.\" ---------------------------------------------------------------------------
.\" Ulm's Oberon System Documentation
.\" Copyright (C) 1989-2001 by University of Ulm, SAI, D-89069 Ulm, Germany
.\" ---------------------------------------------------------------------------
.\"    Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\" 
.\"    Permission is granted to copy and distribute modified versions of
.\" this manual under the conditions for verbatim copying, provided also
.\" that the sections entitled "GNU General Public License" and "Protect
.\" Your Freedom--Fight `Look And Feel'" are included exactly as in the
.\" original, and provided that the entire resulting derived work is
.\" distributed under the terms of a permission notice identical to this
.\" one.
.\" 
.\"    Permission is granted to copy and distribute translations of this
.\" manual into another language, under the above conditions for modified
.\" versions, except that the sections entitled "GNU General Public
.\" License" and "Protect Your Freedom--Fight `Look And Feel'", and this
.\" permission notice, may be included in translations approved by the Free
.\" Software Foundation instead of in the original English.
.\" ---------------------------------------------------------------------------
.de Pg
.nf
.ie t \{\
.	sp 0.3v
.	ps 9
.	ft CW
.\}
.el .sp 1v
..
.de Pe
.ie t \{\
.	ps
.	ft P
.	sp 0.3v
.\}
.el .sp 1v
.fi
..
'\"----------------------------------------------------------------------------
.de Tb
.br
.nr Tw \w'\\$1MMM'
.in +\\n(Twu
..
.de Te
.in -\\n(Twu
..
.de Tp
.br
.ne 2v
.in -\\n(Twu
\fI\\$1\fP
.br
.in +\\n(Twu
.sp -1
..
'\"----------------------------------------------------------------------------
'\" Is [prefix]
'\" Ic capability
'\" If procname params [rtype]
'\" Ef
'\"----------------------------------------------------------------------------
.de Is
.br
.ie \\n(.$=1 .ds iS \\$1
.el .ds iS "
.nr I1 5
.nr I2 5
.in +\\n(I1
..
.de Ic
.sp .3
.in -\\n(I1
.nr I1 5
.nr I2 2
.in +\\n(I1
.ti -\\n(I1
If
\.I \\$1
\.B IN
\.IR caps :
.br
..
.de If
.ne 3v
.sp 0.3
.ti -\\n(I2
.ie \\n(.$=3 \fI\\$1\fP: \fBPROCEDURE\fP(\\*(iS\\$2) : \\$3;
.el \fI\\$1\fP: \fBPROCEDURE\fP(\\*(iS\\$2);
.br
..
.de Ef
.in -\\n(I1
.sp 0.3
..
'\"----------------------------------------------------------------------------
'\"	Strings - made in Ulm (tm 8/87)
'\"
'\"				troff or new nroff
'ds A \(:A
'ds O \(:O
'ds U \(:U
'ds a \(:a
'ds o \(:o
'ds u \(:u
'ds s \(ss
'\"
'\"     international character support
.ds ' \h'\w'e'u*4/10'\z\(aa\h'-\w'e'u*4/10'
.ds ` \h'\w'e'u*4/10'\z\(ga\h'-\w'e'u*4/10'
.ds : \v'-0.6m'\h'(1u-(\\n(.fu%2u))*0.13m+0.06m'\z.\h'0.2m'\z.\h'-((1u-(\\n(.fu%2u))*0.13m+0.26m)'\v'0.6m'
.ds ^ \\k:\h'-\\n(.fu+1u/2u*2u+\\n(.fu-1u*0.13m+0.06m'\z^\h'|\\n:u'
.ds ~ \\k:\h'-\\n(.fu+1u/2u*2u+\\n(.fu-1u*0.13m+0.06m'\z~\h'|\\n:u'
.ds C \\k:\\h'+\\w'e'u/4u'\\v'-0.6m'\\s6v\\s0\\v'0.6m'\\h'|\\n:u'
.ds v \\k:\(ah\\h'|\\n:u'
.ds , \\k:\\h'\\w'c'u*0.4u'\\z,\\h'|\\n:u'
'\"----------------------------------------------------------------------------
.ie t .ds St "\v'.3m'\s+2*\s-2\v'-.3m'
.el .ds St *
.de cC
.IP "\fB\\$1\fP"
..
'\"----------------------------------------------------------------------------
.de Op
.TP
.SM
.ie \\n(.$=2 .BI (+|\-)\\$1 " \\$2"
.el .B (+|\-)\\$1
..
.de Mo
.TP
.SM
.BI \\$1 " \\$2"
..
'\"----------------------------------------------------------------------------
.TH SysSockets 3 "Last change: 24 February 2005" "Release 0.5" "Ulm's Oberon System"
.SH NAME
SysSockets \- BSD interprocess communication
.SH SYNOPSIS
.Pg
TYPE Socket = SysTypes.File;
.sp 0.5
(* protocol families *)
CONST pfUNSPEC    = 0;   (* unspecified *)
CONST pfUNIX      = 1;   (* local to host (pipes, portals) *)
CONST pfINET      = 2;   (* internetwork: UDP, TCP, etc. *)
CONST pfIMPLINK   = 3;   (* arpanet imp addresses *)
CONST pfPUP       = 4;   (* pup protocols: e.g. BSP *)
CONST pfCHAOS     = 5;   (* mit CHAOS protocols *)
CONST pfNS        = 6;   (* XEROX NS protocols *)
CONST pfNBS       = 7;   (* nbs protocols *)
CONST pfECMA      = 8;   (* european computer manufacturers *)
CONST pfDATAKIT   = 9;   (* datakit protocols *)
CONST pfCCITT     = 10;  (* CCITT protocols, X.25 etc *)
CONST pfSNA       = 11;  (* IBM SNA *)
CONST pfDECnet    = 12;  (* DECnet *)
CONST pfDLI       = 13;  (* Direct data link interface *)
CONST pfLAT       = 14;  (* LAT *)
CONST pfHYLINK    = 15;  (* NSC Hyperchannel *)
CONST pfAPPLETALK = 16;  (* Apple Talk *)
CONST pfNIT       = 17;  (* Network Interface Tap *)
CONST pf802       = 18;  (* IEEE 802.2, also ISO 8802 *)
CONST pfOSI       = 19;  (* umbrella for all families used by OSI *)
CONST pfX25       = 20;  (* CCITT X.25 in particular *)
CONST pfOSINET    = 21;  (* AFI = 47, IDI = 4 *)
CONST pfGOSIP     = 22;  (* U.S. Government OSI *)
CONST pfIPX       = 23;  (* Novell Internet Protocol *)
CONST pfROUTE     = 24;  (* Internal Routing Protocol *)
CONST pfLINK      = 25;  (* Link-layer interface *)
CONST pfINET6     = 26;  (* Internet Protocol, Version 6 *)
CONST pfKEY       = 27;  (* Security Association DB socket *)
CONST pfNCA       = 28;  (* NCA socket *)
CONST pfPOLICY    = 29;  (* Security Policy DB socket *)
.sp 0.5
(* socket types *)
CONST dgram     = 1;     (* datagram socket *)
CONST stream    = 2;     (* stream socket *)
CONST raw       = 4;     (* raw-protocol interface *)
CONST rdm       = 5;     (* reliably-delivered message *)
CONST seqpacket = 6;     (* sequenced packet stream *)
.sp 0.5
(* address families *)
CONST afUNSPEC    = pfUNSPEC;
CONST afUNIX      = pfUNIX;
CONST afINET      = pfINET;
CONST afIMPLINK   = pfIMPLINK;
CONST afPUP       = pfPUP;
CONST afCHAOS     = pfCHAOS;
CONST afNS        = pfNS;
CONST afNBS       = pfNBS;
CONST afECMA      = pfECMA;
CONST afDATAKIT   = pfDATAKIT;
CONST afCCITT     = pfCCITT;
CONST afSNA       = pfSNA;
CONST afDECnet    = pfDECnet;
CONST afDLI       = pfDLI;
CONST afLAT       = pfLAT;
CONST afHYLINK    = pfHYLINK;
CONST afAPPLETALK = pfAPPLETALK;
CONST afNIT       = pfNIT;
CONST af802       = pf802;
CONST afOSI       = pfOSI;
CONST afX25       = pfX25;
CONST afOSINET    = pfOSINET;
CONST afGOSIP     = pfGOSIP;
CONST afIPX       = pfIPX;
CONST afROUTE     = pfROUTE;
CONST afLINK      = pfLINK;
CONST afINET6     = pfINET6;
CONST afKEY       = pfKEY;
CONST afNCA       = pfNCA;
CONST afPOLICY    = pfPOLICY;
.sp 0.5
(* socket message flags *)
CONST msgOutOfBand = 1;  (* process out-of-band data *)
CONST msgPeek = 2;       (* peek at incoming message *)
CONST msgDontRoute = 4;  (* send without using routing tables *)
.sp 0.5
(* shutdown options *)
CONST shutReceive  = 0;
CONST shutSend = 1;
CONST shutBoth = 2;
.sp 0.5
(* socket options at socket level -- see <sys/socket.h> *)
CONST socketLevel = 0FFFFH;     (* options for socket level *)
CONST optDebug = 1;             (* turn on debugging info recording *)
CONST optAcceptConn = 2;        (* socket has had listen() *)
CONST optReuseAddr = 4;         (* allow local address reuse *)
CONST optKeepAlive = 8;         (* keep connections alive *)
CONST optDontRoute = 10H;       (* just use interface addresses *)
CONST optBroadcast = 20H;       (* permit sending of broadcast msgs *)
CONST optUseLoopBack = 40H;     (* bypass hardware when possible *)
CONST optLinger = 80H;          (* linger on close if data present *)
CONST optOOBinline = 100H;      (* leave received OOB data in line *)
CONST optSndBuf = 1001H;        (* send buffer size *)
CONST optRcvBuf = 1002H;        (* receive buffer size *)
CONST optSndLoWat = 1003H;      (* send low-water mark *)
CONST optRcvLoWat = 1004H;      (* receive low-water mark *)
CONST optSndTimeO = 1005H;      (* send timeout *)
CONST optRcvTimeO = 1006H;      (* receive timeout *)
CONST optError = 1007H;         (* get error status and clear *)
CONST optType = 1008H;          (* get socket type *)
CONST optProtocol = 1009H;      (* get/set protocol type *)
.sp 0.5
TYPE LingerVal =
   RECORD
      onoff: INTEGER;
      linger: SysTypes.Time;
   END;
TYPE BoolVal = RECORD bool: INTEGER END;
.sp 0.7
PROCEDURE Create(VAR socket: Socket;
                 domain, type, protocol: INTEGER;
                 errors: RelatedEvents.Object) : BOOLEAN;
PROCEDURE Bind(s: Socket; name: ARRAY OF BYTE;
               errors: RelatedEvents.Object) : BOOLEAN;
PROCEDURE Bind3(s: Socket; name: ARRAY OF BYTE;
                namelen: LONGINT;
                errors: RelatedEvents.Object) : BOOLEAN;
PROCEDURE Listen(s: Socket; backlog: INTEGER;
                 errors: RelatedEvents.Object) : BOOLEAN;
.sp 0.3
PROCEDURE Accept(VAR fd: SysTypes.File;
                 s: Socket; VAR addr: ARRAY OF BYTE;
                 errors: RelatedEvents.Object) : BOOLEAN;
PROCEDURE Connect(s: Socket; name: ARRAY OF BYTE;
                  errors: RelatedEvents.Object) : BOOLEAN;
PROCEDURE Connect3(s: Socket; name: ARRAY OF BYTE;
                   namelen: LONGINT;
                   errors: RelatedEvents.Object) : BOOLEAN;
.sp 0.3
PROCEDURE GetName(s: Socket; VAR name: ARRAY OF BYTE;
                  errors: RelatedEvents.Object) : BOOLEAN;
PROCEDURE GetPeerName(s: Socket; VAR name: ARRAY OF BYTE;
                      errors: RelatedEvents.Object) : BOOLEAN;
.sp 0.3
PROCEDURE GetSockOpt(s: Socket; level, optname: INTEGER;
                     VAR optval: ARRAY OF BYTE;
                     errors: RelatedEvents.Object) : BOOLEAN;
PROCEDURE SetSockOpt(s: Socket; level, optname: INTEGER;
                     optval: ARRAY OF BYTE;
                     errors: RelatedEvents.Object) : BOOLEAN;
.sp 0.3
PROCEDURE Shutdown(s: Socket; how: INTEGER;
                   errors: RelatedEvents.Object) : BOOLEAN;
   (* how = shutReceive, shutSend or shutBoth *)
.sp 0.7
(* message operations for sockets *)
PROCEDURE Receive(s: Socket;
                  buf: SysTypes.Address; buflen: SysTypes.Count;
                  flags: INTEGER;
                  errors: RelatedEvents.Object;
                  retry: BOOLEAN; VAR interrupted: BOOLEAN) : SysTypes.Count;
PROCEDURE ReceiveFrom(s: Socket;
                      buf: SysTypes.Address; buflen: SysTypes.Count;
                      flags: INTEGER;
                      VAR from: ARRAY OF BYTE;
                      VAR fromlen: LONGINT;
                      errors: RelatedEvents.Object;
                      retry: BOOLEAN; VAR interrupted: BOOLEAN) : LONGINT;
PROCEDURE Send(s: Socket;
               buf: SysTypes.Address; buflen: SysTypes.Count;
               flags: INTEGER;
               errors: RelatedEvents.Object;
               retry: BOOLEAN; VAR interrupted: BOOLEAN) : BOOLEAN;
PROCEDURE SendTo(s: Socket;
                 buf: SysTypes.Address; buflen: SysTypes.Count;
                 flags: INTEGER;
                 name: ARRAY OF BYTE; namelen: LONGINT;
                 errors: RelatedEvents.Object;
                 retry: BOOLEAN; VAR interrupted: BOOLEAN) : BOOLEAN;
.Pe
.SH DESCRIPTION
.I SysSockets
interfaces the system calls which are related to sockets.
Sockets are endpoints of interprocess communication.
.LP
Many different communication protocols and networks
are accessible as sockets.
The main differences between them are the parameters and
addresses which are necessary to establish a connection.
Once a connection has been established,
sockets behave like other file descriptors and are opened
for reading and writing.
.LP
.I SysSockets
provides a raw access to the system calls.
There exist other modules which offers more convenient
ways to establish connections for specific protocols
and networks, e.g. \fIIPv4TCPSockets(3)\fP
and \fIInetTCP(3)\fP.
.LP
A \fIdomain\fP specifies a communication domain which
uses a common protocol family which shares a address family.
Until now, all implementations restrict protocol families
to one member which uses one unique address type.
Protocol families and address types are given by
integer constants: \fIpf\fPXXX specifies a protocol family
and \fIaF\fPXXX the corresponding address family.
Currently, both values are equal for all protocols.
.LP
In widespread use are three protocols only:
.Tb pfUNIX
.Tp pfUNIX
local connection on one UNIX-machine
.Tp pfINET
IPv4 protocol
.Tp pfINET6
IPv6 protocol
.Te
.LP
There exist different types of sockets,
the most important are \fIstream\fP which provides
a reliable and sequenced two-way connection and
\fIdgram\fP which allows to send unreliable messages (datagrams).
\fIseqpacket\fP works like \fIstream\fP but preserves
packet boundaries.
.LP
.I Create
creates a new socket for the communication domain
\fIdomain\fP (e.g. \fIpfINET\fP)
which is of type \fItype\fP (e.g. \fIstream\fP).
If the communication domain supports more than one
protocol, the protocol may be selected by \fIprotocol\fP.
Normally, only one protocol is available which can be
specified as \fB0\fP.
Sockets which have been just created by \fICreate\fP
are unnamed and unconnected.
Consequently, they are not ready for any input or output operation.
Newly created sockets
should be either prepared to accept connections
(\fIBind\fP, \fIListen\fP and \fIAccept\fP)
or being connected (\fIConnect\fP) to another socket by giving
the address of a peer (the other socket we want
to communicate with).
.LP
.I Bind
assigns \fIname\fP to an unnamed socket.
\fIname\fP should be of the appropiate address type.
Usually, address types have a length of 16 bytes
(some bytes may be unused) where the first 2 bytes are
used select the address family (e.g. \fIafINET\fP).
\fIBind3\fP works like \fIBind\fP but \fInamelen\fP
overrides \fBLEN\fP(\fIname\fP).
.LP
.I Listen
prepares a socket for the acceptance of connections.
Connection requests are queued and \fIbacklog\fP
allows to specify the maximal queue length.
.I Accept
waits for an incoming connection related to the given socket.
The socket must have been named by \fIBind\fP
and prepared by \fIListen\fP.
If successful,
a file descriptor is returned together with the
address of the peer.
Typically, \fIAccept\fP is executed in a loop
which forks for every incoming connection.
.LP
\fIConnect\fP tries to establish a connection to a peer
with the given name.
\fIConnect3\fP works like \fIConnect\fP but
\fInamelen\fP overrides \fBLEN\fP(\fIname\fP).
.LP
.I GetName
returns the current name of the given socket.
.I GetPeerName
returns the name of the peer connected to socket \fIs\fP.
.LP
.I GetSockOpt
and
.I SetSockOpt
allow to retrieve and modify socket options at various levels
of the protocol hierarchy.
Some of the options at the socket level (\fIlevel\fP = \fIsocketLevel\fP)
may be useful in some applications:
.Tb optKeepAlive
.Tp optKeepAlive
asks the system to periodically check the connection for being alive
even when no data is exchanged.
A record of type \fIBoolVal\fP has to be given as \fIoptval\fP.
.Tp optLinger
some applications produce output data for other processes without
waiting for confirmation.
In this case it may be useful to increase the linger time to assure
that the system still tries to transmit the yet not received data
even after \fISysIO.Close\fP or \fIShutdown\fP.
A record of type \fILingerVal\fP has to be given as \fIoptval\fP.
.Te
.LP
.I Shutdown
allows to partially shut down a connection.
.LP
\fIReceive\fP, \fIReceiveFrom\fP,
\fISend\fP and \fISendTo\fP interface
UDP, the unreliable datagram transmission protocol
(socket type \fIdgram\fP).
.SH DIAGNOSTICS
System call failures lead to events of \fISysErrors(3)\fP.
The \fIerrors\fP parameter is passed to \fISysErrors.Raise\fP.
All procedures return
.B FALSE
in error case.
.SH "SEE ALSO"
.Tb getpeername(2)
.Tp accept(2)
\fIAccept\fP
.Tp bind(2)
\fIBind\fP
.Tp connect(2)
\fIConnect\fP
.Tp getpeername(2)
\fIGetPeerName\fP
.Tp getsockname(2)
\fIGetName\fP
.Tp getsockopt(2)
\fIGetSockOpt\fP and \fISetSockOpt\fP
.Tp listen(2)
\fIListen\fP
.Tp receive(2)
\fIReceive\fP and \fIReceiveFrom\fP
.Tp send(2)
\fISend\fP and \fISendTo\fP
.Tp shutdown(2)
\fIShutdown\fP
.Tp socket(2)
\fICreate\fP
.Tp SysErrors(3)
error handling
.Tp SysIO(3)
input and output operations
.Te
.\" ---------------------------------------------------------------------------
.\" $Id: SysSockets.3,v 1.10 2005/02/24 10:12:03 borchert Exp $
.\" ---------------------------------------------------------------------------
.\" $Log: SysSockets.3,v $
.\" Revision 1.10  2005/02/24 10:12:03  borchert
.\" minor fixes of the text
.\"
.\" Revision 1.9  2005/02/24 10:05:01  borchert
.\" reference to Internet(3) replaced by InetTCP(3)
.\"
.\" Revision 1.8  2004/03/03 07:06:36  borchert
.\" pfINET6 added
.\"
.\" Revision 1.7  2001/05/02 06:36:12  borchert
.\" - adapted to Solaris 2.x
.\" - UDP interface changed to allow for more flexible buffer specs
.\"
.\" Revision 1.6  1994/07/04 07:41:12  borchert
.\" GetSockOpt/SetSockOpt & Shutdown & UDP operations added
.\"
.\" Revision 1.5  1992/03/24  09:21:58  borchert
.\" Sockets renamed to SysSockets
.\"
.\" Revision 1.4  1992/01/19  14:47:59  borchert
.\" Connect3 and Bind3 added
.\"
.\" Revision 1.3  1991/11/18  08:14:39  borchert
.\" object parameters for RelatedEvents added
.\"
.\" Revision 1.2  1991/11/12  08:44:03  borchert
.\" Bind ist not necessary prior to Connect
.\"
.\" Revision 1.1  91/11/05  09:27:06  borchert
.\" Initial revision
.\" 
.\" ---------------------------------------------------------------------------
