(* Ulm's Compiler Toolkit
   Copyright (C) 1989-1998 by University of Ulm, SAI, D-89069 Ulm, Germany
   ----------------------------------------------------------------------------
   This file is part of Ulm's Compiler Toolkit.

   Ulm's Compiler Toolkit is free software; you can redistribute it
   and/or modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 1, or
   (at your option) any later version.

   Ulm's Compiler Toolkit is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Ulm's Compiler Toolkit; see the file COPYING.  If not,
   write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA
   02139, USA.
   ----------------------------------------------------------------------------
   E-mail contact: oberon@mathematik.uni-ulm.de
   ----------------------------------------------------------------------------
   $Id$
   ----------------------------------------------------------------------------
   $Log$
   ----------------------------------------------------------------------------
*)

MODULE CDBDaemon;

   IMPORT Args := UnixArguments, BoolArgs, CDBNames, CDBSources, Conclusions,
      (* DebugLoader, *)
      ConstStrings, Containers, Errors, Events, InetTCP, IntArgs, Iterators,
      Jobs, Loader, Names, Networks, Paths, PersistentEvents,
      PersistentObjects, PrivateShards, Process, RelatedEvents,
      RemoteCDBNames, RemoteEvents, RemoteIterators, RemoteNames,
      NameServerMaintenance,
      RemoteObjects, RemoteStreams, Resources, Services, Shadows, Shards,
      StandardContainers, StdCDBNames, Storage, Streams, StringArgs,
      StrListArgs, SysSignals, TransStreams, UnixFiles, UnixNames;

   VAR
      errors: RelatedEvents.Object;
      auth: Shards.Lid;
      read, write, shutdown: Shards.Pot;
      lidType, potType: Services.Type;
      root: CDBNames.Node;
      basedir: ARRAY 512 OF CHAR;
      language: ARRAY 64 OF CHAR;
      intensity: INTEGER;

   PROCEDURE DoTermination(job: Jobs.Job);
   BEGIN
      Process.Exit(Process.indicateSuccess);
   END DoTermination;

   PROCEDURE TerminationHandler(event: Events.Event);
      VAR
	 job: Jobs.Job;
   BEGIN
      IF event IS Resources.Event THEN
	 IF event(Resources.Event).change # Resources.terminated THEN
	    RETURN
	 END;
      END;
      NEW(job); Jobs.Submit(job, DoTermination);
   END TerminationHandler;

   PROCEDURE DieOnTerminationOf(object: Resources.Resource);
      VAR
	 eventType: Events.EventType;
   BEGIN
      Resources.TakeInterest(object, eventType);
      Events.Handler(eventType, TerminationHandler);
   END DieOnTerminationOf;

   PROCEDURE ProcessArgs;
      VAR
	 flag: CHAR;
	 filename: ARRAY 512 OF CHAR;
	 db, ts: Streams.Stream;
	 cont: Containers.Container;

      PROCEDURE CreateLid(VAR lid: Shards.Lid; filename: ARRAY OF CHAR);
	 VAR
	    s: Streams.Stream;
      BEGIN
	 IF ~UnixFiles.Open(s, filename, UnixFiles.read, Streams.onebuf,
	                    errors) THEN
	    Conclusions.Conclude(errors, Errors.fatal, "");
	 END;
	 RelatedEvents.Forward(s, errors);
	 IF ~PersistentObjects.GuardedRead(s, lidType, lid) THEN
	    Conclusions.Conclude(errors, Errors.fatal, filename);
	 END;
      END CreateLid;

      PROCEDURE CreatePot(VAR pot: Shards.Pot; filename: ARRAY OF CHAR);
	 VAR
	    s: Streams.Stream;
	    lid: Shards.Lid;
      BEGIN
	 IF UnixFiles.Open(s, filename, UnixFiles.read, Streams.onebuf,
	                   errors) THEN
	    RelatedEvents.Forward(s, errors);
	    IF ~PersistentObjects.GuardedRead(s, lidType, lid) OR
	          ~PersistentObjects.GuardedRead(s, potType, pot) THEN
	       Conclusions.Conclude(errors, Errors.fatal, filename);
	    END;
	    Streams.Release(s);
	 ELSIF UnixFiles.Open(s, filename, UnixFiles.write + UnixFiles.create,
	                      Streams.onebuf, errors) THEN
	    PrivateShards.Create(pot, lid);
	    IF ~PersistentObjects.Write(s, lid) OR
		  ~PersistentObjects.Write(s, pot) OR
		  ~Streams.Close(s) THEN
	       Conclusions.Conclude(errors, Errors.fatal, filename);
	    END;
	 ELSE
	    Conclusions.Conclude(errors, Errors.fatal, "");
	 END;
      END CreatePot;

   BEGIN (* ProcessArgs *)
      (* by default, the data base may be read by everyone
         but nobody is permitted to change anything
      *)
      auth := NIL;
      Shards.CreateSimplePot(read, (* permissive = *) TRUE);
      Shards.CreateSimplePot(write, (* permissive = *) FALSE);
      shutdown := NIL;
      basedir := "/pub/cdb";
      language := "oberon";
      Args.Init("[-a auth] [-b basedir] [-l language] [-r read-auth] [-s shutdodwn-auth] [-w write-auth] dbname");
      WHILE Args.GetFlag(flag) DO
	 CASE flag OF
	 | "a":   Args.FetchString(filename); CreateLid(auth, filename);
	 | "b":   Args.FetchString(basedir);
	 | "l":   Args.FetchString(language);
	 | "r":   Args.FetchString(filename); CreatePot(read, filename);
	 | "s":   Args.FetchString(filename); CreatePot(shutdown, filename);
	 | "w":   Args.FetchString(filename); CreatePot(write, filename);
	 ELSE
	    Args.Usage;
	 END;
      END;
      Args.FetchString(filename); Args.AllArgs;
      IF shutdown = NIL THEN
	 shutdown := write;
      END;
      IF ~UnixFiles.Open(db, filename, UnixFiles.rdwr + UnixFiles.condcreate,
                         Streams.nobuf, errors) THEN
	 Conclusions.Conclude(errors, Errors.fatal, "");
      END;
      RelatedEvents.Forward(db, errors);
      IF ~TransStreams.Open(ts, db, TransStreams.standard, errors) THEN
	 Conclusions.Conclude(errors, Errors.fatal, filename);
      END;
      RelatedEvents.Forward(ts, errors);
      IF ~StandardContainers.Open(cont, ts, (* auto = *) FALSE, errors) THEN
	 Conclusions.Conclude(errors, Errors.fatal, filename);
      END;
      RelatedEvents.Forward(cont, errors);
      DieOnTerminationOf(cont);
      IF ~StdCDBNames.Create(root, cont, read, write, errors) THEN
	 Conclusions.Conclude(errors, Errors.fatal, filename);
      END;
      DieOnTerminationOf(root);
      RelatedEvents.Forward(root, errors);
   END ProcessArgs;

   PROCEDURE InsertNS;
      VAR
	 basedirNode, subnode: Names.Node;
	 langString: ConstStrings.String;
	 cdbdString: ConstStrings.String;
	 modulesString: ConstStrings.String;
	 maintenanceNode: Names.Node;

      PROCEDURE MkDir(node: Names.Node;
                      dirname: ConstStrings.String;
		      VAR subnode: Names.Node) : BOOLEAN;
	 VAR
	    status: Names.Status;
      BEGIN
	 status := NIL;
	 (*
	 NEW(status);
	 status.perm[Names.examine] := write;
	 status.perm[Names.change] := write;
	 status.perm[Names.read] := read;
	 status.perm[Names.search] := read;
	 status.perm[Names.insert] := write;
	 status.perm[Names.delete] := write;
	 status.perm[Names.destroy] := write;
	 *)
	 IF ~Names.MakeSubnode(node, dirname, status, Names.allCaps,
		  auth, subnode) THEN
	    RETURN FALSE
	 END;
	 DieOnTerminationOf(subnode);
	 RelatedEvents.Forward(node, errors);
      END MkDir;

   BEGIN (* InsertNS *)
      IF ~Paths.GetNode(basedir, auth, errors, basedirNode) THEN
	 Conclusions.Conclude(errors, Errors.fatal, basedir);
      END;
      ConstStrings.Create(langString, language);
      IF ~Names.GetNode(basedirNode, langString, auth, subnode) &
	    ~MkDir(basedirNode, langString, subnode) THEN
	 Conclusions.Conclude(basedirNode, Errors.fatal, basedir);
      END;
      ConstStrings.Create(modulesString, "modules");
      IF ~Names.Insert(subnode, root, modulesString, auth) THEN
	 Conclusions.Conclude(subnode, Errors.fatal, basedir);
      END;
      NameServerMaintenance.Create(maintenanceNode, shutdown);
      ConstStrings.Create(cdbdString, "cdbd");
      IF ~Names.Insert(subnode, maintenanceNode, cdbdString, auth) THEN
	 Conclusions.Conclude(subnode, Errors.fatal, basedir);
      END;
      DieOnTerminationOf(maintenanceNode);
   END InsertNS;

   PROCEDURE OpenAllKindsOfPorts;
      VAR
	 network: Networks.Network;
	 it: Iterators.Iterator;
	 port: Networks.Socket;
	 address: Networks.Address;
   BEGIN
      Networks.GetNetworks(it);
      WHILE Iterators.Get(it, network) DO
	 IF ~Networks.CreateSomeSocket(port, network, address, errors) OR
	       ~RemoteObjects.AddPort(port, address, errors) THEN
	    Conclusions.Conclude(errors, Errors.error, "");
	 END;
      END;
   END OpenAllKindsOfPorts;

BEGIN
   intensity := Storage.Intensity(7);
   NEW(errors); RelatedEvents.QueueEvents(errors);
   Services.SeekType("Shards.Pot", potType);
   Services.SeekType("Shards.Lid", lidType);
   Events.Handler(SysSignals.TERM, TerminationHandler);
   (*
   Conclusions.CatchEvent(Loader.error, Errors.fatal);
   *)
   ProcessArgs;
   OpenAllKindsOfPorts;
   InsertNS;
END CDBDaemon.
