(* Ulm's Oberon Library
   Copyright (C) 1989-2000 by University of Ulm, SAI, D-89069 Ulm, Germany
   ----------------------------------------------------------------------------
   Ulm's Oberon Library is free software; you can redistribute it
   and/or modify it under the terms of the GNU Library General Public
   License as published by the Free Software Foundation; either version
   2 of the License, or (at your option) any later version.

   Ulm's Oberon Library is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   ----------------------------------------------------------------------------
   E-mail contact: oberon@mathematik.uni-ulm.de
   ----------------------------------------------------------------------------
   $Id: AVLTrees.om,v 1.1 2000/05/25 18:30:40 lutz Exp $
   ----------------------------------------------------------------------------
   $Log: AVLTrees.om,v $
   Revision 1.1  2000/05/25  18:30:40  lutz
   Initial revision

   ----------------------------------------------------------------------------
*)

MODULE AVLTrees;
   (* implements AVLTrees (height-balanced binary trees)  *)

   IMPORT
      Conclusions, Disciplines, Events, Iterators, Keys, Objects,
      Priorities, RelatedEvents, Services;

   CONST
      ascending = 0;  (* in ascending order *)
      descending = 1; (* in descending order *)
   
   TYPE
      Order = Iterators.Mode;    (* ascending, descending *)
      AVLDiscipline = POINTER TO AVLDisciplineRec;
      AVLDisciplineRec = 
         RECORD
            (Disciplines.DisciplineRec)
            from, to: Keys.Value;
            key: Keys.Key
         END;

      Node = POINTER TO NodeRec;
      NodeRec =
         RECORD
            (Objects.ObjectRec)     (* because of PROCEDURE Iterate *)
            object: Services.Object;
            height: INTEGER; (* HEIGHT of this NodeRec *)
            left, right: Node;
               (* left and right subtree of this NodeRec *)
         END;
      (* MEMBER(node) := {elem| THERE EXISTS
                          {.left|.right} := seq:
                          node.seq = elem}
         MEMBER(node) := (* DEBUG *)
            | {} iff node = NIL
            | node + MEMBER(node.left) + MEMBER(node.right) OTHERWISE
         HEIGHT(node) :=
            | 0 iff node = NIL
            | 1 + max(HEIGHT(node.left), HEIGHT(node.right)) OTHERWISE

         (1):
            node.height := HEIGHT(node);
         (2):
            |HEIGHT(avlTree.left) - HEIGHT(avlTree.right)| < 2
         (3):
            FOR ALL elem IN MEMBER(node.left):
               Keys.Compare(avlTree.key, node.object, elem.object) > 0
            FOR ALL elem IN MEMBER(node.right):
               Keys.Compare(avlTree.key, node.object, elem.object) < 0
      *)

      AVLTree = POINTER TO AVLTreeRec;
      AVLTreeRec =
         RECORD
            (Services.ObjectRec)
            (* private components *)
            key: Keys.Key;
               (* the avlTree avlTree.root is sorted by this key *)
            card: INTEGER; (* number of members in avlTree.root *)
            root: Node; (* the root of the avlTree *)
         END;
      (* (4): |MEMBER(avlTree.root)| = avlTree.card
         (5): FOR ALL elem IN MEMBER(avlTree.root):
                 Keys.Supported(elem.object, avlTree.key) = TRUE
      *)

   CONST
      keyUsed = 0; (* object with this value is already in the tree *)
      noSuchKey = 1; (* an object with this value is not in the tree *)
      wrongKey = 2; (* object does not support the supposed type of key
                    *)
      errorcodes = 3;

   TYPE
      ErrorCode = SHORTINT;
      ErrorEvent = POINTER TO ErrorEventRec;
      ErrorEventRec =
         RECORD
            (Events.EventRec)
            errorcode: ErrorCode;
            avlTree: AVLTree;
            object: Services.Object;
            key: Keys.Value;
         END;

   VAR
      avlTreeType: Services.Type;
      avlDiscId: Disciplines.Identifier;
      error: Events.EventType;
      errormsg: ARRAY errorcodes OF Events.Message;


   PROCEDURE InitErrorHandling;
   BEGIN
      Events.Define(error);
      Events.SetPriority(error, Priorities.liberrors);
      errormsg[keyUsed] := "this key is already used";
      errormsg[noSuchKey] := "there is no such key";
      errormsg[wrongKey] := "wrong type of key for this AVLTree"
   END InitErrorHandling;

   PROCEDURE Error(avlTree: AVLTree; object: Services.Object;
                      key: Keys.Value; errorcode: ErrorCode);
      (* PRE: Events.Define(error) was called; errormsg[0..errorcodes]
            is defined; avlTree # NIL
         POST: RelatedEvents.Raise(avlTree, event) with appropiate event
            is called;
      *)
      VAR
         event: ErrorEvent;
   BEGIN
      NEW(event);
      event.type := error;
      event.message := errormsg[errorcode];
      event.errorcode := errorcode;
      event.avlTree := avlTree;
      event.object := object;
      event.key := key;
      RelatedEvents.Raise(avlTree, event)
   END Error;

   PROCEDURE Create(VAR new: AVLTree; key: Keys.Key);
      (* Creates a new AVLTree; all elements inserted in this tree must
         suppport the Keys.Key "key", cause the tree is sorted by this
         key.
      *)
   BEGIN
      ASSERT(key # NIL);
      NEW(new);
      new.key := key;
      new.card := 0; new.root := NIL;
      (* (4) AND (5) holds. *)
      Services.Init(new, avlTreeType);
      RelatedEvents.QueueEvents(new)
   END Create;

   PROCEDURE GetKey(avlTree: AVLTree; VAR key: Keys.Key);
      (* retrieves the Type of the Key, by which the tree is sorted. *)
   BEGIN
      ASSERT(avlTree # NIL);
      key := avlTree.key
   END GetKey;

   PROCEDURE Height(node: Node): INTEGER;
      (* PRE: IF node # NIL THEN (1) holds FOR {node.left, node.right}
         POST: RETURN := HEIGHT(node);
      *)
      VAR
         heightLeft, heightRight: INTEGER;

      PROCEDURE Max(val1, val2: INTEGER): INTEGER;
      BEGIN
         IF val1 > val2 THEN RETURN val1
         ELSE RETURN val2
         END
      END Max;

   BEGIN
      IF node = NIL THEN RETURN 0 END;
      IF node.left # NIL THEN heightLeft := node.left.height
      ELSE heightLeft := 0
      END;
      IF node.right # NIL THEN heightRight := node.right.height
      ELSE heightRight := 0
      END;
      RETURN 1 + Max(heightLeft, heightRight)
   END Height;

   PROCEDURE GetBalance(node: Node): INTEGER;
      (* PRE: node # NIL AND (1) holds FOR {node.left, node.right}
         POST: RETURN = HEIGHT(node.left) - HEIGHT(node.right)
      *)
   BEGIN
      ASSERT(node # NIL);
      RETURN Height(node.left) - Height(node.right)
   END GetBalance;

   PROCEDURE Balance(VAR node: Node);
      (* PRE: FOR ALL elem IN MEMBER('node),
            elem # node: (1), (2), (3)
            AND node: (3) AND
            |HEIGHT(node.left) - HEIGTH(node.right)| <= 2)
         POST: MEMBER('node) = MEMBER(node') AND
            FOR ALL elem IN MEMBER(node'): (1), (2) AND (3) AND
            |'node.height - node'.height| <= 1
      *)
      VAR
         balance: INTEGER;
         l, r,                      (* the subtrees of node *)
         ll, lr, rl, rr,            (* the subsubtrees of node *)
         lrl, lrr, rll, rlr: Node;  (* the subsubsubtrees of node *)
   BEGIN
      (*
         Syntax used:
                 (N)     name of the node.
                 H-1     possible heights
                 H-2     of the node.
                 / \     links to left and
                /   \    right subtree.

         Case 1:
         =======                       (L)
                 (W)                    H 
                 H+1                   H+1
                 / \                   / \
                /   \                 /   \
              (L)   (R)             (LL)  (W)
               H    H-2    --->     H-1   H-1 
              / \                          H 
             /   \                        / \
           (LL) (LR)                     /   \
           H-1   H-2                   (LR)  (R)
                 H-1                   H-2   H-2
                                       H-1
         Case 2: symmetric in "N" to Case 1
         =======
         Case 3:
         =======                      (LR)
                 (W)                    H
                 H+1                   / \
                 / \                  /   \
                /   \                /     \
              (L)   (R)            (L)     (W)
               H    H-2    --->    H-1     H-1
              / \                  / |     | \ 
             /   \                /  |     |  \ 
           (LL) (LR)           (LL)(LRL) (LRR)(R)
           H-2   H-1            H-2 H-2   H-2 H-2
                 / \                H-3   H-3 
                /   \     
             (LRL) (LRR)
              H-2   H-2
              H-3   H-3
         Case 4: symmetric in "N" to Case 3
         =======
      *)
      IF node = NIL THEN RETURN END;
      balance := GetBalance(node);
      ASSERT(ABS(balance) <= 2);
      l := node.left; r := node.right;
      IF balance > 1 THEN (* Case 1 OR Case 3, l # NIL *)
         ll := l.left; lr := l.right;
         IF (ll # NIL) & (ll.height = l.height - 1) THEN
            (* Case 1 *)
            node.left := lr; (* node.right := r; *)
            node.height := Height(node);
            (* l.left := ll; *) l.right := node;
            node := l
         ELSE ASSERT(lr # NIL); (* Case 3 *)
            lrl := lr.left; lrr := lr.right;
            (* l.left := ll; *) l.right := lrl; l.height := Height(l);
            node.left := lrr; (* node.right := r; *)
            node.height := Height(node);
            lr.left := l; lr.right := node;
            node := lr
         END
      ELSIF balance < -1 THEN (* Case 2 OR Case 4, r # NIL *)
         rl := r.left; rr := r.right;
         IF ((rr # NIL) & (rr.height = r.height - 1)) THEN
            (* Case 2 *)
            (* node.left := l; *) node.right := rl;
            node.height := Height(node);
            r.left := node; (* r.right := rr; *)
            node := r
         ELSE ASSERT(rl # NIL); (* Case 4 *)
            rll := rl.left; rlr := rl.right;
            r.left := rlr; (* r.right := rr; *) r.height := Height(r);
            (* node.left := l; *) node.right := rll;
            node.height := Height(node);
            rl.left := node; rl.right := r;
            node := rl
         END
      END;
      node.height := Height(node);
      RETURN
   END Balance;

   PROCEDURE AddObject(VAR node: Node; object: Services.Object;
                          avlTree: AVLTree): BOOLEAN;
      (* PRE: NOT THERE IS elem in MEMBER('node):
            Keys.Compare(avlTree.key, object, elem.object) = 0
            FOR ALL elem IN MEMBER('node): (1), (2), (3); 'avlTree: (4)
         POST: MEMBER(node') = MEMBER('node) + newnode,
            newnode.object = object;
            FOR ALL elem IN MEMBER(node'): (1), (2), (3); avlTree': (4)
         EXEP: Error(keyUsed)
      *)
      VAR
         balance,                              (* balance of the node *)
         heightLeft, heightRight, (* height of left and right subtree *)
         compare: INTEGER;              (* ordering of object to node *)
         success: BOOLEAN;               (* has object been inserted? *)
   BEGIN
      IF node = NIL THEN
         NEW(node);
         node.object := object;
         node.height := 1; node.left := NIL; node.right := NIL;
         INC(avlTree.card);
         RETURN TRUE
      END; (* node # NIL *)
      compare := Keys.Compare(avlTree.key, node.object, object);
      IF compare = 0 THEN
         Error(avlTree, object, NIL, keyUsed); RETURN FALSE
      ELSIF compare < 0 THEN
         success := AddObject(node.right, object, avlTree)
      ELSE (* ASSERT(compare > 0); *)
         success := AddObject(node.left, object, avlTree)
      END; (* success is well defined *)
      IF ~success THEN RETURN FALSE
      ELSE Balance(node); RETURN TRUE
      END
   END AddObject;

   PROCEDURE Add(avlTree: AVLTree; object: Services.Object): BOOLEAN;
      (* object is inserted in the AVLTree avlTree. If an object with
         the same key is already in the tree, an ErrorEvent (keyUsed)
         is raised.
      *)
   BEGIN
      ASSERT((avlTree # NIL) & (object # NIL));
      IF ~ Keys.Supported(object, avlTree.key) THEN
         Error(avlTree, object, NIL, wrongKey); RETURN FALSE
      ELSE
         RETURN AddObject(avlTree.root, object, avlTree)
      END
   END Add;

   PROCEDURE RemoveObject(VAR node: Node; keyval: Keys.Value;
                          avlTree: AVLTree): BOOLEAN;
      (* PRE: THERE IS delnode in MEMBER('node):
            Keys.Compare(avlTree.key, keyval, delnode.object) = 0
            FOR ALL elem IN MEMBER('node): (1), (2), (3); 'avlTree: (4)
         POST: MEMBER(node') = MEMBER('node) - {delnode}
            FOR ALL elem IN MEMBER(node'): (1), (2), (3); avlTree': (4)
         EXEP: Error(noSuchKey)
      *)
      VAR
         help: Node;
         nodeValue: Keys.Value;
                             (* the value of the key from node.object *)
         balance,                              (* balance of the node *)
         heightLeft, heightRight, (* height of left and right subtree *)
         compare: INTEGER;              (* ordering of object to node *)
         success: BOOLEAN;               (* has object been inserted? *)

      PROCEDURE GetGreatest(VAR node: Node): Node;
         (* PRE: node # NIL;
               FOR ALL elem IN MEMBER('node): (1), (2), (3);
            POST: MEMBER('node) = MEMBER(node') + {RETURN};
               FOR ALL elem IN MEMBER(node'):
               Keys.Compare(avlTree.key, elem.object, RETURN.object) < 0
               FOR ALL elem IN MEMBER(node'): (1), (2), (3);
         *)
         VAR
            greatest: Node;
      BEGIN
         IF node.right # NIL THEN
            greatest := GetGreatest(node.right)
         ELSE (* node.right = NIL *)
            greatest := node;
            node := node.left
         END;
            (* FOR ALL elem IN MEMBER(node):
               Keys.Compare(avlTree.key, elem.object, greatest.object)
               < 0
            *)
         Balance(node);
         RETURN greatest
      END GetGreatest;

   BEGIN
      IF node = NIL THEN
         Error(avlTree, NIL, keyval, noSuchKey); RETURN FALSE
      END; ASSERT(node # NIL);
      Keys.Extract(node.object, avlTree.key, nodeValue);
      compare := Keys.CompareKeyValues(avlTree.key, nodeValue, keyval);
      IF compare = 0 THEN
         DEC(avlTree.card);
         IF node.left = NIL THEN node := node.right; RETURN TRUE
         ELSIF node.right = NIL THEN node := node.left; RETURN TRUE
         ELSE (* node.left # NIL AND node.right # NIL *)
            help := GetGreatest(node.left); (* help # NIL *)
            help.left := node.left; help.right := node.right;
            node := help;
            Balance(node);
            RETURN TRUE
         END
      ELSIF compare < 0 THEN
         success := RemoveObject(node.right, keyval, avlTree)
      ELSE (* ASSERT(compare > 0); *)
         success := RemoveObject(node.left, keyval, avlTree)
      END; (* success is well defined *)
      IF ~ success THEN RETURN FALSE
      ELSE Balance(node); RETURN TRUE
      END
   END RemoveObject;

   PROCEDURE Remove(avlTree: AVLTree; keyval: Keys.Value): BOOLEAN;
      (* the object with the Keys.Value keyval is removed from avlTree.
         If such an object in not in the tree, an ErrorEvent (noSuchKey)
         is raised.
      *)
   BEGIN
      ASSERT((avlTree # NIL) & (keyval # NIL));
      IF ~ Keys.Compatible(keyval, avlTree.key) THEN
         Error(avlTree, NIL, keyval, wrongKey); RETURN FALSE
      ELSE
         RETURN RemoveObject(avlTree.root, keyval, avlTree)
      END
   END Remove;

   PROCEDURE GetEntry(avlTree: AVLTree; node: Node;
                         keyval: Keys.Value): Node;
      (* PRE: FOR ALL elem IN MEMBER('node): (3);
            THERE IS elem in MEMBER('node):
            Keys.Compare(avlTree.key, keyval, elem.object) = 0
         POST: RETURN = elem;
         EXEP: RETURN = NIL;
      *)
      VAR
         nodeValue: Keys.Value;
         compare: INTEGER;
   BEGIN
      IF node = NIL THEN RETURN NIL END;
      Keys.Extract(node.object, avlTree.key, nodeValue);
      compare := Keys.CompareKeyValues(avlTree.key, nodeValue, keyval);
      IF compare = 0 THEN RETURN node
      ELSIF compare < 0 THEN
         RETURN GetEntry(avlTree, node.right, keyval)
      ELSE (* ASSERT(compare > 0); *)
         RETURN GetEntry(avlTree, node.left, keyval)
      END
   END GetEntry;

   PROCEDURE Get(avlTree: AVLTree; keyval: Keys.Value;
                    VAR object: Services.Object): BOOLEAN;
      (* retrieves the object with Keys.Value keyval from avlTree. If
         such an object does not exist, an ErrorEvent (noSuchKey) is
         raised.
      *)
      VAR elem: Node;
   BEGIN
      ASSERT((avlTree # NIL) & (keyval # NIL));
      IF ~ Keys.Compatible(keyval, avlTree.key) THEN
         Error(avlTree, object, NIL, wrongKey); RETURN FALSE
      END;
      elem := GetEntry(avlTree, avlTree.root, keyval);
      IF elem = NIL THEN
         object := NIL;
         Error(avlTree, object, keyval, noSuchKey);
         RETURN FALSE
      ELSE
         object := elem.object;
         RETURN TRUE
      END
   END Get;

   PROCEDURE Card(avlTree: AVLTree): INTEGER;
      (* returns the number of objects in avlTree *)
   BEGIN
      ASSERT(avlTree # NIL);
      RETURN avlTree.card
   END Card;

   PROCEDURE Iterate(it: Iterators.Iterator; node: Objects.Object;
                     mode: Iterators.Mode);
      CONST
         beneath = -1;
         in = 0;
         above = 1;
      TYPE
         Where = INTEGER; (* beneath .. above *)
      VAR
         avlDiscipline: AVLDiscipline;
         (* attached to it; contains additional data for iteration *)
         ok: BOOLEAN;
         nodeValue: Keys.Value;
         where: Where;
         (* is actual node beneath/in/above the specified range for
            iteration *)
   BEGIN
      IF node = NIL THEN RETURN END;
      WITH node: Node DO
         ok := Disciplines.Seek(it, avlDiscId, avlDiscipline);
         ASSERT(ok);
         Keys.Extract(node.object, avlDiscipline.key, nodeValue);
         IF ((avlDiscipline.from # NIL) &
            (Keys.CompareKeyValues(avlDiscipline.key, nodeValue,
               avlDiscipline.from) < 0))
         THEN
            where := beneath
            (* FOR ALL elem IN MEMBER(node):
               Keys.Extract(elem.object, avlDiscipline.key, elemValue);
               Keys.CompareKeyValues(avlDiscipine.key, elemValue,
                  avlDiscipline.from) < 0
               => nur noch node.right absuchen!
            *)
         ELSIF ((avlDiscipline.to # NIL) &
            (Keys.CompareKeyValues(avlDiscipline.key, nodeValue,
               avlDiscipline.to) > 0))
         THEN
            where := above
            (* FOR ALL elem IN MEMBER(node):
               Keys.Extract(elem.object, avlDiscipline.key, elemValue);
               Keys.CompareKeyValues(avlDiscipine.key, elemValue,
                  avlDiscipline.to) > 0
               => nur noch node.left absuchen!
            *)
         ELSE
            where := in;
         END; (* where is well defined *)
         IF mode = ascending THEN
            IF where # beneath THEN Iterate(it, node.left, mode) END;
            IF where = in THEN Iterators.Yield(it, node.object) END;
            IF where # above THEN Iterate(it, node.right, mode) END
         ELSE ASSERT(mode = descending);
            IF where # above THEN Iterate(it, node.right, mode) END;
            IF where = in THEN Iterators.Yield(it, node.object) END;
            IF where # beneath THEN Iterate(it, node.left, mode) END
         END
      END
   END Iterate;

   PROCEDURE GetEntries(avlTree: AVLTree; order: Order;
                            from, to: Keys.Value; VAR it: Iterators.Iterator);
      (* iterate through all Objects with Keys.Value between from and to;
         if NIL is given for from respectively to, then iteration starts
         at the first object respectively stops at the last object in
         avlTree; iteration must not be carried on over change operations
      *)
      VAR avlDiscipline: AVLDiscipline;
   BEGIN
      ASSERT(avlTree # NIL);
      Iterators.Create(it, Iterate, avlTree.root, order);
      NEW(avlDiscipline); avlDiscipline.id := avlDiscId;
      avlDiscipline.from := from; avlDiscipline.to := to;
      avlDiscipline.key := avlTree.key;
      Disciplines.Add(it, avlDiscipline)
   END GetEntries;

   PROCEDURE Exists(avlTree: AVLTree; keyValue: Keys.Value): BOOLEAN;
      (* is the Keys.Value keyValue already used in the AVLTree avlTree?
      *)
      VAR node: Node;
   BEGIN
      ASSERT((avlTree # NIL) & (keyValue # NIL));
      IF ~ Keys.Compatible(keyValue, avlTree.key) THEN
         Error(avlTree, NIL, keyValue, wrongKey); RETURN FALSE
      END;
      node := GetEntry(avlTree, avlTree.root, keyValue);
      IF node = NIL THEN RETURN FALSE
      ELSE RETURN TRUE
      END
   END Exists;

   PROCEDURE MaxHeight(avlTree: AVLTree): INTEGER;
      (* returns HEIGHT(avlTree)
      *)
      PROCEDURE RecursiveHeight(node: Node): INTEGER;
         VAR
            height, heightLeft, heightRight: INTEGER;
         PROCEDURE Max(val1, val2: INTEGER): INTEGER;
         BEGIN
            IF val1 > val2 THEN RETURN val1
            ELSE RETURN val2
            END
         END Max;
      BEGIN
         IF node = NIL THEN RETURN 0 END;
         heightLeft := RecursiveHeight(node.left);
         heightRight := RecursiveHeight(node.right);
         ASSERT(ABS(heightLeft - heightRight) < 2);
         height := 1 + Max(heightLeft, heightRight);
         ASSERT(height = node.height);
         RETURN height
      END RecursiveHeight;
   BEGIN
      RETURN RecursiveHeight(avlTree.root)
   END MaxHeight;

BEGIN
   InitErrorHandling;
   avlDiscId := Disciplines.Unique();
   Services.CreateType(avlTreeType, "AVLTrees.AVLTree", "")
END AVLTrees.
