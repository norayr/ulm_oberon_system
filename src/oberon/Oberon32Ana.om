(* PLEASE DO NOT EDIT:
   Generated by instantiate_template on Tue Apr  3 17:57:23 MEST 2001
   from templates/Oberon%%Ana.om
*)

(* Ulm's Oberon Library
   Copyright (C) 1989-1998 by University of Ulm, SAI, D-89069 Ulm, Germany
   ----------------------------------------------------------------------------
   Ulm's Oberon Library is free software; you can redistribute it
   and/or modify it under the terms of the GNU Library General Public
   License as published by the Free Software Foundation; either version
   2 of the License, or (at your option) any later version.

   Ulm's Oberon Library is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   ----------------------------------------------------------------------------
   E-mail contact: oberon@mathematik.uni-ulm.de
   ----------------------------------------------------------------------------
   $Id$
   ----------------------------------------------------------------------------
   $Log$
   ----------------------------------------------------------------------------
*)

MODULE Oberon32Analyzer;

   IMPORT CompilerObjects, Iterators, Oberon32, RelatedEvents, Scopes,
      Sym := OberonSymbols, Sym32 := Oberon32Symbols;

   PROCEDURE Process(module: Sym.Ident; errors: RelatedEvents.Object);

      PROCEDURE ProcessScope(scope: Scopes.Scope);
	 VAR
	    it: Iterators.Iterator;
	    ident: Sym.Ident;
	    size: Oberon32.Size;
	    type: Sym.Type;
	    at: Sym32.Attribute;
      BEGIN
	 Scopes.GetIterator(scope, it);
	 WHILE Iterators.Get(it, ident) DO
	    ASSERT(ident.type # NIL);
	    type := ident.type;
	    IF ident.class = Sym.constC THEN
	       IF Sym32.CheckConst(module, ident.constexpr, errors) THEN
		  CompilerObjects.GetAttachment(ident.constexpr, at);
		  IF at = NIL THEN
		     type := NIL;
		  ELSE
		     type := at.type;
		  END;
	       ELSE
		  type := NIL; Sym32.SetTypeToNIL(module, ident.constexpr);
	       END;
	    ELSIF ident.class = Sym.procedureC THEN
	       IF ident.scope # NIL THEN
		  ProcessScope(ident.scope);
	       END;
	       Sym32.Fold(module, ident.body, errors);
	    END;
	    IF type # NIL THEN
	       size := Sym32.GetSize(module, type, errors);
	    END;
	 END;
      END ProcessScope;

   BEGIN (* Process *)
      ProcessScope(module.scope);
      Sym32.Fold(module, module.body, errors);
   END Process;

END Oberon32Analyzer.
