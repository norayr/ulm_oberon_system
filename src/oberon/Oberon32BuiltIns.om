(* PLEASE DO NOT EDIT:
   Generated by instantiate_template on Thu Apr  5 16:40:50 MEST 2001
   from templates/Oberon%%Bui.om
*)

(* Ulm's Oberon Library
   Copyright (C) 1989-1998 by University of Ulm, SAI, D-89069 Ulm, Germany
   ----------------------------------------------------------------------------
   Ulm's Oberon Library is free software; you can redistribute it
   and/or modify it under the terms of the GNU Library General Public
   License as published by the Free Software Foundation; either version
   2 of the License, or (at your option) any later version.

   Ulm's Oberon Library is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   ----------------------------------------------------------------------------
   E-mail contact: oberon@mathematik.uni-ulm.de
   ----------------------------------------------------------------------------
   $Id$
   ----------------------------------------------------------------------------
   $Log$
   ----------------------------------------------------------------------------
*)

MODULE Oberon32BuiltIns;

   (* support constant folding for standard functions of
      OberonStdProcedures

      principles of operation:

      all supporting procedures are of the following type and will
      be called by Oberon32Symbols.FoldProcedureCalls

      PROCEDURE FoldXXX(bproc: Sym.BuiltInProcedure; module: Sym.Ident;
		        args: Sym.Attribute; VAR result: Sym32.Attribute;
		        errors: RelatedEvents.Object) : BOOLEAN;

      returns TRUE if it is able to fold the standard function call:

      - bproc is the built-in procedure in question, usually ignored
        because we have individual folding procedures for all standard
	functions
      - module is likewise ignored but in general needed for
	CompilerObjects.InclAttachment; note that the returned
	attribute (in case of success) is handled by FoldProcedureCalls
      - args is a linear list of (already folded) arguments;
        CompilerObjects.GetAttachment (or short Get in this module)
	allows to access the associated folded argument if present;
      - result is set to a constant attribute in case of success;
        note that Oberon32Symbols.CreateAttribute may be used for
	new attributes or Oberon32Symbols.CreateCopyAttribute(result, at)
	to take a copy of an existing attribute

      only those standard functions need to be supported that may
      legally appear in constant expressions, i.e. adrF and bitF may
      be omitted

      care has to be taken that no generic numeric types will
      be returned, i.e. Short and Long have to fix the result types
   *)

   IMPORT IEEE754Double, BaseTypes := OberonBaseTypes, CompilerErrors,
      CompilerObjects, Conversions := Oberon32Conversions, Oberon32,
      Oberon8Chars, OberonTypes, Procs := OberonStdProcedures, RelatedEvents,
      Streams, Sym := OberonSymbols, Sym32 := Oberon32Symbols, SYS := SYSTEM,
      Write;

   CONST
      intlen = Oberon32.integerLen;
   TYPE
      Integer = Oberon32.Integer;
      Real = Oberon32.Real;

   PROCEDURE Get(at: Sym.Attribute; VAR atdisc: Sym32.Attribute);
   BEGIN
      CompilerObjects.GetAttachment(at, atdisc);
   END Get;

   PROCEDURE GetType(at: Sym.Attribute) : Sym.Type;
      VAR
	 atdisc: Sym32.Attribute;
   BEGIN
      IF at = NIL THEN RETURN NIL END;
      Get(at, atdisc);
      IF atdisc = NIL THEN RETURN at.type END;
      RETURN atdisc.type
   END GetType;

   PROCEDURE CreateCopyOfAttribute(VAR atdisc: Sym32.Attribute;
				   at: Sym.Attribute);
      VAR
	 atd: Sym32.Attribute;
   BEGIN
      Get(at, atd);
      IF atd = NIL THEN
	 Sym32.CreateAttribute(atd);
	 atd.type := GetType(at);
	 atd.kind := Sym32.noConst;
	 atdisc := atd;
      ELSE
	 Sym32.CreateCopyAttribute(atdisc, atd);
      END;
   END CreateCopyOfAttribute;

   PROCEDURE ArithShift(val, n: Integer) : Integer;
   BEGIN
      IF n >= intlen THEN
	 val := 0;
      ELSIF n <= -intlen THEN
	 IF val < 0 THEN
	    val := -1;
	 ELSE
	    val := 0;
	 END;
      ELSIF n > 0 THEN (* shift left *)
	 WHILE n > 0 DO
	    val := val * 2;
	    DEC(n);
	 END;
      ELSIF n < 0 THEN (* shift right *)
	 WHILE n < 0 DO
	    val := val DIV 2;
	    INC(n);
	 END;
      END;
      RETURN val
   END ArithShift;

   PROCEDURE LogShift(val, n: Integer) : Integer;
      VAR
	 neg: BOOLEAN; (* sign bit to be set? *)
   BEGIN
      IF (n >= intlen) OR (n <= -intlen) THEN
	 val := 0;
      ELSIF n > 0 THEN (* shift left *)
	 WHILE n > 0 DO
	    neg := val >= MAX(Integer) DIV 2 + 1;
	    val := val * 2;
	    DEC(n);
	 END;
	 IF neg & (val >= 0) THEN
	    val := MIN(Integer) + val;
	 END;
      ELSIF n < 0 THEN (* shift right *)
	 IF val < 0 THEN
	    val := (val + MAX(Integer) + 1) DIV 2 +
		   MAX(Integer) DIV 2 + 1;
	    INC(n);
	 END;
	 WHILE n < 0 DO
	    val := val DIV 2;
	    INC(n);
	 END;
      END;
      RETURN val
   END LogShift;

   PROCEDURE Rotate(val, n: Integer) : Integer;
      VAR
	 neg: BOOLEAN;
   BEGIN
      n := n MOD intlen;
      (* n in [0..intlen-1] --- rotate left *)
      WHILE n > 0 DO
	 neg := val < 0;
	 IF neg THEN
	    val := val + MAX(Integer) + 1;
	 END;
	 val := val * 2;
	 IF neg THEN
	    INC(val);
	 END;
	 DEC(n);
      END;
      RETURN val
   END Rotate;

   PROCEDURE Abs(bproc: Sym.BuiltInProcedure; module: Sym.Ident;
		 args: Sym.Attribute; VAR result: Sym32.Attribute;
		 errors: RelatedEvents.Object) : BOOLEAN;
      VAR
	 at: Sym32.Attribute;

      PROCEDURE Error(msg: ARRAY OF CHAR);
	 VAR
	    es: Streams.Stream;
      BEGIN
	 CompilerErrors.Open(es);
	 CompilerErrors.At1(es, args.loc);
	 Write.StringS(es, msg);
	 CompilerErrors.Close(es, errors);
      END Error;

   BEGIN
      Get(args, at); IF at = NIL THEN RETURN FALSE END;
      IF at.kind = Sym32.noConst THEN RETURN FALSE END;
      Sym32.CreateCopyAttribute(result, at);
      CASE result.kind OF
      | Sym32.integerConst:
	    IF result.intval = MIN(Oberon32.Integer) THEN
	       Error("cannot apply ABS on minimal integer value");
	       result.intval := MAX(Oberon32.Integer);
	    ELSE
	       result.intval := ABS(result.intval);
	    END;
      | Sym32.realConst:
	    result.realval := ABS(result.realval);
      END;
      RETURN TRUE
   END Abs;

   PROCEDURE Ash(bproc: Sym.BuiltInProcedure; module: Sym.Ident;
		 args: Sym.Attribute; VAR result: Sym32.Attribute;
		 errors: RelatedEvents.Object) : BOOLEAN;
      VAR
	 at1, at2: Sym32.Attribute;
   BEGIN
      Get(args, at1); IF at1 = NIL THEN RETURN FALSE END;
      IF at1.kind = Sym32.noConst THEN RETURN FALSE END;
      args := args.next; Get(args, at2); IF at2 = NIL THEN RETURN FALSE END;
      IF at2.kind = Sym32.noConst THEN RETURN FALSE END;
      ASSERT(at1.kind = Sym32.integerConst);
      ASSERT(at2.kind = Sym32.integerConst);
      Sym32.CreateCopyAttribute(result, at1);
      result.type := BaseTypes.longint;
      result.intval := ArithShift(result.intval, at2.intval);
      RETURN TRUE
   END Ash;

   PROCEDURE Cap(bproc: Sym.BuiltInProcedure; module: Sym.Ident;
		 args: Sym.Attribute; VAR result: Sym32.Attribute;
		 errors: RelatedEvents.Object) : BOOLEAN;
      VAR
	 at: Sym32.Attribute;
	 ch: Oberon8Chars.Value;

      PROCEDURE GetCh(s: Streams.Stream) : CHAR;
	 VAR
	    ch: CHAR;
      BEGIN
	 Streams.SetPos(s, 0);
	 IF ~Streams.ReadByte(s, ch) THEN ch := 0X END;
	 Streams.SetPos(s, 0);
	 RETURN ch
      END GetCh;

      PROCEDURE Error(msg: ARRAY OF CHAR);
	 VAR
	    es: Streams.Stream;
      BEGIN
	 CompilerErrors.Open(es);
	 CompilerErrors.At1(es, args.loc);
	 Write.StringS(es, msg);
	 CompilerErrors.Close(es, errors);
      END Error;

   BEGIN
      Get(args, at); IF at = NIL THEN RETURN FALSE END;
      IF at.kind = Sym32.noConst THEN RETURN FALSE END;
      CASE at.kind OF
      | Sym32.charConst:
	    ch := at.charval;
      | Sym32.stringConst:
	    ch := GetCh(at.stringval);
      END;
      IF (ch < "a") OR (ch > "z") THEN
	 Error("argument of CAP is not a lower case character");
	 RETURN FALSE
      END;
      Sym32.CreateAttribute(result);
      result.kind := Sym32.charConst;
      result.type := BaseTypes.char;
      result.charval := CAP(ch);
      RETURN TRUE
   END Cap;

   PROCEDURE Chr(bproc: Sym.BuiltInProcedure; module: Sym.Ident;
		 args: Sym.Attribute; VAR result: Sym32.Attribute;
		 errors: RelatedEvents.Object) : BOOLEAN;
      VAR
	 at: Sym32.Attribute;
	 val: Integer;

      PROCEDURE Error(msg: ARRAY OF CHAR);
	 VAR
	    es: Streams.Stream;
      BEGIN
	 CompilerErrors.Open(es);
	 CompilerErrors.At1(es, args.loc);
	 Write.StringS(es, msg);
	 CompilerErrors.Close(es, errors);
      END Error;

   BEGIN (* Chr *)
      Get(args, at); IF at = NIL THEN RETURN FALSE END;
      IF at.kind = Sym32.noConst THEN RETURN FALSE END;
      ASSERT(at.kind = Sym32.integerConst);
      IF (at.intval < 0) OR (at.intval > ORD(MAX(CHAR))) THEN
	 Error("argument out of range");
	 val := 0;
      ELSE
	 val := at.intval;
      END;
      Sym32.CreateAttribute(result);
      result.kind := Sym32.charConst;
      result.type := BaseTypes.char;
      result.charval := CHR(val);
      RETURN TRUE
   END Chr;

   PROCEDURE Entier(bproc: Sym.BuiltInProcedure; module: Sym.Ident;
		    args: Sym.Attribute; VAR result: Sym32.Attribute;
		    errors: RelatedEvents.Object) : BOOLEAN;
      VAR
	 at: Sym32.Attribute;
	 realval: Real;

      PROCEDURE Error(msg: ARRAY OF CHAR);
	 VAR
	    es: Streams.Stream;
      BEGIN
	 CompilerErrors.Open(es);
	 CompilerErrors.At1(es, args.loc);
	 Write.StringS(es, msg);
	 CompilerErrors.Close(es, errors);
      END Error;

   BEGIN (* Entier *)
      Get(args, at); IF at = NIL THEN RETURN FALSE END;
      IF at.kind = Sym32.noConst THEN RETURN FALSE END;
      ASSERT(at.kind = Sym32.realConst);
      realval := at.realval;
      IF (realval >= 0) & (realval > MAX(Integer)) OR
            (realval < 0) & (realval <= MIN(Integer)) THEN
	 Error("argument out of range");
	 realval := 1;
      END;
      Sym32.CreateAttribute(result);
      result.kind := Sym32.integerConst;
      result.type := BaseTypes.longint;
      result.intval := ENTIER(at.realval);
      RETURN TRUE
   END Entier;

   PROCEDURE Len(bproc: Sym.BuiltInProcedure; module: Sym.Ident;
		 args: Sym.Attribute; VAR result: Sym32.Attribute;
		 errors: RelatedEvents.Object) : BOOLEAN;
      VAR
	 varat: Sym.Attribute;
	 dimat, lenat: Sym32.Attribute;
	 type: Sym.Type;
	 dim, dimcount, length: Integer;
	 dyn: BOOLEAN; (* dynamic length? *)
	 es: Streams.Stream;

      PROCEDURE SetResult(intval: Integer);
      BEGIN
	 Sym32.CreateAttribute(result);
	 result.kind := Sym32.integerConst;
	 result.type := BaseTypes.longint;
	 result.intval := length;
      END SetResult;

   BEGIN (* Len *)
      varat := args; type := varat.type;
      args := args.next;
      IF args # NIL THEN
	 Get(args, dimat); IF dimat = NIL THEN RETURN FALSE END;
	 ASSERT(dimat.kind = Sym32.integerConst);
	 dim := dimat.intval;
      ELSE
	 dim := 0; (* default *)
      END;

      dimcount := 0;
      LOOP
	 ASSERT(type # NIL);
	 IF type.form # Sym.array THEN
	    CompilerErrors.Open(es);
	    IF dimcount = 0 THEN
	       CompilerErrors.At1(es, varat.loc);
	       Write.StringS(es, "is not an array");
	    ELSE
	       CompilerErrors.At1(es, args.loc);
	       IF varat.type.loc # NIL THEN
		  CompilerErrors.Ref(es, varat.type.loc);
	       END;
	       Write.StringS(es, "has not that many dimensions");
	    END;
	    CompilerErrors.Close(es, errors);
	    SetResult(1); (* avoid additional error msgs *)
	    RETURN TRUE
	 END;
	 dyn := type.dyn;
	 IF dim = 0 THEN EXIT END;
	 DEC(dim); INC(dimcount);
	 type := type.element;
      END;

      IF dyn THEN
	 (* unable to fold it *)
	 RETURN FALSE
      END;

      ASSERT((type # NIL) & (type.form = Sym.array) & (type.length # NIL));
      IF ~Sym32.CheckConst(module, type.length, errors) THEN
	 SetResult(1); (* avoid additional error msgs *)
	 RETURN TRUE
      END;
      Get(type.length, lenat);
      ASSERT(lenat.kind = Sym32.integerConst);
      length := lenat.intval;

      SetResult(length);
      RETURN TRUE
   END Len;

   PROCEDURE Long(bproc: Sym.BuiltInProcedure; module: Sym.Ident;
		  args: Sym.Attribute; VAR result: Sym32.Attribute;
		  errors: RelatedEvents.Object) : BOOLEAN;
      VAR
	 at: Sym32.Attribute;
	 type: Sym.Type;

      PROCEDURE Error(msg: ARRAY OF CHAR);
	 VAR
	    es: Streams.Stream;
      BEGIN
	 CompilerErrors.Open(es);
	 CompilerErrors.At1(es, args.loc);
	 Write.StringS(es, msg);
	 CompilerErrors.Close(es, errors);
      END Error;

   BEGIN (* Long *)
      CreateCopyOfAttribute(result, args);
      type := result.type;
      ASSERT(type.form IN Sym.specforms);
      ASSERT(~(type.spec = Sym.generic));
      CASE type.spec OF
      | Sym.standard:   
	    CASE type.stdlength OF
	    | Sym.long:
		  Error("is already as long as possible");
	    | Sym.medium:
		  CASE type.form OF
		  | Sym.integer:    type := BaseTypes.longint;
		  | Sym.cardinal:   type := BaseTypes.longcard;
		  | Sym.real:       type := BaseTypes.longreal;
		  END;
	    | Sym.short:
		  CASE type.form OF
		  | Sym.integer:    type := BaseTypes.integer;
		  | Sym.cardinal:   type := BaseTypes.cardinal;
		  | Sym.real:       type := BaseTypes.real;
		  END;
	    END;
      | Sym.explicit:   
	    IF type.form = Sym.integer THEN
	       IF type.bits >= Oberon32.intLen THEN
		  type := BaseTypes.longint;
	       ELSE
		  type := BaseTypes.integer;
	       END;
	    ELSIF type.form = Sym.cardinal THEN
	       IF type.bits >= Oberon32.intLen THEN
		  type := BaseTypes.longcard;
	       ELSE
		  type := BaseTypes.cardinal;
	       END;
	    ELSE
	       ASSERT(type.form = Sym.real);
	       IF type.bits >= Oberon32.realLen THEN
		  type := BaseTypes.longreal;
	       ELSE
		  type := BaseTypes.real;
	       END;
	    END;
      END;
      result.type := type;
      RETURN TRUE
   END Long;

   PROCEDURE Lsh(bproc: Sym.BuiltInProcedure; module: Sym.Ident;
		 args: Sym.Attribute; VAR result: Sym32.Attribute;
		 errors: RelatedEvents.Object) : BOOLEAN;
      VAR
	 at1, at2: Sym32.Attribute;
   BEGIN
      Get(args, at1); IF at1 = NIL THEN RETURN FALSE END;
      args := args.next; Get(args, at2); IF at2 = NIL THEN RETURN FALSE END;
      IF at1.kind = Sym32.noConst THEN RETURN FALSE END;
      IF at2.kind = Sym32.noConst THEN RETURN FALSE END;
      ASSERT(at1.kind = Sym32.integerConst);
      ASSERT(at2.kind = Sym32.integerConst);
      Sym32.CreateCopyAttribute(result, at1);
      result.type := BaseTypes.longint;
      result.intval := LogShift(result.intval, at2.intval);
      RETURN TRUE
   END Lsh;

   PROCEDURE Max(bproc: Sym.BuiltInProcedure; module: Sym.Ident;
		 args: Sym.Attribute; VAR result: Sym32.Attribute;
		 errors: RelatedEvents.Object) : BOOLEAN;
      VAR
	 type: Sym.Type;
	 bits: INTEGER;

      PROCEDURE Error(msg: ARRAY OF CHAR);
	 VAR
	    es: Streams.Stream;
      BEGIN
	 CompilerErrors.Open(es);
	 CompilerErrors.At1(es, args.loc);
	 Write.StringS(es, msg);
	 CompilerErrors.Close(es, errors);
      END Error;

   BEGIN (* Max *)
      ASSERT(args.mode = Sym.typeAt);
      type := GetType(args);
      Sym32.CreateAttribute(result); result.type := type;
      ASSERT(~(type.form IN Sym.specforms) OR (type.spec # Sym.generic));
      CASE type.form OF
      | Sym.integer, Sym.address:
	    result.kind := Sym32.integerConst;
	    IF type.form = Sym.integer THEN
	       CASE type.spec OF
	       | Sym.standard:
		     CASE type.stdlength OF
		     | Sym.long:    bits := Oberon32.longIntLen;
		     | Sym.medium:  bits := Oberon32.intLen;
		     | Sym.short:   bits := Oberon32.shortIntLen;
		     END;
	       | Sym.explicit:
		     bits := type.bits;
	       END;
	    ELSE
	       bits := 8 * Oberon32.addressSize;
	    END;
	    IF bits <= Oberon32.integerLen THEN
	       (* assuming 2-complement *)
	       result.intval := ASH(1, bits-2) - 1 + ASH(1, bits-2);
	    ELSIF bits <= Oberon32.maxIntegerLenOnTarget THEN
	       Error("implementation restriction: representable on target architecture only");
	       RETURN FALSE
	    ELSE
	       Error("not supported on target architecture");
	       RETURN FALSE
	    END;
      | Sym.cardinal:
	    Error("implementation restriction: not yet supported");
	    RETURN FALSE
      | Sym.real:
	    IF OberonTypes.Identical(type, BaseTypes.real) THEN
	       result.kind := Sym32.realConst;
	       result.realval := IEEE754Double.Max();
	    ELSE
	       Error("implementation restriction: not yet supported");
	       RETURN FALSE
	    END;
      | Sym.set:
	    result.type := BaseTypes.integer;
	    result.kind := Sym32.integerConst;
	    result.intval := Oberon32.maxSetLenOnTarget - 1;
      | Sym.char:
	    result.kind := Sym32.charConst;
	    result.charval := MAX(Oberon8Chars.Value);
      END;
      RETURN TRUE
   END Max;

   PROCEDURE Min(bproc: Sym.BuiltInProcedure; module: Sym.Ident;
		 args: Sym.Attribute; VAR result: Sym32.Attribute;
		 errors: RelatedEvents.Object) : BOOLEAN;
      VAR
	 type: Sym.Type;
	 bits: INTEGER;

      PROCEDURE Error(msg: ARRAY OF CHAR);
	 VAR
	    es: Streams.Stream;
      BEGIN
	 CompilerErrors.Open(es);
	 CompilerErrors.At1(es, args.loc);
	 Write.StringS(es, msg);
	 CompilerErrors.Close(es, errors);
      END Error;

   BEGIN (* Min *)
      ASSERT(args.mode = Sym.typeAt);
      type := GetType(args);
      Sym32.CreateAttribute(result); result.type := type;
      ASSERT(~(type.form IN Sym.specforms) OR (type.spec # Sym.generic));
      CASE type.form OF
      | Sym.integer, Sym.address:
	    result.kind := Sym32.integerConst;
	    IF type.form = Sym.integer THEN
	       CASE type.spec OF
	       | Sym.standard:
		     CASE type.stdlength OF
		     | Sym.long:    bits := Oberon32.longIntLen;
		     | Sym.medium:  bits := Oberon32.intLen;
		     | Sym.short:   bits := Oberon32.shortIntLen;
		     END;
	       | Sym.explicit:
		     bits := type.bits;
	       END;
	    ELSE
	       bits := 8 * Oberon32.addressSize;
	    END;
	    IF bits <= Oberon32.integerLen THEN
	       (* assuming 2-complement *)
	       result.intval := ASH(1, bits-2) * (-2);
	    ELSIF bits <= Oberon32.maxIntegerLenOnTarget THEN
	       Error("implementation restriction: representable on target architecture only");
	       RETURN FALSE
	    ELSE
	       Error("not supported on target architecture");
	       RETURN FALSE
	    END;
      | Sym.cardinal:
	    Error("implementation restriction: not yet supported");
	    RETURN FALSE
      | Sym.real:
	    IF OberonTypes.Identical(type, BaseTypes.real) THEN
	       result.kind := Sym32.realConst;
	       result.realval := IEEE754Double.Min();
	    ELSE
	       Error("implementation restriction: not yet supported");
	       RETURN FALSE
	    END;
      | Sym.set:
	    result.type := BaseTypes.integer;
	    result.kind := Sym32.integerConst;
	    result.intval := 0;
      | Sym.char:
	    result.kind := Sym32.charConst;
	    result.charval := 0X;
      END;
      RETURN TRUE
   END Min;

   PROCEDURE Odd(bproc: Sym.BuiltInProcedure; module: Sym.Ident;
		 args: Sym.Attribute; VAR result: Sym32.Attribute;
		 errors: RelatedEvents.Object) : BOOLEAN;
      VAR
	 at: Sym32.Attribute;
   BEGIN
      Get(args, at); IF at = NIL THEN RETURN FALSE END;
      IF at.kind = Sym32.noConst THEN RETURN FALSE END;
      ASSERT(at.kind = Sym32.integerConst);
      Sym32.CreateAttribute(result);
      result.kind := Sym32.booleanConst;
      result.type := BaseTypes.boolean;
      result.boolval := ODD(at.intval);
      RETURN TRUE
   END Odd;

   PROCEDURE Ord(bproc: Sym.BuiltInProcedure; module: Sym.Ident;
		 args: Sym.Attribute; VAR result: Sym32.Attribute;
		 errors: RelatedEvents.Object) : BOOLEAN;
      VAR
	 at: Sym32.Attribute;
	 val: Integer;

      PROCEDURE GetCh(s: Streams.Stream) : CHAR;
	 VAR
	    ch: CHAR;
      BEGIN
	 Streams.SetPos(s, 0);
	 IF ~Streams.ReadByte(s, ch) THEN ch := 0X END;
	 Streams.SetPos(s, 0);
	 RETURN ch
      END GetCh;

   BEGIN (* Ord *)
      Get(args, at); IF at = NIL THEN RETURN FALSE END;
      IF at.kind = Sym32.noConst THEN RETURN FALSE END;
      Sym32.CreateAttribute(result);
      result.kind := Sym32.integerConst;
      result.type := BaseTypes.integer;
      CASE at.kind OF
      | Sym32.integerConst:
	    result.intval := at.intval;
      | Sym32.charConst:
	    result.intval := ORD(at.charval);
      | Sym32.stringConst:
	    result.intval := ORD(GetCh(at.stringval));
      END;
      RETURN TRUE
   END Ord;

   PROCEDURE Rot(bproc: Sym.BuiltInProcedure; module: Sym.Ident;
		 args: Sym.Attribute; VAR result: Sym32.Attribute;
		 errors: RelatedEvents.Object) : BOOLEAN;
      VAR
	 at1, at2: Sym32.Attribute;
   BEGIN
      Get(args, at1); IF at1 = NIL THEN RETURN FALSE END;
      IF at1.kind = Sym32.noConst THEN RETURN FALSE END;
      args := args.next; Get(args, at2); IF at2 = NIL THEN RETURN FALSE END;
      IF at2.kind = Sym32.noConst THEN RETURN FALSE END;
      Sym32.CreateCopyAttribute(result, at1);
      ASSERT(at1.kind = Sym32.integerConst);
      ASSERT(at2.kind = Sym32.integerConst);
      result.type := BaseTypes.longint;
      result.intval := Rotate(result.intval, at2.intval);
      RETURN TRUE
   END Rot;

   PROCEDURE Short(bproc: Sym.BuiltInProcedure; module: Sym.Ident;
		   args: Sym.Attribute; VAR result: Sym32.Attribute;
		   errors: RelatedEvents.Object) : BOOLEAN;
      VAR
	 at: Sym32.Attribute;
	 type: Sym.Type;

      PROCEDURE Error(msg: ARRAY OF CHAR);
	 VAR
	    es: Streams.Stream;
      BEGIN
	 CompilerErrors.Open(es);
	 CompilerErrors.At1(es, args.loc);
	 Write.StringS(es, msg);
	 CompilerErrors.Close(es, errors);
      END Error;

   BEGIN (* Short *)
      CreateCopyOfAttribute(result, args);
      type := result.type;
      ASSERT(type.form IN Sym.specforms);
      ASSERT(~(type.spec = Sym.generic));
      CASE type.spec OF
      | Sym.standard:   
	    CASE type.stdlength OF
	    | Sym.long:
		  CASE type.form OF
		  | Sym.integer:    type := BaseTypes.integer;
		  | Sym.cardinal:   type := BaseTypes.cardinal;
		  | Sym.real:       type := BaseTypes.real;
		  END;
	    | Sym.medium:
		  CASE type.form OF
		  | Sym.integer:    type := BaseTypes.shortint;
		  | Sym.cardinal:   type := BaseTypes.shortcard;
		  | Sym.real:       type := BaseTypes.shortreal;
		  END;
	    | Sym.short:
		  Error("is already as short as possible");
	    END;
      | Sym.explicit:   
	    IF type.form = Sym.integer THEN
	       IF type.bits > Oberon32.intLen THEN
		  type := BaseTypes.integer;
	       ELSE
		  type := BaseTypes.shortint;
	       END;
	    ELSIF type.form = Sym.cardinal THEN
	       IF type.bits > Oberon32.intLen THEN
		  type := BaseTypes.cardinal;
	       ELSE
		  type := BaseTypes.shortcard;
	       END;
	    ELSE
	       ASSERT(type.form = Sym.real);
	       IF type.bits > Oberon32.realLen THEN
		  type := BaseTypes.real;
	       ELSE
		  type := BaseTypes.shortreal;
	       END;
	    END;
      END;
      result.type := type;
      RETURN TRUE
   END Short;

   PROCEDURE Size(bproc: Sym.BuiltInProcedure; module: Sym.Ident;
		  args: Sym.Attribute; VAR result: Sym32.Attribute;
		  errors: RelatedEvents.Object) : BOOLEAN;
      VAR
	 type: Sym.Type;
   BEGIN (* Size *)
      ASSERT(args.mode = Sym.typeAt);
      type := GetType(args);
      Sym32.CreateAttribute(result);
      result.kind := Sym32.integerConst;
      result.type := BaseTypes.longint;
      result.intval := Sym32.GetSize(module, type, errors);
      RETURN TRUE
   END Size;

   PROCEDURE Val(bproc: Sym.BuiltInProcedure; module: Sym.Ident;
		 args: Sym.Attribute; VAR result: Sym32.Attribute;
		 errors: RelatedEvents.Object) : BOOLEAN;
      VAR
	 type: Sym.Type;
	 at: Sym32.Attribute;

      PROCEDURE Error(msg: ARRAY OF CHAR);
	 VAR
	    es: Streams.Stream;
      BEGIN
	 CompilerErrors.Open(es);
	 CompilerErrors.At1(es, args.loc);
	 Write.StringS(es, msg);
	 CompilerErrors.Close(es, errors);
      END Error;

      PROCEDURE ToInteger(at: Sym32.Attribute) : Integer;
	 VAR
	    intval: Integer;
      BEGIN
	 CASE at.kind OF
	 | Sym32.integerConst:   RETURN at.intval
	 | Sym32.realConst:      RETURN ENTIER(at.realval)
	 | Sym32.setConst:       IF ~Conversions.SetToInteger(module,
				       at.setval, intval) THEN
				    Error("unable to convert this set");
				    intval := 0;
				 END;
				 RETURN intval
	 | Sym32.charConst:      RETURN ORD(at.charval)
	 | Sym32.booleanConst:   IF at.boolval THEN
				    RETURN 1
				 ELSE
				    RETURN 0
				 END;
	 | Sym32.nilConst:	 RETURN 0
	 END;
      END ToInteger;

      PROCEDURE ToReal(at: Sym32.Attribute) : Real;
      BEGIN
	 IF at.kind = Sym32.realConst THEN
	    RETURN at.realval
	 ELSE
	    RETURN ToInteger(at)
	 END;
      END ToReal;

   BEGIN (* Val *)
      ASSERT(args.mode = Sym.typeAt);
      type := GetType(args);
      args := args.next;
      Get(args, at);
      IF (at = NIL) OR (at.kind = Sym32.stringConst) THEN RETURN FALSE END;
      IF at.kind = Sym32.noConst THEN RETURN FALSE END;
      Sym32.CreateAttribute(result);
      result.type := type;
      IF type.form IN Sym.numeric THEN
	 IF type.form = Sym.real THEN
	    result.kind := Sym32.realConst;
	    result.realval := ToReal(at);
	 ELSE
	    result.kind := Sym32.integerConst;
	    result.intval := ToInteger(at);
	 END;
      ELSIF type.form IN {Sym.char, Sym.byte} THEN
	 result.kind := Sym32.charConst;
	 result.charval := CHR(ToInteger(at));
      ELSIF type.form = Sym.boolean THEN
	 result.kind := Sym32.booleanConst;
	 result.boolval := ToInteger(at) # 0;
      ELSIF type.form = Sym.set THEN
	 result.kind := Sym32.setConst;
	 IF ~Conversions.IntegerToSet(module, ToInteger(at), result.setval) THEN
	    Error("unable to convert this to SET");
	    result.setval := {};
	 END;
      ELSE
	 (* we give up here and reject to fold it *)
	 RETURN FALSE
      END;
      RETURN TRUE
   END Val;

   PROCEDURE Support(ident: Sym.Ident; fold: Sym32.FoldBuiltInProc);
      VAR
	 type: Sym.Type;
   BEGIN
      ASSERT((ident # NIL) & (ident.class = Sym.procedureC));
      type := ident.type;
      ASSERT((type # NIL) & (type.form = Sym.proceduretype) & type.builtin);
      Sym32.InitBuiltInProc(type.builtinproc, fold);
   END Support;

   PROCEDURE Init;
   BEGIN
      Support(Procs.absF,    Abs);
      Support(Procs.ashF,    Ash);
      Support(Procs.capF,    Cap);
      Support(Procs.chrF,    Chr);
      Support(Procs.entierF, Entier);
      Support(Procs.lenF,    Len);
      Support(Procs.longF,   Long);
      Support(Procs.lshF,    Lsh);
      Support(Procs.maxF,    Max);
      Support(Procs.minF,    Min);
      Support(Procs.oddF,    Odd);
      Support(Procs.ordF,    Ord);
      Support(Procs.rotF,    Rot);
      Support(Procs.shortF,  Short);
      Support(Procs.sizeF,   Size);
      Support(Procs.valF,    Val);
   END Init;

BEGIN
   Init;
END Oberon32BuiltIns.
