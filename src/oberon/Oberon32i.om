(* PLEASE DO NOT EDIT:
   Generated by instantiate_template on Wed Apr 28 16:24:12 MEST 2004
   from templates/Oberon%%.om
*)

(* Ulm's Oberon Library
   Copyright (C) 1989-1998 by University of Ulm, SAI, D-89069 Ulm, Germany
   ----------------------------------------------------------------------------
   Ulm's Oberon Library is free software; you can redistribute it
   and/or modify it under the terms of the GNU Library General Public
   License as published by the Free Software Foundation; either version
   2 of the License, or (at your option) any later version.

   Ulm's Oberon Library is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   ----------------------------------------------------------------------------
   E-mail contact: oberon@mathematik.uni-ulm.de
   ----------------------------------------------------------------------------
   $Id$
   ----------------------------------------------------------------------------
   $Log$
   ----------------------------------------------------------------------------
*)

MODULE Oberon32i;

   (* template that carries all architecture-dependent parameters for
      the other templates and other architecture-dependent libraries
   *)

   IMPORT SYS := SYSTEM, Types; (* possible sources of basic types *)

   CONST
      archname = "32i";

   TYPE
      Integer = Types.Int32;
	 (* integer type that should be used to hold constant integer values *)
   CONST
      integerLen = 32; (* length of Integer in bits *)
      maxIntegerLenOnTarget = 32;
	 (* maximal supported integer length on target architecture;
	    if this is < integerLen we have some severe implementation
	    restrictions because some constant values are not supported
	 *)

   TYPE
      Real = REAL;

   TYPE
      Set = SET;
   CONST
      setLen = 32; (* length of Set in bits *)
      maxSetLenOnTarget = 32;
	 (* maximal support set length on target architecture;
	    if this is < setLen we have some severe implementation
	    restrictions because not all possible set values are supported
	 *)

   CONST
      (* length in bits (must be multiplies of 8) *)
      shortIntLen = 8;
      intLen = 32;
      longIntLen = 32;

      shortRealLen = 32;
      realLen = 64;
      longRealLen = 64;

   TYPE
      Size = LONGINT; (* generic type for storage use in bytes *)
   CONST
      maxsize = MAX(LONGINT); (* maximal size of a contiguous object *)
      minoffset = - maxsize - 1; (* minimal offset *)
      maxalign = 16;
	 (* maximal alignment, i.e. this alignment is to be guaranteed
	    if we do not know what will be allocated next
	 *)

   CONST
      (* size and alignments of basic types; they may be negative
         for unsupported variants
      *)
      int8Size = 1;          int8Align = 1;
      int16Size = 2;        int16Align = 2;
      int32Size = 4;        int32Align = 4;
      int64Size = 8;        int64Align = 8;

      real32Size = 4;      real32Align = 4;
      real64Size = 8;      real64Align = 8;
      real96Size = 12;      real96Align = 8;
      real128Size = 16;    real128Align = 16;

      booleanSize = 1;    booleanAlign = 1;
      addressSize = 4;    addressAlign = 4;
      pointerSize = 4;    pointerAlign = 4;
      charSize = 1;          charAlign = 1;
      setSize = 4;            setAlign = 4;
      byteSize = 1;          byteAlign = 1;

      coroutineSize = 4;
      coroutineAlign = 4;
      proceduretypeSize = 4;
      proceduretypeAlign = 4;

      recordAlign = 4; (* minimal alignment *)
      arrayAlign = 4; (* minimal alignment *)

END Oberon32i.
