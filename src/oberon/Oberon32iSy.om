(* PLEASE DO NOT EDIT:
   Generated by instantiate_template on Wed Apr 28 16:24:14 MEST 2004
   from templates/Oberon%%Sym.om
*)

(* Ulm's Oberon Library
   Copyright (C) 1989-1998 by University of Ulm, SAI, D-89069 Ulm, Germany
   ----------------------------------------------------------------------------
   Ulm's Oberon Library is free software; you can redistribute it
   and/or modify it under the terms of the GNU Library General Public
   License as published by the Free Software Foundation; either version
   2 of the License, or (at your option) any later version.

   Ulm's Oberon Library is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   ----------------------------------------------------------------------------
   E-mail contact: oberon@mathematik.uni-ulm.de
   ----------------------------------------------------------------------------
   $Id$
   ----------------------------------------------------------------------------
   $Log$
   ----------------------------------------------------------------------------
*)

MODULE Oberon32iSymbols;

   (* various architecture-dependent extensions of data types
      of OberonSymbols
   *)

   IMPORT NetIO, IEEE754Double, BaseTypes := OberonBaseTypes,
      CompilerErrors, CompilerObjects, Disciplines, IEEE, Lex := OberonLex,
      Oberon32i, Oberon32iIntegers, Oberon8Chars, OberonTypes,
      PersistentObjects, RelatedEvents, Services, Streams,
      Sym := OberonSymbols, Texts, Write;

   TYPE
      Integer = Oberon32i.Integer;
      Real = Oberon32i.Real;
      Set = Oberon32i.Set;
      Char = Oberon8Chars.Value;
      Size = Oberon32i.Size;

   CONST
      integerConst = 0;
      realConst = 1;
      setConst = 2;
      charConst = 3;
      booleanConst = 4;
      stringConst = 5;
      nilConst = 6;
      noConst = 7; (* not a constant; carries just type information *)
   TYPE
      ConstantKind = SHORTINT; (* integerConst .. *)
      Attribute = POINTER TO AttributeRec;
      AttributeRec =
	 RECORD
	    (CompilerObjects.AttachmentRec)
	       (* may be attached to OberonSymbols.Attribute *)
	    type: Sym.Type;
	    kind: ConstantKind;
	    intval: Integer;
	    realval: Real;
	    setval: Set;
	    charval: Char;
	    boolval: BOOLEAN;
	    stringval: Streams.Stream;
	 END;
   VAR
      attributeType: Services.Type;

   CONST
      forwardDir = 0;
      backwardDir = 1;
   TYPE
      Direction = SHORTINT;

   TYPE
      FoldBuiltInProc =
	 PROCEDURE (
	       builtinproc: Sym.BuiltInProcedure;
	       module: Sym.Ident;
	       args: Sym.Attribute;
	       VAR result: Attribute;
	       errors: RelatedEvents.Object
	    ) : BOOLEAN;
	 (* return TRUE if result is non-NIL *)

   TYPE
      BuiltInDiscipline = POINTER TO BuiltInDisciplineRec;
      BuiltInDisciplineRec =
	 RECORD
	    (Disciplines.DisciplineRec)
	    fold: FoldBuiltInProc;
	 END;
   VAR
      bdid: Disciplines.Identifier;

   TYPE
      FieldDiscipline = POINTER TO FieldDisciplineRec;
      FieldDisciplineRec =
	 RECORD
	    (CompilerObjects.AttachmentRec)
	    offset: Size;
	 END;
   VAR
      fdtype: Services.Type;

   TYPE
      TypeDiscipline = POINTER TO TypeDisciplineRec;
      TypeDisciplineRec =
	 RECORD
	    (CompilerObjects.AttachmentRec)
	    type: Sym.Type;
	       (* usually the type we are attached to; but it may
		  be more specific in case of constants
	       *)
	    size, align: Size;
	    length: Size; (* for arrays *)
	 END;
   VAR
      tdtype: Services.Type;

   VAR
      typeType: Services.Type; (* that of Sym.Type *)

   TYPE
      TemporaryTypeDiscipline = POINTER TO TemporaryTypeDisciplineRec;
      TemporaryTypeDisciplineRec =
	 RECORD
	    (Disciplines.DisciplineRec)
	    type: Sym.Type; (* back link *)
	    next: TemporaryTypeDiscipline;
	       (* list of marks belonging to a module *)
	 END;
   VAR
      ttdiscid: Disciplines.Identifier;

   TYPE
      ModuleDiscipline = POINTER TO ModuleDisciplineRec;
      ModuleDisciplineRec =
	 RECORD
	    (Disciplines.DisciplineRec)
	    ttdiscs: TemporaryTypeDiscipline;
	 END;
   VAR
      mdiscid: Disciplines.Identifier;

   (* === forward declarations ============================================ *)

   PROCEDURE ^ CheckConst(module: Sym.Ident; at: Sym.Attribute;
                          errors: RelatedEvents.Object) : BOOLEAN;

   PROCEDURE ^ Align(VAR size: Size; align: Size;
		     loc: CompilerObjects.Location;
                     errors: RelatedEvents.Object);

   PROCEDURE ^ Allocate(size, align: Size;
                        VAR next, offset: Size; dir: Direction;
		        loc: CompilerObjects.Location;
		        errors: RelatedEvents.Object);
   PROCEDURE ^ AdaptType(module: Sym.Ident; type, like: Sym.Type);

   PROCEDURE ^ SetTypeToNIL(module: Sym.Ident; at: Sym.Attribute);

   PROCEDURE ^ GetSize(module: Sym.Ident; type: Sym.Type;
                       errors: RelatedEvents.Object) : Size;

   (* === PO if of Attribute ============================================== *)

   PROCEDURE ReadText(s: Streams.Stream; VAR text: Streams.Stream) : BOOLEAN;
      VAR
	 defined: BOOLEAN;
	 length: Streams.Count;
   BEGIN
      IF ~NetIO.ReadBoolean(s, defined) THEN RETURN FALSE END;
      IF ~defined THEN text := NIL; RETURN TRUE END;
      IF ~NetIO.ReadLongInt(s, length) THEN RETURN FALSE END;
      Texts.Open(text);
      RETURN Streams.Copy(s, text, length) &
             Streams.Seek(text, 0, Streams.fromStart)
   END ReadText;

   PROCEDURE WriteText(s: Streams.Stream; text: Streams.Stream) : BOOLEAN;
      VAR
	 length: Streams.Count;
   BEGIN
      IF ~NetIO.WriteBoolean(s, text # NIL) THEN RETURN FALSE END;
      IF text = NIL THEN RETURN TRUE END;
      RETURN Streams.Seek(text, 0, Streams.fromEnd) &
             Streams.Tell(text, length) &
	     Streams.Seek(text, 0, Streams.fromStart) &
	     NetIO.WriteLongInt(s, length) &
	     Streams.Copy(text, s, length) &
	     Streams.Seek(text, 0, Streams.fromStart)
   END WriteText;

   PROCEDURE InternalCreateAttribute(VAR object: PersistentObjects.Object);
      VAR
	 at: Attribute;
   BEGIN
      NEW(at); PersistentObjects.Init(at, attributeType);
      at.intval := 0; at.realval := 0.0;
      at.setval := {}; at.boolval := FALSE; at.stringval := NIL;
      object := at;
   END InternalCreateAttribute;

   PROCEDURE ReadAttribute(s: Streams.Stream;
                           object: PersistentObjects.Object) : BOOLEAN;
   BEGIN
      WITH object: Attribute DO
	 IF ~CompilerObjects.GuardedRead(s, typeType, object.type) OR
	       ~NetIO.ReadShortInt(s, object.kind) THEN
	    RETURN FALSE
	 END;
	 CASE object.kind OF
	 | integerConst:   RETURN NetIO.ReadLongInt(s, object.intval)
	 | realConst:      RETURN NetIO.ReadReal(s, object.realval)
	 | setConst:       RETURN NetIO.ReadSet(s, object.setval)
	 | charConst:      RETURN NetIO.ReadChar(s, object.charval)
	 | booleanConst:   RETURN NetIO.ReadBoolean(s, object.boolval)
	 | stringConst:    RETURN ReadText(s, object.stringval)
	 | nilConst:       RETURN TRUE
	 | noConst:        RETURN TRUE
	 ELSE
	    RETURN FALSE (* invalid value of kind *)
	 END;
      END;
   END ReadAttribute;

   PROCEDURE WriteAttribute(s: Streams.Stream;
                            object: PersistentObjects.Object) : BOOLEAN;
   BEGIN
      WITH object: Attribute DO
	 IF ~CompilerObjects.Write(s, object.type) OR
	       ~NetIO.WriteShortInt(s, object.kind) THEN
	    RETURN FALSE
	 END;
	 CASE object.kind OF
	 | integerConst:   RETURN NetIO.WriteLongInt(s, object.intval)
	 | realConst:      RETURN NetIO.WriteReal(s, object.realval)
	 | setConst:       RETURN NetIO.WriteSet(s, object.setval)
	 | charConst:      RETURN NetIO.WriteChar(s, object.charval)
	 | booleanConst:   RETURN NetIO.WriteBoolean(s, object.boolval)
	 | stringConst:    RETURN WriteText(s, object.stringval)
	 | nilConst:       RETURN TRUE
	 | noConst:        RETURN TRUE
	 END;
      END;
   END WriteAttribute;

   (* === PO if of FieldDiscipline ======================================== *)

   PROCEDURE CreateFieldDiscipline(VAR object: PersistentObjects.Object);
      VAR
	 fdisc: FieldDiscipline;
   BEGIN
      NEW(fdisc); PersistentObjects.Init(fdisc, fdtype);
      fdisc.offset := 0;
      object := fdisc;
   END CreateFieldDiscipline;

   PROCEDURE ReadFieldDiscipline(s: Streams.Stream;
                                 object: PersistentObjects.Object) : BOOLEAN;
   BEGIN
      WITH object: FieldDiscipline DO
	 RETURN NetIO.ReadLongInt(s, object.offset)
      END;
   END ReadFieldDiscipline;

   PROCEDURE WriteFieldDiscipline(s: Streams.Stream;
                                  object: PersistentObjects.Object) : BOOLEAN;
   BEGIN
      WITH object: FieldDiscipline DO
	 RETURN NetIO.WriteLongInt(s, object.offset)
      END;
   END WriteFieldDiscipline;

   (* === PO if of TypeDiscipline ========================================= *)

   PROCEDURE CreateTypeDiscipline(VAR object: PersistentObjects.Object);
      VAR
	 tdisc: TypeDiscipline;
   BEGIN
      NEW(tdisc); PersistentObjects.Init(tdisc, tdtype);
      tdisc.size := 0; tdisc.align := 1; tdisc.length := 0;
      object := tdisc;
   END CreateTypeDiscipline;

   PROCEDURE ReadTypeDiscipline(s: Streams.Stream;
                                object: PersistentObjects.Object) : BOOLEAN;
   BEGIN
      WITH object: TypeDiscipline DO
	 RETURN CompilerObjects.GuardedRead(s, typeType, object.type) &
	        NetIO.ReadLongInt(s, object.size) &
	        NetIO.ReadLongInt(s, object.align) &
		NetIO.ReadLongInt(s, object.length)
      END;
   END ReadTypeDiscipline;

   PROCEDURE WriteTypeDiscipline(s: Streams.Stream;
                                 object: PersistentObjects.Object) : BOOLEAN;
   BEGIN
      WITH object: TypeDiscipline DO
	 RETURN CompilerObjects.Write(s, object.type) &
	        NetIO.WriteLongInt(s, object.size) &
	        NetIO.WriteLongInt(s, object.align) &
		NetIO.WriteLongInt(s, object.length)
      END;
   END WriteTypeDiscipline;

   (* === recursive calculation of size and alignment ===================== *)

   PROCEDURE Max(val1, val2: Size) : Size;
   BEGIN
      IF val1 > val2 THEN
	 RETURN val1
      ELSE
	 RETURN val2
      END;
   END Max;

   PROCEDURE RemoveTypeMarks(module: Sym.Ident);
      VAR
	 mdisc: ModuleDiscipline;
	 ttdisc: TemporaryTypeDiscipline;
   BEGIN
      IF Disciplines.Seek(module, mdiscid, mdisc) THEN
	 ttdisc := mdisc.ttdiscs;
	 WHILE ttdisc # NIL DO
	    Disciplines.Remove(ttdisc.type, ttdiscid);
	    ttdisc := ttdisc.next;
	 END;
      END;
   END RemoveTypeMarks;

   PROCEDURE GetTypeDisc(module: Sym.Ident;
                         type: Sym.Type; VAR tdisc: TypeDiscipline;
                         errors: RelatedEvents.Object);
      VAR
	 size, align: Size;
	 bitlength: INTEGER;
	 reftypesize: Size;
	    (* size of referenced type; this is unneeded in this
	       context but to be calculated for later use
	    *)
	 paramlist: Sym.ParamList;

      PROCEDURE Mark(type: Sym.Type);
	 (* types are marked at the begin of GetTypeDisc to avoid
	    recursive calls due to pointer types
	 *)
	 VAR
	    ttdisc: TemporaryTypeDiscipline;
	    mdisc: ModuleDiscipline;
      BEGIN
	 NEW(ttdisc);
	 ttdisc.id := ttdiscid;
	 ttdisc.type := type;
	 IF ~Disciplines.Seek(module, mdiscid, mdisc) THEN
	    NEW(mdisc); mdisc.id := mdiscid; mdisc.ttdiscs := NIL;
	 END;
	 ttdisc.next := mdisc.ttdiscs; mdisc.ttdiscs := ttdisc;
	 Disciplines.Add(type, ttdisc);
	 Disciplines.Add(module, mdisc);
      END Mark;

      PROCEDURE Marked(type: Sym.Type) : BOOLEAN;
	 VAR
	    ttdisc: TemporaryTypeDiscipline;
      BEGIN
	 RETURN Disciplines.Seek(type, ttdiscid, ttdisc)
      END Marked;

      PROCEDURE IndirectlyMarked(type: Sym.Type) : BOOLEAN;
      BEGIN
	 LOOP
	    IF Marked(type) THEN RETURN TRUE END;
	    IF type.form # Sym.record THEN RETURN FALSE END;
	    type := type.basetype;
	    IF type = NIL THEN RETURN FALSE END;
	 END;
      END IndirectlyMarked;

      PROCEDURE MulOp(length: Integer; size: Size) : Size;
	 VAR
	    i, i1, i2: Size;
	    prod: Size;

	 PROCEDURE Error;
	    VAR
	       es: Streams.Stream;
	 BEGIN
	    CompilerErrors.Open(es);
	    CompilerErrors.At1(es, type.loc);
	    Write.StringS(es, "exceeds maximal size");
	    CompilerErrors.Close(es, errors);
	 END Error;

      BEGIN (* MulOp *)
	 ASSERT((length >= 0) & (size >= 0));
	 i1 := length; i2 := size;
	 IF i1 > i2 THEN
	    i := i1; i1 := i2; i2 := i;
	 END;

	 prod := 0;
	 WHILE i1 > 0 DO
	    IF ODD(i1) THEN
	       IF prod <= MAX(Size) - i2 THEN
		  INC(prod, i2);
	       ELSE
		  Error; RETURN 0
	       END;
	    END;
	    i1 := i1 DIV 2;
	    IF i1 > 0 THEN
	       IF i2 <= MAX(Size) DIV 2 THEN
		  i2 := 2 * i2;
	       ELSE
		  Error; RETURN 0
	       END;
	    END;
	 END;

	 RETURN prod
      END MulOp;

      PROCEDURE GetSizeOfArray;
	 VAR
	    at: Sym.Attribute;
	    atdisc: Attribute;
	    tdiscOfElement: TypeDiscipline;
	    length: Integer;
      BEGIN
	 ASSERT(~type.dyn);
	 at := type.length;
	 ASSERT(at.type.form = Sym.integer);
	 IF CheckConst(module, at, errors) THEN
	    CompilerObjects.GetAttachment(at, atdisc);
	    ASSERT(atdisc # NIL);
	    ASSERT(atdisc.kind = integerConst);
	    length := atdisc.intval;
	 ELSE
	    length := 1;
	 END;
	 GetTypeDisc(module, type.element, tdiscOfElement, errors);
	 size := tdiscOfElement.size;
	 Align(size, tdiscOfElement.align, type.loc, errors);
	 size := MulOp(length, size);
	 IF Oberon32i.arrayAlign > tdiscOfElement.align THEN
	    Align(size, Oberon32i.arrayAlign, type.loc, errors);
	 END;
	 IF size > 0 THEN
	    align := Max(Oberon32i.arrayAlign, tdiscOfElement.align);
	 ELSE
	    align := 1;
	 END;
      END GetSizeOfArray;

      PROCEDURE GetSizeOfRecord;
	 CONST
	    tablen = Oberon32i.maxalign + 1;
	 TYPE
	    FieldList = POINTER TO FieldListRec;
	    FieldListRec =
	       RECORD
		  field: Sym.FieldList;
		  size: Size;
		  next: FieldList;
	       END;
	 VAR
	    tdiscOfBaseType: TypeDiscipline;
	    tdiscOfField: TypeDiscipline;
	    offset, startOffset, maxAlign: Size;
	    field: Sym.FieldList;
	    sorted: ARRAY tablen OF FieldList;
	    alignIndex: Size;
	    member: FieldList;

	 PROCEDURE InitTab;
	    VAR
	       i: Size;
	 BEGIN
	    i := 0;
	    WHILE i < tablen DO
	       sorted[i] := NIL; INC(i);
	    END;
	 END InitTab;

	 PROCEDURE Add;
	    (* adds field to sorted using tdiscOfField *)
	    VAR
	       entry, tmp: FieldList;
	       align: Size;
	 BEGIN
	    NEW(entry); entry.field := field;
	    entry.size := tdiscOfField.size;
	    entry.next := NIL;
	    align := tdiscOfField.align;
	    ASSERT(align < tablen);
	    IF sorted[align] = NIL THEN
	       sorted[align] := entry;
	    ELSE
	       tmp := sorted[align];
	       WHILE tmp.next # NIL DO
	          tmp := tmp.next;
	       END;
	       tmp.next := entry;
	    END;
	 END Add;

	 PROCEDURE SetOffset(field: Sym.FieldList);
	    VAR
	       fdisc: FieldDiscipline;
	 BEGIN
	    CreateFieldDiscipline(fdisc);
	    CompilerObjects.Init(fdisc);
	    fdisc.offset := offset;
	    CompilerObjects.Attach(module, field, fdisc);
	 END SetOffset;

      BEGIN (* GetSizeOfRecord *)
	 IF type.basetype # NIL THEN
	    GetTypeDisc(module, type.basetype, tdiscOfBaseType, errors);
	    startOffset := tdiscOfBaseType.size;
	    maxAlign := tdiscOfBaseType.align;
	 ELSE
	    startOffset := 0;
	    maxAlign := Oberon32i.recordAlign;
	 END;
	 InitTab;
	 field := type.fields;
	 WHILE field # NIL DO
	    GetTypeDisc(module, field.type, tdiscOfField, errors);
	    IF tdiscOfField.align > maxAlign THEN
	       maxAlign := tdiscOfField.align;
	    END;
	    Add;
	    field := field.next;
	 END;
	 alignIndex := 0;
	 WHILE alignIndex <= Oberon32i.maxalign DO
	    member := sorted[alignIndex];
	    WHILE member # NIL DO
	       Allocate(member.size, alignIndex,
	                startOffset, offset, forwardDir,
			type.loc, errors);
	       SetOffset(member.field);
	       member := member.next;
	    END;
	    INC(alignIndex);
	 END;
	 size := startOffset;
	 Align(size, Oberon32i.recordAlign, type.loc, errors);
	 IF size > 0 THEN
	    align := Max(maxAlign, Oberon32i.recordAlign);
	 ELSE
	    align := 1;
	 END;
      END GetSizeOfRecord;

      PROCEDURE NumberOfDynDimensions(type: Sym.Type) : INTEGER;
      BEGIN
	 IF (type = NIL) OR ~(type.form = Sym.array) OR ~type.dyn THEN
	    RETURN 0
	 END;
	 RETURN 1 + NumberOfDynDimensions(type.element)
      END NumberOfDynDimensions;

   BEGIN (* GetTypeDisc *)
      CompilerObjects.GetAttachment(type, tdisc);
      IF tdisc # NIL THEN RETURN END;
      ASSERT(~Marked(type));
      Mark(type);
      CASE type.form OF
      | Sym.integer, Sym.cardinal:
	    ASSERT(type.spec # Sym.generic);
	    CASE type.spec OF
	    | Sym.standard:
		  CASE type.stdlength OF
		  | Sym.short:   bitlength := Oberon32i.shortIntLen;
		  | Sym.medium:  bitlength := Oberon32i.intLen;
		  | Sym.long:    bitlength := Oberon32i.longIntLen;
		  END;
	    | Sym.explicit:
		  bitlength := type.bits;
	    END;
	    CASE bitlength OF
	    |  8: size := Oberon32i.int8Size; align := Oberon32i.int8Align;
	    | 16: size := Oberon32i.int16Size; align := Oberon32i.int16Align;
	    | 32: size := Oberon32i.int32Size; align := Oberon32i.int32Align;
	    | 64: size := Oberon32i.int64Size; align := Oberon32i.int64Align;
	    END;
      | Sym.address:
	    size := Oberon32i.addressSize;
	    align := Oberon32i.addressAlign;
      | Sym.real:
	    ASSERT(type.spec # Sym.generic);
	    CASE type.spec OF
	    | Sym.standard:
		  CASE type.stdlength OF
		  | Sym.short:   bitlength := Oberon32i.shortRealLen;
		  | Sym.medium:  bitlength := Oberon32i.realLen;
		  | Sym.long:    bitlength := Oberon32i.longRealLen;
		  END;
	    | Sym.explicit:
		  bitlength := type.bits;
	    END;
	    CASE bitlength OF
	    |  32: size := Oberon32i.real32Size;
		   align := Oberon32i.real32Align;
	    |  64: size := Oberon32i.real64Size;
		   align := Oberon32i.real64Align;
	    |  96: size := Oberon32i.real96Size;
		   align := Oberon32i.real96Align;
	    | 128: size := Oberon32i.real128Size;
		   align := Oberon32i.real128Align;
	    END;
      | Sym.boolean:
	    size := Oberon32i.booleanSize;
	    align := Oberon32i.booleanAlign;
      | Sym.char:
	    size := Oberon32i.charSize;
	    align := Oberon32i.charAlign;
      | Sym.set:
	    size := Oberon32i.setSize;
	    align := Oberon32i.setAlign;
      | Sym.byte:
	    size := Oberon32i.byteSize;
	    align := Oberon32i.byteAlign;
      | Sym.coroutine:
	    size := Oberon32i.coroutineSize;
	    align := Oberon32i.coroutineAlign;
      | Sym.array:
	    IF type.dyn THEN
	       size := Oberon32i.addressSize;
	       align := Oberon32i.addressAlign;
	       size := size + NumberOfDynDimensions(type) *
			      Oberon32i.longIntLen;
		  (* add size of dope vector *)
	    ELSE
	       GetSizeOfArray;
	    END;
      | Sym.record:
	    GetSizeOfRecord;
      | Sym.pointer:
	    size := Oberon32i.pointerSize;
	    align := Oberon32i.pointerAlign;
      | Sym.proceduretype:
	    size := Oberon32i.proceduretypeSize;
	    align := Oberon32i.proceduretypeAlign;
      END;
      CreateTypeDiscipline(tdisc);
      tdisc.type := type;
      tdisc.size := size; tdisc.align := align;
      CompilerObjects.Init(tdisc);
      CompilerObjects.Attach(module, type, tdisc);
      CASE type.form OF
      | Sym.pointer:
	    (* type.reftype may be NIL for NIL-type (builtin type) *)
	    IF (type.reftype # NIL) & ~IndirectlyMarked(type.reftype) THEN
	       (* reftypesize is to be calculated as this type might
		  be left uncalculated otherwise
	       *)
	       reftypesize := GetSize(module, type.reftype, errors);
	    END;
      | Sym.proceduretype:
	    IF ~type.builtin THEN
	       paramlist := type.paramlist;
	       WHILE paramlist # NIL DO
		  IF ~IndirectlyMarked(paramlist.type) THEN
		     reftypesize := GetSize(module, paramlist.type, errors);
		  END;
		  paramlist := paramlist.next;
	       END;
	       IF type.function & ~IndirectlyMarked(type.restype) THEN
		  reftypesize := GetSize(module, type.restype, errors);
	       END;
	    END;
      ELSE
      END;
   END GetTypeDisc;

   PROCEDURE CreateAttribute(VAR at: Attribute);
   BEGIN
      InternalCreateAttribute(at);
   END CreateAttribute;

   PROCEDURE CreateCopyAttribute(VAR new: Attribute; orig: Attribute);
   BEGIN
      InternalCreateAttribute(new);
      new.type := orig.type;
      new.kind := orig.kind;
      CASE orig.kind OF
      | integerConst:   new.intval := orig.intval;
      | realConst:      new.realval := orig.realval;
      | setConst:       new.setval := orig.setval;
      | charConst:      new.charval := orig.charval;
      | booleanConst:   new.boolval := orig.boolval;
      | stringConst:    new.stringval := orig.stringval;
      | nilConst:
      | noConst:
      END;
   END CreateCopyAttribute;

   PROCEDURE StringCompare(relop: Lex.Symbol;
			   at1, at2: Attribute) : BOOLEAN;
      VAR
	 cmp: INTEGER;

      PROCEDURE Compare() : INTEGER;
	 VAR
	    ch1, ch2: CHAR;
	    ok1, ok2: BOOLEAN;
	    index: INTEGER;

	 PROCEDURE Next(at: Attribute; VAR ch: CHAR) : BOOLEAN;
	 BEGIN
	    CASE at.kind OF
	    | stringConst:
		  RETURN Streams.ReadByte(at.stringval, ch)
	    | charConst:
		  IF index = 0 THEN
		     ch := at.charval; RETURN TRUE
		  ELSE
		     RETURN FALSE
		  END;
	    END;
	 END Next;

      BEGIN (* Compare *)
	 index := 0;
	 LOOP
	    ok1 := Next(at1, ch1);
	    ok2 := Next(at2, ch2);
	    INC(index);
	    IF ~ok1 OR ~ok2 THEN EXIT END;
	    IF ch1 # ch2 THEN
	       RETURN ORD(ch1) - ORD(ch2)
	    END;
	 END;
	 IF ok1 THEN
	    RETURN 1      (* at1 is longer than at2 *)
	 ELSIF ok2 THEN
	    RETURN -1     (* at2 is longer than at1 *)
	 ELSE
	    RETURN 0      (* at1 and at2 are identical *)
	 END;
      END Compare;

   BEGIN (* StringCompare *)
      IF at1.kind = stringConst THEN
	 Streams.SetPos(at1.stringval, 0);
      END;
      IF at2.kind = stringConst THEN
	 Streams.SetPos(at2.stringval, 0);
      END;
      cmp := Compare();
      CASE relop OF
      | Lex.lst:  RETURN cmp < 0
      | Lex.leq:  RETURN cmp <= 0
      | Lex.eql:  RETURN cmp = 0
      | Lex.neq:  RETURN cmp # 0
      | Lex.geq:  RETURN cmp >= 0
      | Lex.grt:  RETURN cmp > 0
      END;
   END StringCompare;

   (* === initialization ================================================== *)

   PROCEDURE Init;

      PROCEDURE Register(VAR type: Services.Type;
                         name, basename: ARRAY OF CHAR;
			 create: PersistentObjects.CreateProc;
			 read: PersistentObjects.ReadProc;
			 write: PersistentObjects.WriteProc);
	 VAR
	    persif: PersistentObjects.Interface;
      BEGIN
	 NEW(persif);
	 persif.create := create; persif.read := read; persif.write := write;
	 persif.createAndRead := NIL;
	 PersistentObjects.RegisterType(type, name, basename, persif);
      END Register;

   BEGIN (* Init *)
      Register(attributeType, "Oberon32iSymbols.Attribute",
	 "CompilerObjects.Attachment", InternalCreateAttribute,
	 ReadAttribute, WriteAttribute);
      Register(fdtype, "Oberon32iSymbols.FieldDiscipline",
	 "CompilerObjects.Attachment", CreateFieldDiscipline,
	 ReadFieldDiscipline, WriteFieldDiscipline);
      Register(tdtype, "Oberon32iSymbols.TypeDiscipline",
	 "CompilerObjects.Attachment", CreateTypeDiscipline,
	 ReadTypeDiscipline, WriteTypeDiscipline);
      bdid := Disciplines.Unique();

      Services.SeekType("OberonSymbols.Type", typeType);
      ASSERT(typeType # NIL);

      ttdiscid := Disciplines.Unique();
      mdiscid := Disciplines.Unique();
   END Init;

   (* === exported procedures ============================================= *)

   PROCEDURE InitBuiltInProc(builtinproc: Sym.BuiltInProcedure;
                             fold: FoldBuiltInProc);
      VAR
	 bdisc: BuiltInDiscipline;
   BEGIN
      NEW(bdisc); bdisc.id := bdid; bdisc.fold := fold;
      Disciplines.Add(builtinproc, bdisc);
   END InitBuiltInProc;

   PROCEDURE GetSize(module: Sym.Ident; type: Sym.Type;
                     errors: RelatedEvents.Object) : Size;
      VAR
	 tdisc: TypeDiscipline;
   BEGIN
      GetTypeDisc(module, type, tdisc, errors);
      RETURN tdisc.size
   END GetSize;

   PROCEDURE ArithmeticType(module: Sym.Ident;
                            type1, type2: Sym.Type;
			    errors: RelatedEvents.Object) : Sym.Type;
      VAR
	 type: Sym.Type;
	 size1, size2: Size;
   BEGIN
      IF (type1 = NIL) OR (type2 = NIL) THEN RETURN NIL END;
      IF type1.form = Sym.address THEN
	 type1 := BaseTypes.longint;
      END;
      IF type2.form = Sym.address THEN
	 type2 := BaseTypes.longint;
      END;
      type := OberonTypes.ArithmeticType(type1, type2);
      IF (type = NIL) OR ~(type.form IN Sym.specforms) OR
	    (type.spec # Sym.generic) THEN
	 RETURN type
      END;
      ASSERT((type1.form IN Sym.specforms) & (type1.spec # Sym.generic));
      ASSERT((type2.form IN Sym.specforms) & (type2.spec # Sym.generic));
      ASSERT(type1.spec # type2.spec);
      (* we have now a mixed specs that cannot be resolved by
         OberonTypes.ArithmeticType without any knowledge about
	 the relationsships between the standard types (INTEGER etc)
	 and the size-oriented types (INT16 etc)
      *)
      size1 := GetSize(module, type1, errors);
      size2 := GetSize(module, type2, errors);
      IF size1 > size2 THEN
	 RETURN type1
      ELSIF size1 < size2 THEN
	 RETURN type2
      ELSIF type1.spec = Sym.standard THEN
	 RETURN type1
      ELSE
	 RETURN type2
      END;
   END ArithmeticType;

   PROCEDURE Fold(module: Sym.Ident;
                  at: Sym.Attribute; errors: RelatedEvents.Object);

      VAR
	 atdisc, new: Attribute;

      PROCEDURE ConvertConstant(const: Sym.Attribute);
	 VAR
	    atdisc: Attribute;
	    token: Lex.Token;
      BEGIN
	 ASSERT(const.mode = Sym.constvalAt);
	 CompilerObjects.GetAttachment(const, atdisc);
	 IF atdisc # NIL THEN RETURN END;
	 InternalCreateAttribute(atdisc);
	 atdisc.type := const.type;
	 CASE const.constval.kind OF
	 | Sym.emptySetConst:
	       atdisc.kind := setConst; atdisc.setval := {};
	 | Sym.trueConst:
	       atdisc.kind := booleanConst; atdisc.boolval := TRUE;
	 | Sym.falseConst:
	       atdisc.kind := booleanConst; atdisc.boolval := FALSE;
	 | Sym.tokenConst:
	       token := const.constval.token;
	       CASE token.sy OF
	       | Lex.intconst:
		     atdisc.kind := integerConst;
		     Streams.SetPos(token.text, 0);
		     IF ~Oberon32iIntegers.ReadDec(token.text, atdisc.intval,
		                                  const.loc, errors) THEN
			atdisc.intval := 1;
		     END;
	       | Lex.hexconst:
		     atdisc.kind := integerConst;
		     Streams.SetPos(token.text, 0);
		     IF ~Oberon32iIntegers.ReadHex(token.text, atdisc.intval,
		                                  const.loc, errors) THEN
			atdisc.intval := 1;
		     END;
	       | Lex.realconst,
	         Lex.longrealconst:
		     atdisc.kind := realConst;
		     Streams.SetPos(token.text, 0);
		     IF ~IEEE754Double.Read(token.text, atdisc.realval,
		                                const.loc, errors) THEN
			atdisc.realval := 1.0;
		     END;
		     CASE token.sy OF
		     | Lex.realconst:     atdisc.type := BaseTypes.real;
		     | Lex.longrealconst: atdisc.type := BaseTypes.longreal;
		     END;
	       | Lex.charconst:
		     atdisc.kind := charConst;
		     Streams.SetPos(token.text, 0);
		     IF ~Oberon8Chars.Read(token.text, atdisc.charval,
		                           const.loc, errors) THEN
			atdisc.charval := 0X;
		     END;
	       | Lex.string:
		     atdisc.kind := stringConst;
		     atdisc.stringval := token.text;
	       | Lex.nil:
	             atdisc.kind := nilConst;
	       END;
	 END;
	 CompilerObjects.Attach(module, const, atdisc);
      END ConvertConstant;

      PROCEDURE FoldProcedureCalls;
	 VAR
	    proc: Sym.Attribute;
	    bdisc: BuiltInDiscipline;
	    prev, oldparam, param: Sym.Attribute;
	    atdisc: Attribute;
      BEGIN
	 (* fold all parameters *)
	 param := at.firstparam; prev := NIL;
	 WHILE param # NIL DO
	    oldparam := param; Fold(module, param, errors);
	    IF param # oldparam THEN
	       param.next := oldparam.next;
	       IF prev = NIL THEN
		  at.firstparam := param;
	       ELSE
		  prev.next := param;
	       END;
	    END;
	    prev := param; param := param.next;
	 END;

	 (* check for built-in procedures that support folding *)
	 proc := at.proc;
	 IF (proc.mode IN Sym.identModes) & proc.ident.type.builtin &
	       Disciplines.Seek(proc.ident.type.builtinproc, bdid, bdisc) &
	       bdisc.fold(proc.ident.type.builtinproc, module, at.firstparam,
	                  atdisc, errors) THEN
	    CompilerObjects.Attach(module, at, atdisc);
	 END;
      END FoldProcedureCalls;

      PROCEDURE UnaryOp(at: Sym.Attribute);
	 VAR
	    atdisc, new: Attribute;
	    loc: CompilerObjects.Location;
	    es: Streams.Stream;
	    opsy: Lex.Symbol;
	    op: Sym.Attribute;
      BEGIN
	 ASSERT(at.mode = Sym.unaryAt);
	 opsy := at.opsy; op := at.rightop;
	 CompilerObjects.GetAttachment(op, atdisc);
	 ASSERT((opsy = Lex.plus) OR (opsy = Lex.minus) OR (opsy = Lex.tilde));
	 IF atdisc = NIL THEN RETURN END;
	 IF opsy = Lex.plus THEN
	    CreateCopyAttribute(new, atdisc);
	 ELSE
	    InternalCreateAttribute(new);
	    new.type := atdisc.type;
	    new.kind := atdisc.kind;
	    CASE atdisc.kind OF
	    | integerConst:
		  ASSERT(opsy = Lex.minus);
		  IF atdisc.intval = MIN(Integer) THEN
		     CompilerObjects.CreateLocation(loc, op.loc.src,
			at.loc.begin, op.loc.end);
		     CompilerErrors.Open(es);
		     CompilerErrors.At1(es, loc);
		     Write.StringS(es,
			"constant exceeds maximal integer value");
		     CompilerErrors.Close(es, errors);
		  ELSE
		     new.intval := - atdisc.intval;
		  END;
	    | realConst:
		  ASSERT(opsy = Lex.minus);
		  new.realval := - atdisc.realval;
	    | setConst:
		  ASSERT(opsy = Lex.minus);
		  new.setval := - atdisc.setval;
	    | booleanConst:
		  ASSERT(opsy = Lex.tilde);
		  new.boolval := ~atdisc.boolval;
	    | noConst:
	    END;
	 END;
	 CompilerObjects.Attach(module, at, new);
      END UnaryOp;

      PROCEDURE BinaryOp(at: Sym.Attribute);
	 VAR
	    err: BOOLEAN;
	    es: Streams.Stream;
	    opsy: Lex.Symbol;
	    op1, op2: Sym.Attribute;
	    new, atdisc1, atdisc2: Attribute;
	    type1, type2: Sym.Type;

	 PROCEDURE IntegerCompare(relop: Lex.Symbol;
	                          i1, i2: Integer) : BOOLEAN;
	 BEGIN
	    CASE relop OF
	    | Lex.lst:  RETURN i1 < i2
	    | Lex.leq:  RETURN i1 <= i2
	    | Lex.eql:  RETURN i1 = i2
	    | Lex.neq:  RETURN i1 # i2
	    | Lex.geq:  RETURN i1 >= i2
	    | Lex.grt:  RETURN i1 > i2
	    END;
	 END IntegerCompare;

	 PROCEDURE IntegerArithmetic(op: Lex.Symbol; i1, i2: Integer) : Integer;

	    PROCEDURE AddOp(i1, i2: Integer) : Integer;
	    BEGIN
	       err := (i1 >= 0) & (i2 > 0) & (MAX(Integer) - i1 < i2) OR
		      (i1 < 0) & (i2 < 0) & (i1 < MIN(Integer) - i2);
	       RETURN i1 + i2
	    END AddOp;

	    PROCEDURE SubOp(i1, i2: Integer) : Integer;
	    BEGIN
	       err := (i1 >= 0) & (i2 < 0) & (i2 < i1 - MAX(Integer)) OR
		      (i1 < -1) & (i2 > 0) & (i1 < MIN(Integer) + i2);
	       RETURN i1 - i2
	    END SubOp;

	    PROCEDURE MulOp(i1, i2: Integer) : Integer;
	       VAR
		  i: Integer;
		  minus: BOOLEAN;
		  prod, c1, c2: Integer;
	    BEGIN
	       IF i1 > i2 THEN
		  i := i1; i1 := i2; i2 := i;
	       END;
	       IF (i1 = MIN(Integer)) & (i2 # 1) THEN
		  err := TRUE; RETURN MIN(Integer)
	       END;
	       minus := (i1 < 0) # (i2 < 0);

	       c1 := ABS(i1);
	       IF i2 >= 0 THEN
		  c2 := - i2;
	       ELSE
		  c2 := i2;
	       END;
	       prod := 0;
	       WHILE (c1 > 0) & ~err DO
		  IF ODD(c1) THEN
		     IF prod >= MIN(Integer) - c2 THEN
			INC(prod, c2);
		     ELSE
			err := TRUE;
		     END;
		  END;
		  c1 := c1 DIV 2;
		  IF c1 > 0 THEN
		     IF c2 >= MIN(Integer) DIV 2 THEN
			c2 := 2 * c2;
		     ELSE
			err := TRUE;
		     END;
		  END;
	       END;

	       IF minus THEN
		  RETURN prod
	       ELSE
		  IF prod = MIN(Integer) THEN
		     err := TRUE;
		     RETURN MAX(Integer)
		  ELSE
		     RETURN - prod
		  END;
	       END;
	    END MulOp;

	    PROCEDURE DivOp(i1, i2: Integer) : Integer;
	       (* we assume Modulo-arithmetic *)
	       VAR
		  q, r: Integer;
	    BEGIN
	       IF i2 = 0 THEN err := TRUE; RETURN 1 END;
	       RETURN i1 DIV i2
	    END DivOp;

	    PROCEDURE ModOp(i1, i2: Integer) : Integer;
	       (* assumption: DIV and MOD are performed in Euler-arithmetic *)
	       (* result is in Modulo-arithmetic *)
	       VAR
		  q, r: Integer;
	    BEGIN
	       IF i2 = 0 THEN err := TRUE; RETURN 1 END;
	       RETURN i1 MOD i2
	    END ModOp;

	 BEGIN (* IntegerArithmetic *)
	    CASE opsy OF
            | Lex.plus:    RETURN AddOp(i1, i2)
            | Lex.minus:   RETURN SubOp(i1, i2)
            | Lex.times:   RETURN MulOp(i1, i2)
            | Lex.div:     RETURN DivOp(i1, i2)
            | Lex.mod:     RETURN ModOp(i1, i2)
	    END;
	 END IntegerArithmetic;

	 PROCEDURE RealCompare(relop: Lex.Symbol; r1, r2: Real) : BOOLEAN;
	 BEGIN
	    CASE relop OF
	    | Lex.lst:  RETURN r1 < r2
	    | Lex.leq:  RETURN r1 <= r2
	    | Lex.eql:  RETURN r1 = r2
	    | Lex.neq:  RETURN r1 # r2
	    | Lex.geq:  RETURN r1 >= r2
	    | Lex.grt:  RETURN r1 > r2
	    END;
	 END RealCompare;

	 PROCEDURE RealArithmetic(opsy: Lex.Symbol; r1, r2: Real) : Real;

	    VAR
	       result: Real;

	    PROCEDURE AddOp(r1, r2: Real) : Real;
	    BEGIN
	       RETURN r1 + r2
	    END AddOp;

	    PROCEDURE MulOp(r1, r2: Real) : Real;
	    BEGIN
	       RETURN r1 * r2
	    END MulOp;

	    PROCEDURE DivOp(r1, r2: Real) : Real;
	    BEGIN
	       IF r2 = 0.0 THEN
		  err := TRUE;
		  RETURN 1.0
	       ELSE
		  RETURN r1 / r2
	       END;
	    END DivOp;

	 BEGIN (* RealArithmetic *)
	    CASE opsy OF
	    | Lex.plus:    result := AddOp(r1, r2)
	    | Lex.minus:   result := AddOp(r1, -r2)
	    | Lex.times:   result := MulOp(r1, r2)
	    | Lex.slash:   result := DivOp(r1, r2)
	    END;
	    IF IEEE.Valid(result) THEN
	       RETURN result
	    ELSE
	       err := TRUE;
	       RETURN 1.0
	    END;
	 END RealArithmetic;

	 PROCEDURE IsRealConst(at: Attribute) : BOOLEAN;
	 BEGIN
	    RETURN (at # NIL) & (at.kind = realConst)
	 END IsRealConst;

	 PROCEDURE IsReal(at: Sym.Attribute) : BOOLEAN;
	 BEGIN
	    RETURN (at # NIL) & (at.type.form = Sym.real);
	 END IsReal;

	 PROCEDURE IsIntegerConst(at: Attribute) : BOOLEAN;
	 BEGIN
	    RETURN (at # NIL) & (at.kind = integerConst)
	 END IsIntegerConst;

	 PROCEDURE ConvertToReal(VAR at: Attribute);
	    VAR
	       new: Attribute;
	 BEGIN
	    ASSERT(at.kind = integerConst);
	    InternalCreateAttribute(new); new.type := BaseTypes.real;
	    new.kind := realConst;
	    new.realval := at.intval;
	    at := new;
	 END ConvertToReal;

	 PROCEDURE IsStringConst(at: Attribute) : BOOLEAN;
	 BEGIN
	    RETURN (at # NIL) & (at.kind IN {stringConst, charConst})
	 END IsStringConst;

	 PROCEDURE IsBooleanConst(at: Attribute) : BOOLEAN;
	 BEGIN
	    RETURN (at # NIL) & (at.kind = booleanConst)
	 END IsBooleanConst;

	 PROCEDURE BooleanOp(opsy: Lex.Symbol; at1, at2: Attribute) : BOOLEAN;
	    VAR
	       val1, val2: BOOLEAN;
	 BEGIN
	    val1 := at1.boolval; val2 := at2.boolval;
	    CASE opsy OF
	    | Lex.eql:        RETURN val1 = val2
	    | Lex.neq:        RETURN val1 # val2
	    | Lex.or:         RETURN val1 OR val2
	    | Lex.ampersand:  RETURN val1 & val2
	    END;
	 END BooleanOp;

	 PROCEDURE IsNilConst(at: Attribute) : BOOLEAN;
	 BEGIN
	    RETURN (at # NIL) & (at.kind = nilConst)
	 END IsNilConst;

	 PROCEDURE CompareNil(opsy: Lex.Symbol) : BOOLEAN;
	 BEGIN
	    CASE opsy OF
	    | Lex.eql:  RETURN TRUE
	    | Lex.neq:  RETURN FALSE
	    END;
	 END CompareNil;

	 PROCEDURE IsSetConst(at: Attribute) : BOOLEAN;
	 BEGIN
	    RETURN (at # NIL) & (at.kind = setConst)
	 END IsSetConst;

	 PROCEDURE SetOp(opsy: Lex.Symbol; set1, set2: Set) : Set;
	 BEGIN
	    CASE opsy OF
	    | Lex.plus:    RETURN set1 + set2
	    | Lex.minus:   RETURN set1 - set2
	    | Lex.times:   RETURN set1 * set2
	    | Lex.slash:   RETURN set1 / set2
	    END;
	 END SetOp;

	 PROCEDURE CheckSetMemberRange(member: Integer;
	                               loc: CompilerObjects.Location) : BOOLEAN;
	    VAR
	       es: Streams.Stream;
	 BEGIN
	    IF member < 0 THEN
	       CompilerErrors.Open(es);
	       CompilerErrors.At1(es, loc);
	       Write.StringS(es, "set member values must not be negative");
	       CompilerErrors.Close(es, errors);
	    ELSIF member > Oberon32i.maxSetLenOnTarget THEN
	       CompilerErrors.Open(es);
	       CompilerErrors.At1(es, loc);
	       Write.StringS(es, "set member value exceeds maximal value (");
	       Write.IntS(es, Oberon32i.maxSetLenOnTarget, 1);
	       Write.CharS(es, ")");
	       CompilerErrors.Close(es, errors);
	    ELSIF member > Oberon32i.setLen THEN
	       CompilerErrors.Open(es);
	       CompilerErrors.At1(es, loc);
	       Write.StringS(es, "implementation restriction: compiler is ");
	       Write.StringS(es, "unable to represent set member values ");
	       Write.StringS(es, "exceeding ");
	       Write.IntS(es, Oberon32i.setLen, 1);
	       CompilerErrors.Close(es, errors);
	    ELSE
	       RETURN TRUE
	    END;
	    RETURN FALSE
	 END CheckSetMemberRange;

	 PROCEDURE GetAttributeAndType(op: Sym.Attribute;
	                               VAR at: Attribute;
				       VAR type: Sym.Type);
	 BEGIN
	    IF op = NIL THEN
	       at := NIL; type := NIL;
	    ELSE
	       CompilerObjects.GetAttachment(op, at);
	       IF at # NIL THEN
		  type := at.type;
	       ELSE
		  type := op.type;
	       END;
	    END;
	 END GetAttributeAndType;

      BEGIN (* BinaryOp *)
	 ASSERT(at.mode = Sym.binaryAt);
	 op1 := at.leftop; op2 := at.rightop; opsy := at.opsy;
	 GetAttributeAndType(op1, atdisc1, type1);
	 GetAttributeAndType(op2, atdisc2, type2);
	 err := FALSE;
	 IF IsIntegerConst(atdisc1) & (IsReal(op2) OR (opsy = Lex.slash)) THEN
	    ConvertToReal(atdisc1);
	 END;
	 IF IsIntegerConst(atdisc2) & (IsReal(op1) OR (opsy = Lex.slash)) THEN
	    ConvertToReal(atdisc2);
	 END;
	 new := NIL;
	 IF IsIntegerConst(atdisc1) & IsIntegerConst(atdisc2) THEN
	    InternalCreateAttribute(new);
	    IF (opsy >= Lex.eql) & (opsy <= Lex.geq) THEN
	       new.type := BaseTypes.boolean;
	       new.kind := booleanConst;
	       new.boolval :=
		  IntegerCompare(opsy, atdisc1.intval, atdisc2.intval);
	    ELSIF (opsy = Lex.range) OR (opsy = Lex.comma) THEN
	       new.type := BaseTypes.set;
	       new.kind := setConst;
	       IF CheckSetMemberRange(atdisc1.intval, op1.loc) &
	             CheckSetMemberRange(atdisc2.intval, op2.loc) THEN
		  IF opsy = Lex.range THEN
		     new.setval := {atdisc1.intval .. atdisc2.intval};
		  ELSE
		     new.setval := {atdisc1.intval, atdisc2.intval};
		  END;
	       ELSE
		  new.setval := {};
	       END;
	    ELSE
	       new.kind := integerConst; new.type := BaseTypes.genericInteger;
	       new.intval :=
		  IntegerArithmetic(opsy, atdisc1.intval, atdisc2.intval);
	    END;
	 ELSIF IsSetConst(atdisc1) & IsSetConst(atdisc2) THEN
	    InternalCreateAttribute(new);
	    IF (opsy = Lex.eql) OR (opsy = Lex.neq) THEN
	       new.type := BaseTypes.boolean;
	       new.kind := booleanConst;
	       new.boolval := (atdisc1.setval = atdisc2.setval) =
	                      (opsy = Lex.eql);
	    ELSE
	       new.type := BaseTypes.set;
	       new.kind := setConst;
	       new.setval := SetOp(opsy, atdisc1.setval, atdisc2.setval);
	    END;
	 ELSIF IsIntegerConst(atdisc1) & IsSetConst(atdisc2) THEN
	    InternalCreateAttribute(new);
	    CASE opsy OF
	    | Lex.in:
		  new.type := BaseTypes.boolean;
		  new.kind := booleanConst;
		  new.boolval := atdisc1.intval IN atdisc2.setval;
	    | Lex.comma:
		  new.type := BaseTypes.set;
		  new.kind := setConst;
		  new.setval := {atdisc1.intval} + atdisc2.setval;
	    END;
	 ELSIF IsSetConst(atdisc1) & IsIntegerConst(atdisc2) THEN
	    ASSERT(opsy = Lex.comma);
	    InternalCreateAttribute(new);
	    new.type := BaseTypes.set;
	    new.kind := setConst;
	    new.setval := atdisc1.setval + {atdisc2.intval};
	 ELSIF IsSetConst(atdisc2) & (op1 = NIL) THEN
	    ASSERT(opsy = Lex.comma);
	    InternalCreateAttribute(new);
	    new.type := BaseTypes.set;
	    new.kind := setConst;
	    new.setval := atdisc2.setval;
	 ELSIF IsIntegerConst(atdisc1) THEN
	    IF (atdisc1.intval = 0) &
		  ((opsy = Lex.times) OR (opsy = Lex.div)) THEN
	       InternalCreateAttribute(new);
	       new.type := ArithmeticType(module, type1, type2, errors);
	       new.kind := integerConst;
	       new.intval := 0;
	    END;
	 ELSIF IsIntegerConst(atdisc2) THEN
	    IF (atdisc2.intval = 0) &
		  ((opsy = Lex.times) OR (opsy = Lex.div)) THEN
	       InternalCreateAttribute(new);
	       new.type := ArithmeticType(module, type1, type2, errors);
	       new.kind := integerConst;
	       new.intval := 0;
	       IF opsy = Lex.div THEN
		  err := TRUE;
	       END;
	    ELSIF (opsy = Lex.comma) & (op1 = NIL) THEN
	       InternalCreateAttribute(new);
	       new.type := BaseTypes.set;
	       new.kind := setConst;
	       IF CheckSetMemberRange(atdisc2.intval, op2.loc) THEN
		  new.setval := {atdisc2.intval};
	       ELSE
		  new.setval := {};
	       END;
	    END;
	 ELSIF IsRealConst(atdisc1) & IsRealConst(atdisc2) THEN
	    IF (opsy >= Lex.eql) & (opsy <= Lex.geq) THEN
	       InternalCreateAttribute(new);
	       new.type := BaseTypes.boolean;
	       new.kind := booleanConst;
	       new.boolval :=
		  RealCompare(opsy, atdisc1.realval, atdisc2.realval);
	    ELSE
	       InternalCreateAttribute(new);
	       new.type := BaseTypes.real;
	       new.kind := realConst;
	       new.realval :=
		  RealArithmetic(opsy, atdisc1.realval, atdisc2.realval);
	    END;
	 ELSIF IsStringConst(atdisc1) & IsStringConst(atdisc2) THEN
	    ASSERT((opsy >= Lex.eql) & (opsy <= Lex.geq));
	    InternalCreateAttribute(new);
	    new.type := BaseTypes.boolean;
	    new.kind := booleanConst;
	    new.boolval := StringCompare(opsy, atdisc1, atdisc2);
	 ELSIF IsBooleanConst(atdisc1) THEN
	    IF IsBooleanConst(atdisc2) THEN
	       InternalCreateAttribute(new);
	       new.type := BaseTypes.boolean;
	       new.kind := booleanConst;
	       new.boolval := BooleanOp(opsy, atdisc1, atdisc2);
	    ELSIF (opsy = Lex.or) & atdisc1.boolval OR
	          (opsy = Lex.ampersand) & ~atdisc1.boolval THEN
	       InternalCreateAttribute(new);
	       new.type := BaseTypes.boolean;
	       new.kind := booleanConst;
	       new.boolval := atdisc1.boolval;
	    END;
	 ELSIF IsNilConst(atdisc1) & IsNilConst(atdisc2) THEN
	    InternalCreateAttribute(new);
	    new.type := BaseTypes.boolean;
	    new.kind := booleanConst;
	    new.boolval := CompareNil(opsy);
	 END;
	 IF (new = NIL) &
	       (at.type # NIL) & (at.type.form IN Sym.specforms) &
	       (at.type.spec = Sym.generic) THEN
	    (* unable to fold but we still have to resolve generic types *)
	    InternalCreateAttribute(new);
	    new.type := ArithmeticType(module, type1, type2, errors);
	    new.kind := noConst;
	 END;
	 IF err THEN
	    CompilerErrors.Open(es);
	    CompilerErrors.At1(es, op1.loc);
	    CompilerErrors.At2(es, op2.loc);
	    Write.StringS(es, "constant expression evaluation faulted");
	    CompilerErrors.Close(es, errors);
	 END;
	 IF new # NIL THEN
	    CompilerObjects.Attach(module, at, new);
	 END;
      END BinaryOp;

      PROCEDURE CaseLabels(at: Sym.Attribute);

	 PROCEDURE Const(at: Sym.Attribute);
	    VAR
	       ok: BOOLEAN;
	 BEGIN
	    ok := CheckConst(module, at, errors);
	 END Const;

      BEGIN (* CaseLabels *)
	 IF at = NIL THEN RETURN END;
	 ASSERT(at.mode IN Sym.opModes);
	 IF at.mode = Sym.binaryAt THEN
	    CASE at.opsy OF
	    | Lex.comma:
		  CaseLabels(at.leftop); CaseLabels(at.rightop);
	    | Lex.range:
		  Const(at.leftop); Const(at.rightop);
	    ELSE
	       Const(at);
	    END;
	 ELSE
	    Const(at);
	 END;
      END CaseLabels;

      PROCEDURE FixType(at: Sym.Attribute);
	 (* convert a generic type into the correct type in
	    dependence of the constant value
	 *)

	 CONST
	    max8 = 127; min8 = - max8 - 1;
	    max16 = 32767; min16 = - max16 - 1;
	    max32 = 2147483647; min32 = - max32 - 1;
	 VAR
	    atdisc: Attribute;

	 PROCEDURE Fits(val: Oberon32i.Integer; nofbytes: INTEGER) : BOOLEAN;
	 BEGIN
	    CASE nofbytes OF
	    | 1:  RETURN (val >= min8) & (val <= max8)
	    | 2:  RETURN (val >= min16) & (val <= max16)
	    | 4:  RETURN (val >= min32) & (val <= max32)
	    ELSE
	       ASSERT(nofbytes > 4);
	       RETURN TRUE
	    END;
	 END Fits;

      BEGIN (* FixType *)
	 IF at.type = NIL THEN RETURN END;
	 IF ~(at.type.form IN Sym.specforms) THEN RETURN END;
	 CompilerObjects.GetAttachment(at, atdisc);
	 IF atdisc = NIL THEN
	    ASSERT(at.type.spec # Sym.generic); RETURN
	 END;
	 IF atdisc.type = NIL THEN RETURN END;
	 IF atdisc.type.spec # Sym.generic THEN RETURN END;
	 IF atdisc.kind = noConst THEN
	    ASSERT((atdisc.type = NIL) OR
	       ~(atdisc.type.form IN Sym.specforms) OR
	       (atdisc.type.spec # Sym.generic));
	    RETURN
	 END;
	 ASSERT(atdisc.kind = integerConst);
	 IF Fits(atdisc.intval, Oberon32i.int8Size) THEN
	    atdisc.type := BaseTypes.int8;
	 ELSIF Fits(atdisc.intval, Oberon32i.int16Size) THEN
	    atdisc.type := BaseTypes.int16;
	 ELSIF Fits(atdisc.intval, Oberon32i.int32Size) THEN
	    atdisc.type := BaseTypes.int32;
	 ELSE
	    ASSERT(Fits(atdisc.intval, Oberon32i.int64Size));
	    atdisc.type := BaseTypes.int64;
	 END;
      END FixType;

      PROCEDURE ProcessType(type: Sym.Type);
	 VAR
	    tdisc: TypeDiscipline;
      BEGIN
	 IF type # NIL THEN
	    GetTypeDisc(module, type, tdisc, errors);
	 END;
      END ProcessType;

   BEGIN (* Fold *)
      IF at = NIL THEN RETURN END;
      IF at.mode = Sym.typeAt THEN ProcessType(at.type); RETURN END;
      ASSERT(at.mode IN Sym.opModes + Sym.stmtModes);
      CompilerObjects.GetAttachment(at, atdisc);
      IF atdisc # NIL THEN RETURN (* already folded *) END;
      IF at.mode IN Sym.stmtModes THEN
	 Fold(module, at.next, errors); (* fold all stmts in chain *)
	 IF at.mode IN {Sym.whileAt, Sym.repeatAt, Sym.loopAt,
	                Sym.singleCaseAt, Sym.withAt} THEN
	    Fold(module, at.body, errors);
	 END;
      END;
      CASE at.mode OF
      | Sym.constvalAt:
	    ConvertConstant(at); FixType(at);
      | Sym.constAt:
	    IF CheckConst(module, at.ident.constexpr, errors) THEN
	       CompilerObjects.GetAttachment(at.ident.constexpr, atdisc);
	       IF atdisc # NIL THEN
		  CreateCopyAttribute(new, atdisc);
		  CompilerObjects.Attach(module, at, new);
	       END;
	    END;
      | Sym.callAt:
	    FoldProcedureCalls;
      | Sym.refAt, Sym.selectAt, Sym.indexAt, Sym.guardAt:
	    Fold(module, at.designator, errors);
	    IF at.mode = Sym.indexAt THEN
	       Fold(module, at.index, errors);
	    END;
      | Sym.unaryAt:
	    Fold(module, at.rightop, errors);
	    UnaryOp(at); FixType(at);
      | Sym.binaryAt:
	    Fold(module, at.leftop, errors); Fold(module, at.rightop, errors);
	    BinaryOp(at); FixType(at);
      | Sym.ifAt, Sym.caseAt, Sym.whileAt, Sym.repeatAt, Sym.returnAt:
	    Fold(module, at.expression, errors);
	    CASE at.mode OF
	    | Sym.ifAt:
		  Fold(module, at.then, errors);
		  Fold(module, at.elsifs, errors);
		  Fold(module, at.else, errors);
	    | Sym.caseAt:
		  Fold(module, at.cases, errors);
		  Fold(module, at.else, errors);
	    ELSE
	    END;
      | Sym.singleCaseAt:
	    CaseLabels(at.labels);
      ELSE
	 (* unable to fold it *)
      END;
      CompilerObjects.GetAttachment(at, atdisc);
      IF (atdisc # NIL) & (atdisc.type # NIL) THEN
	 ProcessType(atdisc.type);
      ELSIF (atdisc = NIL) & (at.type # NIL) &
	    (at.type.form IN Sym.specforms) & (at.type.spec = Sym.generic) THEN
	 (* avoid failed assertions due to unresolved generic types *)
	 ASSERT(RelatedEvents.EventsPending(errors));
	 SetTypeToNIL(module, at);
      END;
   END Fold;

   PROCEDURE CheckConst(module: Sym.Ident;
                        at: Sym.Attribute;
                        errors: RelatedEvents.Object) : BOOLEAN;
      VAR
	 es: Streams.Stream;
	 atdisc: Attribute;
   BEGIN
      ASSERT(at.mode IN Sym.opModes);
      Fold(module, at, errors);
      CompilerObjects.GetAttachment(at, atdisc);
      IF (atdisc # NIL) & (atdisc.kind # noConst) THEN
	 RETURN TRUE
      ELSE
	 CompilerErrors.Open(es);
	 CompilerErrors.At1(es, at.loc);
	 Write.StringS(es, "constant expression expected");
	 CompilerErrors.Close(es, errors);
	 RETURN FALSE
      END;
   END CheckConst;

   PROCEDURE GetType(at: Sym.Attribute; VAR type: Sym.Type);
      VAR
	 atdisc: Attribute;
   BEGIN
      CompilerObjects.GetAttachment(at, atdisc);
      IF atdisc # NIL THEN
	 type := atdisc.type;
      ELSE
	 type := at.type;
      END;
      ASSERT(type # NIL);
   END GetType;

   PROCEDURE AdaptType(module: Sym.Ident; type, like: Sym.Type);
      (* copy architecture-specific type information from like
	 to type; this is useful for constants
      *)
      VAR
	 tdisc, orig: TypeDiscipline;
   BEGIN
      CompilerObjects.GetAttachment(type, tdisc);
      CompilerObjects.GetAttachment(like, orig); ASSERT(orig # NIL);
      IF tdisc = NIL THEN
	 CreateTypeDiscipline(tdisc);
	 tdisc.type := orig.type;
	 tdisc.size := orig.size;
	 tdisc.align := orig.align;
	 tdisc.length := orig.length;
	 CompilerObjects.Init(tdisc);
	 CompilerObjects.Attach(module, type, tdisc);
      ELSE
	 ASSERT(OberonTypes.Identical(tdisc.type, orig.type));
      END;
   END AdaptType;

   PROCEDURE SetTypeToNIL(module: Sym.Ident; at: Sym.Attribute);
      VAR
	 atdisc: Attribute;
	 attach: BOOLEAN;
   BEGIN
      CompilerObjects.GetAttachment(at, atdisc);
      IF atdisc = NIL THEN
	 CreateAttribute(atdisc);
	 atdisc.kind := noConst;
	 atdisc.type := NIL;
	 CompilerObjects.Attach(module, at, atdisc);
      ELSE
	 atdisc.type := NIL;
      END;
   END SetTypeToNIL;

   PROCEDURE CompareConstants(cval1, cval2: Attribute) : BOOLEAN;
   BEGIN
      IF (cval1.kind IN {charConst, stringConst}) &
	    (cval2.kind IN {charConst, stringConst}) THEN
	 RETURN StringCompare(Lex.eql, cval1, cval2)
      ELSE
	 IF cval1.kind # cval2.kind THEN RETURN FALSE END;
	 CASE cval1.kind OF
	 | integerConst:   RETURN cval1.intval = cval2.intval
	 | realConst:      RETURN cval1.realval = cval2.realval
	 | setConst:       RETURN cval1.setval = cval2.setval
	 | booleanConst:   RETURN cval1.boolval = cval2.boolval
	 | nilConst:       RETURN TRUE
	 END;
      END;
   END CompareConstants;

   PROCEDURE Align(VAR size: Size; align: Size;
		   loc: CompilerObjects.Location;
                   errors: RelatedEvents.Object);
      VAR
	 es: Streams.Stream;
   BEGIN
      ASSERT(align > 0);
      IF ABS(size) MOD align # 0 THEN
         IF size >= 0 THEN
            IF size > Oberon32i.maxsize - align THEN
	       CompilerErrors.Open(es);
	       CompilerErrors.At1(es, loc);
	       Write.StringS(es, "size or offset exceeds ");
	       Write.IntS(es, Oberon32i.maxsize, 1);
	       CompilerErrors.Close(es, errors);
            ELSE
               INC(size, align - size MOD align);
            END;
         ELSE
            IF size < Oberon32i.minoffset + align THEN
	       CompilerErrors.Open(es);
	       CompilerErrors.At1(es, loc);
	       Write.StringS(es, "offset exceeds ");
	       Write.IntS(es, Oberon32i.minoffset, 1);
	       CompilerErrors.Close(es, errors);
            ELSE
               DEC(size, align - ABS(size) MOD align);
            END;
         END;
      END;
   END Align;

   PROCEDURE Allocate(size, align: Size;
                      VAR next, offset: Size; dir: Direction;
		      loc: CompilerObjects.Location;
		      errors: RelatedEvents.Object);
      VAR
	 es: Streams.Stream;
   BEGIN
      ASSERT((size >= 0) & (align >= 0));
      IF size >= align THEN
         Align(next, align, loc, errors);
      END;
      CASE dir OF
      | forwardDir:
	    offset := next;
	    IF next <= Oberon32i.maxsize - size THEN (* size >= 0! *)
	       INC(next, size);
	    ELSE
	       CompilerErrors.Open(es);
	       CompilerErrors.At1(es, loc);
	       Write.StringS(es, "size or offset exceeds ");
	       Write.IntS(es, Oberon32i.maxsize, 1);
	       CompilerErrors.Close(es, errors);
	       next := 0; (* avoid additional error messages *)
	    END;
      | backwardDir:
	    IF next >= Oberon32i.minoffset + size THEN (* size >= 0! *)
	       DEC(next, size);
	    ELSE
	       CompilerErrors.Open(es);
	       CompilerErrors.At1(es, loc);
	       Write.StringS(es, "offset exceeds ");
	       Write.IntS(es, Oberon32i.minoffset, 1);
	       CompilerErrors.Close(es, errors);
	       next := 0; (* avoid additional error messages *)
	    END;
	    offset := next;
      END;
   END Allocate;

   PROCEDURE GetAlign(module: Sym.Ident; type: Sym.Type;
                      errors: RelatedEvents.Object) : Size;
      VAR
	 tdisc: TypeDiscipline;
   BEGIN
      GetTypeDisc(module, type, tdisc, errors);
      (* use an alignment of 1 instead of 0 if no alignment is needed *)
      ASSERT(tdisc.align > 0);
      RETURN tdisc.align
   END GetAlign;

   PROCEDURE GetArrayLength(module: Sym.Ident; type: Sym.Type;
                            errors: RelatedEvents.Object) : Size;
      VAR
	 tdisc: TypeDiscipline;
   BEGIN
      ASSERT(type.form = Sym.array);
      GetTypeDisc(module, type, tdisc, errors);
      RETURN tdisc.length
   END GetArrayLength;

   PROCEDURE PatchSize(module: Sym.Ident; type: Sym.Type; size: Size);
      VAR
	 tdisc: TypeDiscipline;
   BEGIN
      CompilerObjects.GetAttachment(type, tdisc); ASSERT(tdisc # NIL);
      tdisc.size := size;
      tdisc.align := Oberon32i.maxalign;
	 (* always necessary for patches because we do not know
	    what types have been added to it
	 *)
   END PatchSize;

   PROCEDURE GetOffset(module: Sym.Ident; field: Sym.FieldList) : Size;
      VAR
	 fdisc: FieldDiscipline;
   BEGIN
      CompilerObjects.GetAttachment(field, fdisc);
      ASSERT(fdisc # NIL);
      RETURN fdisc.offset
   END GetOffset;

   PROCEDURE PatchOffset(module: Sym.Ident; field: Sym.FieldList;
                         offset: Size);
      VAR
	 fdisc: FieldDiscipline;
   BEGIN
      CompilerObjects.GetAttachment(field, fdisc);
      ASSERT(fdisc # NIL);
      fdisc.offset := offset;
   END PatchOffset;

BEGIN
   Init;
END Oberon32iSymbols.
