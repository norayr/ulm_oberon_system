(* Ulm's Oberon Library
   Copyright (C) 1989-1998 by University of Ulm, SAI, D-89069 Ulm, Germany
   ----------------------------------------------------------------------------
   Ulm's Oberon Library is free software; you can redistribute it
   and/or modify it under the terms of the GNU Library General Public
   License as published by the Free Software Foundation; either version
   2 of the License, or (at your option) any later version.

   Ulm's Oberon Library is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   ----------------------------------------------------------------------------
   E-mail contact: oberon@mathematik.uni-ulm.de
   ----------------------------------------------------------------------------
   $Id: CDBNames.om,v 1.1 1998/03/18 09:55:48 borchert Exp $
   ----------------------------------------------------------------------------
   $Log: CDBNames.om,v $
   Revision 1.1  1998/03/18 09:55:48  borchert
   Initial revision

   ----------------------------------------------------------------------------
*)

MODULE CDBNames;

   IMPORT CompilerObjects, ConstStrings, Names, Objects, PersistentTexts,
      RelatedEvents, Services, Shards, Sources := CompilerSources, Streams;

   (* name space design:

      * At the root we have a directory named ``modules'' and
        (not yet implemented) another called ``services''.

      * Below ``modules'' we have an directory for each existing
        module name with following sub structure:

        <modname>/obj/<genkey>/<arch>/<archkey>/def/<srcid>/<sth unique>
                 .            .                /mod/<srcid>/<sth unique>
                 .            /gen/def/<srcid>/<sth unique>
                 .                /mod/<srcid>/<sth unique>
                 /src/def/<srcid>
                     /mod/<srcid>

        <modname>     the full unabridged name of the module
	<genkey>      the architecture-independent key (in ASCII form)
	<arch>        the architecture (in ASCII form)
	<archkey>     the architecture-dependent key (in ASCII form)
	<srcid>       time stamp (in GMT) and an unique number if necessary
	<sth unique>  sth unique that will be generated by CDBNames
   *)

   TYPE
      Interface = POINTER TO InterfaceRec;
      Node = POINTER TO NodeRec;
      NodeRec =
	 RECORD
	    (Names.NodeRec)
	    if: Interface;
	    root: BOOLEAN;
	 END;
   VAR
      nodeType: Services.Type;

   TYPE
      AddObjectProc = PROCEDURE (root: Node; header: CompilerObjects.Header;
				 text: PersistentTexts.Text;
		                 auth: Shards.Lid;
				 VAR node: Node) : BOOLEAN;
      AddSourceProc = PROCEDURE (root: Node; header: Sources.Header;
                                 text: PersistentTexts.Text;
			         auth: Shards.Lid;
				 VAR node: Node) : BOOLEAN;

      GetObjectHeaderProc = PROCEDURE (node: Node; auth: Shards.Lid;
				 VAR header: CompilerObjects.Header) : BOOLEAN;

      GetSourceHeaderProc = PROCEDURE (node: Node; auth: Shards.Lid;
                                       VAR header: Sources.Header) : BOOLEAN;

      GetTextProc = PROCEDURE (node: Node; auth: Shards.Lid;
                               VAR text: PersistentTexts.Text) : BOOLEAN;

      GetPathProc = PROCEDURE (node: Node; VAR path: ARRAY OF CHAR);

      GetRootProc = PROCEDURE (node: Node; VAR root: Node);

      InterfaceRec =
	 RECORD
	    (Objects.ObjectRec)
	    addObject: AddObjectProc;
	    addSource: AddSourceProc;
	    getObjectHeader: GetObjectHeaderProc;
	    getSourceHeader: GetSourceHeaderProc;
	    getText: GetTextProc;
	    getPath: GetPathProc;
	    getRoot: GetRootProc;
	 END;

   PROCEDURE InitModule;
   BEGIN
      Services.CreateType(nodeType, "CDBNames.Node", "Names.Node");
   END InitModule;

   PROCEDURE Init(node: Node; if: Interface; root: BOOLEAN);
   BEGIN
      ASSERT((if # NIL) &
             (~root OR (if.addObject # NIL) & (if.addSource # NIL)) &
             (if.getObjectHeader # NIL) & (if.getSourceHeader # NIL) &
	     (if.getText # NIL) & (if.getPath # NIL) & (if.getRoot # NIL));
      node.if := if;
      node.root := root;
   END Init;

   PROCEDURE IsRoot(node: Node) : BOOLEAN;
   BEGIN
      RETURN node.root
   END IsRoot;

   PROCEDURE AddObject(root: Node; header: CompilerObjects.Header;
                       text: PersistentTexts.Text;
		       auth: Shards.Lid;
		       VAR node: Node) : BOOLEAN;
   BEGIN
      ASSERT(root.root);
      RETURN root.if.addObject(root, header, text, auth, node)
   END AddObject;

   PROCEDURE AddSource(root: Node; header: Sources.Header;
		       text: PersistentTexts.Text;
		       auth: Shards.Lid;
		       VAR node: Node) : BOOLEAN;
   BEGIN
      ASSERT(root.root);
      RETURN root.if.addSource(root, header, text, auth, node)
   END AddSource;

   PROCEDURE GetObjectHeader(node: Node; auth: Shards.Lid;
                             VAR header: CompilerObjects.Header) : BOOLEAN;
   BEGIN
      RETURN node.if.getObjectHeader(node, auth, header)
   END GetObjectHeader;

   PROCEDURE GetSourceHeader(node: Node; auth: Shards.Lid;
			     VAR header: Sources.Header) : BOOLEAN;
   BEGIN
      RETURN node.if.getSourceHeader(node, auth, header)
   END GetSourceHeader;

   PROCEDURE GetText(node: Node; auth: Shards.Lid;
                     VAR text: PersistentTexts.Text) : BOOLEAN;
   BEGIN
      RETURN node.if.getText(node, auth, text)
   END GetText;

   PROCEDURE GetPath(node: Node; VAR path: ARRAY OF CHAR);
      (* return relative path from root *)
   BEGIN
      node.if.getPath(node, path);
   END GetPath;

   PROCEDURE GetRoot(node: Node; VAR root: Node);
      (* return associated root node *)
   BEGIN
      node.if.getRoot(node, root);
   END GetRoot;

BEGIN
   InitModule;
END CDBNames.
