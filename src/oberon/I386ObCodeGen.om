(* Ulm's Oberon Library
   Copyright (C) 1989-2004 by University of Ulm, SAI, D-89069 Ulm, Germany
   ----------------------------------------------------------------------------
   Ulm's Oberon Library is free software; you can redistribute it
   and/or modify it under the terms of the GNU Library General Public
   License as published by the Free Software Foundation; either version
   2 of the License, or (at your option) any later version.

   Ulm's Oberon Library is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   ----------------------------------------------------------------------------
   E-mail contact: oberon@mathematik.uni-ulm.de
   ----------------------------------------------------------------------------
   $Id: I386ObCodeG.om,v 1.1 2004/09/07 09:52:16 borchert Exp borchert $
   ----------------------------------------------------------------------------
   $Log: I386ObCodeG.om,v $
   Revision 1.1  2004/09/07 09:52:16  borchert
   Initial revision

   ----------------------------------------------------------------------------
*)

MODULE I386ObCodeGen; (* Christian Ehrhardt *)

   IMPORT ASCII, CompilerErrors, CompilerKeys, CompilerObjects, ConstStrings,
      Disciplines, Emit := I386Emit, EmitErrors := I386OberonEmitErrors,
      FragmentedStreams, Gen := I386OpCodeGenerator,
      GenTypes := I386OberonGenTypes, I386BuiltIns := I386ObBuiltIns,
      I386FPURegisters, I386Regs := I386StdRegisters,
      I386Relocations := I386ObRelocations,
      I386StackAlloc := I386StackAllocations, Iterators, Lex := OberonLex,
      OA := I386OberonAnalyzer, Ob32 := Oberon32i, Ob8 := Oberon8Chars,
      Objects, Op := I386Operands, PC := I386OberonContexts,
      Pentium := I386Instructions, PersistentTexts, Read,
      Regs := CompilerRegisters, RelatedEvents,
      Relocations := CompilerRelocations, Res := I386OberonResults, Scopes,
      StackAlloc := CompilerStackAllocations, Streams, Sym := OberonSymbols,
      Sym32 := Oberon32iSymbols, SYSTEM, Texts,
      TmpPtrs := CompilerTemporaryPointers, UnixOberonBuiltIns,
      UnixProcs := UnixOberonProcedures, Write;

   CONST
      setNever   = 0;
      setTrue    = 1;
      setFalse   = 2;
      setAll     = 3;

   TYPE
      BoolContext = POINTER TO BoolContextRec;
      BoolContextRec = RECORD
	 target : Op.Operand;   (* Save the result here if not NIL *)
         setaction : INTEGER; (* setNever .. setAll *)
	 truelab, falselab : FragmentedStreams.Label;
				(* Jump to this label if the expression
				 * evaluates to true/false. Don't jump if
				 * label is NIL *)
         neg : BOOLEAN;
         trueleave, falseleave : INTEGER;
	 levels : INTEGER;
      END;

      CaseBlock = POINTER TO CaseBlockRec;
      CaseBlockRec = RECORD
	 done : BOOLEAN;
	 id   : LONGINT;
	 lab  : FragmentedStreams.Label;
	 at   : Sym.Attribute;
      END;

      CaseRange = POINTER TO CaseRangeRec;
      CaseRangeRec = RECORD
	 (Disciplines.ObjectRec)
	 next, prev : CaseRange;
	 block  : CaseBlock;
	 first, last : LONGINT;
	 at : Sym.Attribute; (* For Error Messages *)
      END;

      CaseTable = POINTER TO CaseTableRec;
      CaseTableRec = RECORD
	 next : CaseTable;
	 val : LONGINT;
      END;

      DelayedPtr = POINTER TO DelayedPtrRec;
      DelayedPtrRec = RECORD
	 next : DelayedPtr;
	 reg : Regs.Value;
	 offset : Streams.Count;
      END;

      LeftOp = POINTER TO LeftOpRec;
      LeftOpRec = RECORD
         type : Sym.Type;
	 op : Op.Operand;
	 at : Sym.Attribute;
	 dptrs : DelayedPtr;
	 needdptrs : BOOLEAN;
	 own : Regs.Owner;
      END;

   CONST
      identM = 1;   (* ident is the identfier of the variable,
                     * type is the type of the attribute *)
      stackM = 2;   (* ident is the identifier that the variable is
                     * associated with, type should be NIL. The returned
		     * operand will point to the data for this Variable that
		     * was put onto the stack. This size if always 4 and
		     * byvalue is FALSE. *)
      offsetM = 3;  (* offsetM is like stackM except that the offset on the
                     * stack frame is specified explicitly. It is not taken
		     * from the Information associated with the variable.
		     * The offset is relative to the local variable block of
		     * the stack frame that ident is in. *)

   TYPE
      VarMode = INTEGER;  (* identM .. offsetM *)

      VarDesc = POINTER TO VarDescRec;
      VarDescRec = RECORD
         mode : VarMode;
         ident : Sym.Ident;
	 type : Sym.Type;
	 offset : Streams.Count;
      END;

   VAR
      leveldid : Disciplines.Identifier;


   TYPE
      TrackedLabel = POINTER TO TrackedLabelRec;
      TrackedLabelRec = RECORD
         (FragmentedStreams.LabelRec)
         id : LONGINT;
	 mys : Streams.Stream;
	 desc : ARRAY 100 OF CHAR;
	 loc : CompilerObjects.Location;
	 next : TrackedLabel;
      END;

   VAR
      labeltrackid : LONGINT;
      trackedlabels : TrackedLabel;



   PROCEDURE SetMode (reg : Regs.Value; type : Sym.Type);
      VAR
         old, new : Regs.Mode;
   BEGIN
      new := Regs.stdM;
      CASE type.form OF
      | Sym.pointer:
         IF type.taggedptr THEN
            new := Regs.ptrM;
         END;
      | Sym.address:
         IF type.traced THEN
            new := Regs.addrM;
         END;
      ELSE
      END;
      old := Regs.GetMode (reg);
      IF new # old THEN
         ASSERT(type.form # Sym.boolean);
         Regs.LoadReg (reg, Gen.StdRegs);
         Regs.SetMode (reg, new);
      END;
   END SetMode;

   PROCEDURE CreateLabel (VAR lab : FragmentedStreams.Label; desc : ARRAY OF CHAR; loc : CompilerObjects.Location; s : FragmentedStreams.Stream);
      VAR
         l : TrackedLabel;
   BEGIN
      FragmentedStreams.CreateLabel (lab);
      RETURN;
      l := NIL;
      FragmentedStreams.CreateLabel (l);
      l.id := labeltrackid;
      INC(labeltrackid);
      COPY(desc, l.desc);
      l.mys := s;
      l.loc := loc;
      lab := l;
      l.next := trackedlabels;
      trackedlabels := l;
   END CreateLabel;


   PROCEDURE CheckOp (op : Op.Operand) : Op.Operand;
      VAR
         reg : Regs.Value;
   BEGIN
      ASSERT(op # NIL);
      IF Op.Loc (op) = Op.fpuRegister THEN
         ASSERT(op.reg1 # NIL);
	 ASSERT(op.reg2 = NIL);
	 reg := op.reg1;
	 WITH reg : I386FPURegisters.Value DO
	    ASSERT(reg.freg >= 0);
	    ASSERT(reg.freg <= reg.set.top);
	 END;
	 RETURN op;
      END;
      IF op.reg1 # NIL THEN
	 Regs.CheckLoc (op.reg1);
      END;
      IF op.reg2 # NIL THEN
	 Regs.CheckLoc (op.reg2);
      END;
      IF Op.Loc (op) # Op.memory THEN
         ASSERT((op.reg1 = NIL) OR Regs.Traced (op.reg1));
         ASSERT((op.reg2 = NIL) OR Regs.Traced (op.reg2));
      END;
      RETURN op;
   END CheckOp;

   PROCEDURE FixupLoc (at : Sym.Attribute) : CompilerObjects.Location;
   BEGIN
      WHILE at.loc = NIL DO
	 IF at.leftop # NIL THEN
	    at := at.leftop;
	 ELSIF at.rightop # NIL THEN
	    at := at.rightop;
         ELSE
            RETURN NIL
	 END;
      END;
      RETURN at.loc;
   END FixupLoc;


   PROCEDURE ChownOp (op : Op.Operand; newowner : Regs.Owner);
   BEGIN
      ASSERT(op # NIL);
      IF op.reg1 # NIL THEN
	 Regs.Chown (op.reg1, newowner);
      END;
      IF op.reg2 # NIL THEN
	 Regs.Chown (op.reg2, newowner);
      END;
   END ChownOp;


   PROCEDURE AddCaseRange (ranges : CaseRange; first, last : LONGINT; blk : CaseBlock; at : Sym.Attribute; errors : RelatedEvents.Object);
      VAR
	 new, tmp, next : CaseRange;
	 merged : BOOLEAN;
	 es : Streams.Stream;

   BEGIN
      new := NIL;
      ASSERT(ranges # NIL);
      IF first > last THEN
	 CompilerErrors.Raise (errors, FixupLoc(at), "Invalid range");
	 (* No registers to destroy *)
	 RETURN;
      END;
      tmp := ranges;
      LOOP
	 (* We know that the new interval is completly after tmp. *)
	 next := tmp.next;
	 (* If tmp is the last interval we found the correct place for it *)
	 IF next = NIL THEN
	    EXIT;
	 END;
	 (* The new interval starts before the end of the next interval,
	  * i.e. the new interval belongs before next *)
	 IF first <= next.last THEN
	    EXIT;
	 END;
	 tmp := next;
      END;
      (* Check if the interval overlapps with others. *)
      IF (next # NIL) & (last >= next.first) THEN
	 CompilerErrors.Open (es);
	 CompilerErrors.At1 (es, FixupLoc(at));
	 Write.StringS (es, "case label defined twice");
	 CompilerErrors.Ref (es, FixupLoc(next.at));
	 CompilerErrors.Close (es, errors);
	 RETURN;
      END;
      (* Update ranges.first and ranges.last *)
      IF ranges.next = NIL THEN
	 ranges.first := first;
	 ranges.last := last;
      ELSE
	 IF first < ranges.first THEN
	    ranges.first := first
	 END;
	 IF last > ranges.last THEN
	    ranges.last := last;
	 END;
      END;
      merged := FALSE;
      IF (tmp # ranges) & (tmp.last + 1 = first) & (tmp.block.id = blk.id) THEN
	 merged := TRUE;
	 tmp.last := last;
	 tmp.at := at;
      END;
      IF (next # NIL) & (last+1 = next.first) & (blk.id = next.block.id) THEN
	 IF merged THEN
	    tmp.last := next.last;
	    tmp.next := next.next;
	    IF next.next # NIL THEN
	       next.next.prev := tmp;
            END;
	 ELSE
	    next.first := first;
	    next.at := at;
	    merged := TRUE;
	 END;
      END;
      IF ~merged THEN
	 NEW(new);
	 new.prev := tmp;
	 new.next := next;
	 IF next # NIL THEN
	    next.prev := new;
	 END;
	 tmp.next := new;
	 new.block := blk;
	 new.first := first;
	 new.last := last;
	 new.at := at;
      END;
   END AddCaseRange;


   PROCEDURE RealName (ident : Sym.Ident) : ConstStrings.String;
      VAR
         ret : ConstStrings.String;
   BEGIN
      ret := NIL;
      ret := ident.origname;
      IF ret = NIL THEN
	 ret := ident.name;
      END;
      RETURN ret;
   END RealName;


   (* Negate a condition Code for JCC, SETCC etc. *)
   PROCEDURE NegCC (cc : LONGINT) :  LONGINT;
   BEGIN
      IF cc MOD 2 # 0 THEN
	 RETURN cc-1;
      END;
      RETURN cc+1;
   END NegCC;

   PROCEDURE Lea (proc : PC.Context; op : Op.Operand; target : SET; caller : Regs.Owner) : Op.Operand;
      VAR
	 code : Gen.Register;
	 reg : Regs.Value;
	 scale : INTEGER;
	 new : BOOLEAN;
   BEGIN
      reg := NIL;
      new := FALSE;
      op.memsz := 4;
      IF (op.reg1 # NIL) & Regs.RegCode (op.reg1, code) &
	 (code IN target) THEN
	 reg := op.reg1;
      ELSIF (op.reg2 # NIL) & Regs.RegCode (op.reg2, code) &
	 (code IN target) THEN
	 reg := op.reg2;
      ELSIF (op.reg1 # NIL) & Regs.Traced (op.reg1) THEN
	 reg := op.reg1;
      ELSIF (op.reg2 # NIL) & Regs.Traced (op.reg2) THEN
	 reg := op.reg2;
      ELSE
	 Regs.CreateValue (reg, proc.regs, caller, Regs.addrM);
	 Regs.LoadReg (reg, target);
	 new := TRUE;
      END;
      ASSERT(Regs.Traced (reg));
      Regs.AddConstraint (reg, target);
      Regs.SetMode (reg, Regs.addrM);
      Op.Scale (op, scale);
      IF new OR (op.disp # 0) OR (op.dispsz # 0) OR
	 ((op.reg1 # NIL) & (op.reg2 # NIL)) OR
	 ((op.reg2 # NIL) & (scale # 1)) THEN
	 Emit.Instr2 (proc.s, Pentium.LEA, Op.RegOp (reg, 4 (* address *)), op);
      END;
      IF op.reg1 # reg THEN
	 Regs.DestroyOwnedValue (op.reg1, caller);
      END;
      IF op.reg2 # reg THEN
	 Regs.DestroyOwnedValue (op.reg2, caller);
      END;
      RETURN CheckOp(Op.MemOp1 (reg, op.memsz, 0, 0));
   END Lea;


   (* Count is in units of align bytes. *)
   PROCEDURE GenStringOp (proc : PC.Context;
                          mnem : Gen.Mnemonic; modeadd : SET;
		          dst, src, cnt : Op.Operand;
		          align : INTEGER; overlap : BOOLEAN;
		          caller : Regs.Owner);
      VAR
	 reg : Regs.Value;
	 ops1 : ARRAY 2 OF Op.Operand;
	 op2, opmem : Op.Operand;
	 beyond : TrackedLabel;

   BEGIN
      reg := NIL;
      ASSERT(Op.Loc (dst) = Op.memory);
      ASSERT(Op.Loc (src) = Op.memory);
      ASSERT(Op.Loc (cnt) IN {Op.register, Op.immediate, Op.immediateDyn});
      dst := Lea (proc, dst, {Gen.gendi}, caller);
      src := Lea (proc, src, {Gen.gensi}, caller);
      IF (Op.Loc (cnt) # Op.register) OR ~Regs.Traced (cnt.reg1) THEN
	 Regs.CreateValue (reg, proc.regs, caller, Regs.stdM);
	 Regs.LoadReg (reg, {Gen.gencx});
	 Regs.AddConstraint (reg, {Gen.gencx});
	 op2 := Op.RegOp (reg, 4 (* LONGINT *));
	 Emit.Instr2 (proc.s, Pentium.MOV, op2, cnt);
	 cnt := op2;
      ELSE
	 Regs.LoadReg (cnt.reg1, {Gen.gencx});
	 Regs.AddConstraint (cnt.reg1, {Gen.gencx});
      END;
      (* Clear the direction flag *)
      Emit.Instr0 (proc.s, Pentium.CLD);
      IF overlap THEN
	 (* We don't know if the two regions overlap. Thus we add
	  * (align * cnt) to %esi and %edi and set the direction flag if
	  * the src region starts after the dst region. *)
	 CreateLabel (beyond, "GenStringOp: beyond overlap", NIL, proc.s);
	 op2 := Op.RegOp (dst.reg1, 4 (*address*));
	 Emit.Instr2 (proc.s, Pentium.CMP, op2, Op.RegOp (src.reg1, 4));
	 Emit.JumpCC (proc.s, beyond, Pentium.JB-Pentium.JCC);
	 Regs.EnterLevel (proc.regs);
	 (* Bugfix: The -4 is needed because the addresss registers
	  * are decremented AFTER the move. *)
	 opmem := Op.MemOp2 (dst.reg1, cnt.reg1, 4 (*address*), -4, 0, align);
	 Emit.Instr2 (proc.s, Pentium.LEA, op2, opmem);
         Regs.SetMode (op2.reg1, Regs.addrM);
	 op2 := Op.RegOp (src.reg1, 4 (*address*));
	 opmem := Op.MemOp2 (src.reg1, cnt.reg1, 4 (*address*), -4, 0, align);
	 Emit.Instr2 (proc.s, Pentium.LEA, op2, opmem);
         Regs.SetMode (op2.reg1, Regs.addrM);
	 Emit.Instr0 (proc.s, Pentium.STD);
	 Regs.LeaveLevel (proc.regs);
	 Regs.DoneLevel (proc.regs);
	 FragmentedStreams.AttachLabel (proc.s, beyond);
      END;
      ASSERT(cnt.memsz = 4);
      src.memsz := align;
      dst.memsz := align;
      ops1[0] := dst; ops1[1] := src;
      Emit.InstrMode (proc.s, mnem, 2, ops1, modeadd, cnt.reg1);
      Regs.DestroyOwnedValue (src.reg1, caller);
      Regs.DestroyOwnedValue (dst.reg1, caller);
      Regs.DestroyOwnedValue (cnt.reg1, caller);
   END GenStringOp;


   PROCEDURE ImmOpConst (proc : PC.Context; attach : Sym32.Attribute;
			 byvalue : BOOLEAN) : Op.Operand;

      VAR
	 op : Op.Operand;
	 i : INTEGER;
	 off, len : Streams.Count;
	 ref : Relocations.SymRef;
	 reloc : Relocations.RelocRequest;
	 ok : BOOLEAN;
	 ch : CHAR;

      PROCEDURE GetCh (s : Streams.Stream; VAR ch : CHAR) : BOOLEAN;
	 VAR
	    dummy : CHAR;
	    pos : Streams.Count;
      BEGIN
	 Streams.GetPos (s, pos);
	 Read.CharS (s, ch);
	 IF ch = 0X THEN
	    Streams.SetPos (s, pos);
	    RETURN TRUE;
	 END;
	 Read.CharS (s, dummy);
	 Streams.SetPos (s, pos);
	 RETURN (dummy = 0X);
      END GetCh;

   BEGIN
      op := NIL;
      ASSERT(attach # NIL);
      CASE attach.kind OF
      | Sym32.integerConst:
	 op := Op.ImmInt (attach.intval);
      | Sym32.realConst:
         op := Op.ImmReal (attach.realval);
      | Sym32.setConst:
	 op := Op.ImmSet (attach.setval);
      | Sym32.charConst:
         op := Op.ImmChar (attach.charval);
      | Sym32.booleanConst:
         op := Op.ImmBool (attach.boolval);
      | Sym32.stringConst:
	 Streams.SetPos (attach.stringval, 0);
         IF ~GetCh (attach.stringval, ch) THEN
	    off := Emit.StringStream (proc.rodata, attach.stringval, len);
	    op := Op.MemOp0 (len, off, 4 (* address *));
	    NEW(ref);
	    ref.modname := RealName (proc.module);
	    ConstStrings.Create (ref.symname, "__rodata");
	    Relocations.Create (reloc, proc.s, Relocations.addSym, ref);
	    Op.RelocOpen (op, reloc);
         ELSE
	    (* Character constant. The caller should make sure that
	     * it does the right thing if a string is needed. *)
	    op := Op.ImmChar (ch);
         END;
      | Sym32.nilConst:
	 op := Op.ImmNil ();
      END;
      RETURN CheckOp(op);
   END ImmOpConst;

   PROCEDURE ^ GenVar (proc : PC.Context; var : VarDesc; byvalue : BOOLEAN;
                       possible : SET; caller : Regs.Owner) : Op.Operand;

   PROCEDURE LoadArrayLen (proc : PC.Context; at : Sym.Attribute;
                           possible : SET; caller : Regs.Owner) : Op.Operand;
      VAR
         dim : LONGINT;
	 op : Op.Operand;
	 var : VarDesc;
	 reg : Regs.Value;
   BEGIN
      op := NIL;
      dim := 0;
      WHILE at.mode = Sym.indexAt DO
         at := at.designator;
      END;
      ASSERT(at.mode = Sym.varAt);
      NEW (var);
      var.ident := at.ident;
      var.mode := stackM;
      op := GenVar (proc, var, FALSE, Gen.StdRegs, caller);
      Regs.CreateValue (reg, proc.regs, caller, Regs.stdM);
      Regs.LoadReg (reg, possible);
      INC (op.disp, Ob32.pointerSize+dim*Ob32.int32Size);
      Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (reg, 4), op);
      Regs.DestroyOwnedValue (op.reg1, caller);
      Regs.DestroyOwnedValue (op.reg2, caller);
      RETURN Op.RegOp (reg, 4);
   END LoadArrayLen;

   PROCEDURE LoadTmpTag (proc : PC.Context; at : Sym.Attribute; caller : Regs.Owner) : Regs.Value;
      VAR
         attype : Sym.Type;
	 tmptag, tag : Regs.Value;
   BEGIN
      tag := NIL; attype := NIL;
      IF at.mode # Sym.varAt THEN
	 Sym32.GetType (at, attype);
	 WHILE at.mode = Sym.guardAt DO
	    at := at.designator;
	 END;
      END;
      IF at.mode = Sym.varAt THEN
	 tmptag := GenTypes.GetTmpTag (at.ident);
	 IF tmptag # NIL THEN
	    IF attype # NIL THEN
	       tag := GenTypes.MaxTag (proc, tag, attype, caller, FALSE);
	    ELSE
	       Regs.CreateValue (tag, proc.regs, caller, Regs.stdM);
	       Regs.LoadReg (tag, Gen.StdRegs);
	       Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (tag, 4),
			    Op.RegOp (tmptag, 4));
	    END;
	 END;
      END;
      RETURN tag;
   END LoadTmpTag;

   PROCEDURE LoadPtrTag (proc : PC.Context;
                         op : Op.Operand; caller : Regs.Owner) : Regs.Value;
      VAR
	 tagreg : Regs.Value;
	 tmptag : Regs.Value;
   BEGIN
      tagreg := NIL;
      Regs.CreateValue (tagreg, proc.regs, caller, Regs.stdM);
      Regs.LoadReg (tagreg, Gen.StdRegs);
      CASE Op.Loc (op) OF
      | Op.immediate, Op.immediateDyn, Op.memory:
	 Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (tagreg, 4),
		      Op.ImmInt (-4));
	 Emit.Instr2 (proc.s, Pentium.ADD, Op.RegOp (tagreg, 4), op);
	 Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (tagreg, 4),
		      Op.MemOp1 (tagreg, 4, 0, 0));
      | Op.register:
	 Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (tagreg, 4),
		      Op.MemOp1 (op.reg1, 4, -4, 0));
      END;
      RETURN tagreg;
   END LoadPtrTag;

   PROCEDURE LoadVarParamTag (proc : PC.Context; op : Op.Operand;
			      caller : Regs.Owner) : Regs.Value;
      VAR
	 tagreg : Regs.Value;
   BEGIN
      tagreg := NIL;
      Regs.CreateValue (tagreg, proc.regs, caller, Regs.stdM);
      Regs.LoadReg (tagreg, Gen.StdRegs);
      ASSERT(Op.Loc (op) = Op.memory);
      INC(op.disp, 4);
      Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (tagreg, 4), op);
      DEC(op.disp, 4);
      RETURN tagreg;
   END LoadVarParamTag;


   PROCEDURE ^ GenDesignator (proc : PC.Context; lop : Sym.Attribute;
			      possible : SET; caller : Regs.Owner) : Op.Operand;

   PROCEDURE ^ GenExpr (proc : PC.Context; at : Sym.Attribute;
			byvalue : BOOLEAN; possible : SET; caller : Regs.Owner)
			           : Op.Operand;

   PROCEDURE ^ GenCall (proc : PC.Context; stmt : Sym.Attribute;
		        caller : Regs.Owner) : Regs.Value;

   PROCEDURE GenVars (scope, export : Scopes.Scope; blk : Res.Block);
      VAR
         it : Iterators.Iterator;
         ident : Sym.Ident;
	 ok : BOOLEAN;
	 txt : Texts.Text;
   BEGIN
      it := NIL;
      Scopes.GetIterator (export, it);
      WHILE Iterators.Get (it, ident) DO
         IF ident.class = Sym.varC THEN
            Res.AddSymbol (blk, ident.name, 4+OA.VarOffset (ident));
         END;
      END;
      it := NIL;
      blk.align := OA.DataBlockAlign (scope);
      blk.datalen := 4;
      blk.memlen := 4+OA.DataBlockSize (NIL, scope, NIL);  (* Variables and GTAGREF *)
      Texts.Open (txt);
      Write.CharS (txt, ASCII.nul);
      Write.CharS (txt, ASCII.nul);
      Write.CharS (txt, ASCII.nul);
      Write.CharS (txt, ASCII.nul);
      ok := PersistentTexts.Create (blk.data, txt); ASSERT(ok);
   END GenVars;


   (* Move the symbol Value of the specified symbol
    * to a register and return a suitable Operand. The module defaults to
    * the current module if NIL. *)
   PROCEDURE GenSymVal (proc : PC.Context; possible : SET;
                        mod : ConstStrings.String;
                        sym : ConstStrings.String;
			caller : Regs.Owner; inreg : BOOLEAN) : Op.Operand;
      VAR
	 reloc : Relocations.RelocRequest;
	 ref : Relocations.SymRef;
	 reg : Regs.Value;
	 opimm : Op.Operand;
   BEGIN
      reloc := NIL;
      ASSERT(~inreg OR (possible # {}));
      NEW(ref);
      IF mod = NIL THEN
	 ref.modname := RealName (proc.module);
      ELSE
         ref.modname := mod;
      END;
      ref.symname := sym;
      Relocations.Create (reloc, proc.s, Relocations.addSym, ref);
      opimm := Op.ImmIntFixed (0, 4 (* address *));
      Op.RelocOpen (opimm, reloc);
      IF ~inreg THEN
         RETURN CheckOp (opimm);
      END;
      Regs.CreateValue (reg, proc.regs, caller, Regs.stdM);
      Regs.LoadReg (reg, possible);
      Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (reg, 4 (* address *)), opimm);
      RETURN CheckOp(Op.RegOp (reg, 4)); 
   END GenSymVal;

   PROCEDURE ^ GenValue (proc : PC.Context; op : Op.Operand;
		       form : Sym.Form; size : LONGINT;
		       possible : SET; caller : Regs.Owner) : Op.Operand;

   PROCEDURE LoadFPUReg (proc : PC.Context; op : Op.Operand; form: Sym.Form;
			 size : LONGINT; caller : Regs.Owner) : Op.Operand;
      VAR
	 off : LONGINT;
	 i : INTEGER;
	 arr : ARRAY 8 OF BYTE;
	 reg, tmp : Regs.Value;
	 tmpop, immop, memop : Op.Operand;
	 ok : BOOLEAN;
   BEGIN
      IF Op.Loc (op) = Op.fpuRegister THEN
	 RETURN CheckOp (op);
      END;
      CASE form OF
      | Sym.real:
         CASE Op.Loc (op) OF
	 | Op.fpuRegister:
	    RETURN op;	  
	 | Op.immediate:
	    ASSERT(op.immsz = 8);
	    Regs.CreateValue (tmp, proc.regs, caller, Regs.stdM);
	    Regs.LoadReg (tmp, Gen.StdRegs);
	    tmpop := Op.RegOp (tmp, 4);
	    off := StackAlloc.Allocate (proc.stack, 8, 4, FALSE);
	    Regs.UntracedValue (reg, Gen.genbp);
	    Op.GetImmData (op, arr, 8);
	    memop := Op.MemOp1 (reg, 4, off, 0);
	    immop := Op.ImmData (FALSE, 4, arr);
	    Emit.Instr2 (proc.s, Pentium.MOV, tmpop, immop);
	    Emit.Instr2 (proc.s, Pentium.MOV, memop, tmpop);
	    i := 0;
	    WHILE i < 4 DO
	       arr[i] := arr[i+4];
	       INC (i);
	    END;
	    immop := Op.ImmData (FALSE, 4, arr);
	    memop := Op.MemOp1 (reg, 4, off + 4, 0);
	    Emit.Instr2 (proc.s, Pentium.MOV, tmpop, immop);
	    Emit.Instr2 (proc.s, Pentium.MOV, memop, tmpop);
	    memop := Op.MemOp1 (reg, 8, off, 0);
	    I386FPURegisters.CreateValue (reg, proc.fpuregs);
	    I386FPURegisters.PushReal (reg, proc.s, memop);
	    StackAlloc.Free (proc.stack, off);
	    Regs.DestroyOwnedValue (tmp, caller);
	    RETURN Op.FPUOp (reg);
	 | Op.memory:
	    ASSERT(op.memsz IN { 4, 8 });
	    I386FPURegisters.CreateValue (reg, proc.fpuregs);
	    I386FPURegisters.PushReal (reg, proc.s, op);
	    IF op.reg1 # NIL THEN
	       Regs.DestroyOwnedValue (op.reg1, caller);
	    END;
	    IF op.reg2 # NIL THEN
	       Regs.DestroyOwnedValue (op.reg2, caller);
	    END;
	    RETURN Op.FPUOp (reg);
	 END;
      | Sym.integer, Sym.cardinal, Sym.address, Sym.char, Sym.byte:
	 IF (form IN { Sym.integer, Sym.address })
	     & (Op.Loc (op) = Op.memory) & (size IN {2,4,8}) THEN
	    ASSERT(op.memsz = size);
	    I386FPURegisters.CreateValue (reg, proc.fpuregs);
	    I386FPURegisters.PushInt (reg, proc.s, op);
	    IF op.reg1 # NIL THEN
	       Regs.DestroyOwnedValue (op.reg1, caller);
	    END;
	    IF op.reg2 # NIL THEN
	       Regs.DestroyOwnedValue (op.reg2, caller);
	    END;
	    RETURN Op.FPUOp (reg);
	 END;
	 IF Op.Loc (op) = Op.memory THEN
	    op := GenValue (proc, op, form, size, Gen.StdRegs, caller);
	 END;
	 IF (Op.Loc (op) = Op.immediate) OR (Op.Loc (op) = Op.immediateDyn) THEN
	    Regs.CreateValue (tmp, proc.regs, caller, Regs.stdM);
	    Regs.LoadReg (tmp, Gen.StdRegs);
	    tmpop := Op.RegOp (tmp, 4);
	    Emit.Instr2 (proc.s, Pentium.MOV, tmpop, op);
	    op := tmpop;
	 END;
	 ASSERT(Op.Loc (op) = Op.register);
	 Regs.UntracedValue (tmp, Gen.genbp);
	 I386FPURegisters.CreateValue (reg, proc.fpuregs);
	 IF (size = 4) & (form = Sym.cardinal) THEN
	    (* Ouch this hurts! The FPU can only load signed values *)
	    off := StackAlloc.Allocate (proc.stack, 8, 4, FALSE);
	    memop := Op.MemOp1 (tmp, 4, off + 4, 0);
	    Emit.Instr2 (proc.s, Pentium.MOV, memop, op);
	    memop := Op.MemOp1 (tmp, 4, off, 0);
	    Emit.Instr2 (proc.s, Pentium.XOR, op, op);
	    Emit.Instr2 (proc.s, Pentium.MOV, memop, op);
	    memop.memsz := 8;
	    I386FPURegisters.PushInt (reg, proc.s, memop);
	    StackAlloc.Free (proc.stack, off);
	 ELSE
	    Regs.SaveReg (op.reg1);
	    ok := Regs.StackOffset (op.reg1, off); ASSERT(ok);
	    memop := Op.MemOp1 (tmp, 4, off, 0);
	    I386FPURegisters.PushInt (reg, proc.s, memop);
	 END;
	 Regs.DestroyOwnedValue (op.reg1, caller);
	 RETURN Op.FPUOp (reg);
      END;
   END LoadFPUReg;

   PROCEDURE GenValue (proc : PC.Context; op : Op.Operand;
		       form : Sym.Form; size : LONGINT;
		       possible : SET; caller : Regs.Owner) : Op.Operand;
      VAR
	 ops : ARRAY 2 OF Op.Operand;
	 reg : Regs.Value;
	 rset : SET;

   BEGIN
      ASSERT(possible # {});
      ops[0] := NIL;
      ASSERT((op # NIL) & ((size <= 4) OR ((size = 8) & (form = Sym.real))));
      IF form = Sym.real THEN
	 RETURN LoadFPUReg (proc, op, form, size, caller);
      END;
      IF (Op.Loc (op) = Op.immediateDyn) & (form # Sym.real) THEN
	 RETURN CheckOp (op);
      END;
      reg := NIL;
      IF (op.reg1 # NIL) & Regs.Traced (op.reg1) THEN
         reg := op.reg1;
      ELSIF (op.reg2 # NIL) & Regs.Traced (op.reg2) THEN
         reg := op.reg2;
      END;
      IF reg = NIL THEN
	 Regs.CreateValue (reg, proc.regs, caller, Regs.stdM);
	 rset := possible; 
	 IF size < 4 THEN
	    rset := possible * Gen.LowByteRegs;
	    IF rset = {} THEN
	       rset := Gen.LowByteRegs;
	    END;
	    Regs.AddConstraint (reg, rset);
         ELSE
	    Regs.AddConstraint (reg, possible);
	 END;
	 Regs.LoadReg (reg, rset);
      ELSE
	 IF size < 4 THEN
	    rset := possible * Gen.LowByteRegs;
	    IF rset = {} THEN
	       rset := Gen.LowByteRegs;
	    END;
	    Regs.AddConstraint (reg, rset);
         ELSE
	    Regs.AddConstraint (reg, possible);
         END;
      END;
      ops[0] := Op.RegOp (reg, 4);
      ops[1] := op;
      CASE form OF
      | Sym.integer, Sym.address:
	 IF size < 4 THEN
	    Emit.Instr (proc.s, Pentium.MOVSX, 2, ops);
         ELSE
	    Emit.Instr (proc.s, Pentium.MOV, 2, ops);
         END;
      | Sym.cardinal, Sym.char, Sym.byte:
	 IF size < 4 THEN
	    Emit.Instr (proc.s, Pentium.MOVZX, 2, ops);
         ELSE
            Emit.Instr (proc.s, Pentium.MOV, 2, ops);
         END;
      ELSE
         Emit.Instr (proc.s, Pentium.MOV, 2, ops);
      END;
      IF (op.reg1 # NIL) & (op.reg1 # reg) THEN
	 Regs.DestroyOwnedValue (op.reg1, caller);
      END;
      IF (op.reg2 # NIL) & (op.reg2 # reg) THEN
	 Regs.DestroyOwnedValue (op.reg2, caller);
      END;
      Regs.RemoveConstraint (ops[0].reg1);
      Regs.Chown (ops[0].reg1, caller);
      RETURN CheckOp(ops[0]);
   END GenValue;


   (* Generate code to access a variable. If ``byvalue'' is true we
    * return the content of the variable, else we return the address
    *)
   PROCEDURE GenVar (proc : PC.Context; var : VarDesc; byvalue : BOOLEAN;
                     possible : SET; caller : Regs.Owner) : Op.Operand;

      VAR
	 msize : LONGINT;
	 lev, codelev : INTEGER;
	 ref : Relocations.SymRef;
	 op : Op.Operand;
	 reloc : Relocations.RelocRequest;
	 own : Regs.Owner;
	 ok : BOOLEAN;
	 reg, reg2 : Regs.Value;
	 ops : ARRAY 2 OF Op.Operand;
	 offset, add : LONGINT;
	 load : BOOLEAN;

   BEGIN
      ref := NIL;
      ASSERT((var # NIL) & (var.mode IN {identM, stackM, offsetM}));
      ASSERT(~byvalue OR (var.mode = identM));
      ASSERT(var.mode # offsetM);
      own := Regs.GetOwner (proc.regs);
      CASE var.mode OF
      | identM: msize := Sym32.GetSize (proc.module, var.ident.type, proc.errors);
      | stackM, offsetM: msize := 4;
      END;
      IF (var.ident.module # NIL) & (ConstStrings.Compare (
               RealName (var.ident.module), RealName(proc.module)) # 0) THEN
	 (* Imported Identifier *)
	 ASSERT(var.mode = identM);
	 ASSERT(var.ident.varkind = Sym.noParam);
	 NEW (ref);
	 op := Op.MemOp0 (msize, 0, 4);
	 ref.modname := RealName (var.ident.module);
	 ref.symname := var.ident.name;
	 Relocations.Create (reloc, proc.s, Relocations.addSym, ref);
	 Op.RelocOpen (op, reloc);
	 IF ~byvalue THEN
	    RETURN CheckOp(op);
         END;
      ELSE
	 (* Variable of the "local" Module *)
	 lev := Scopes.Level (OA.VarScope (var.ident)); ASSERT(lev >= 2);
	 IF lev = 2 THEN
	    (* Global Variable *)
	    ASSERT(var.ident.varkind = Sym.noParam);
	    ASSERT(var.mode = identM);
	    op := Op.MemOp0 (msize, OA.VarOffset (var.ident), 4);
	    NEW (ref);
	    ref.modname := RealName (proc.module);
	    ConstStrings.Create (ref.symname, "__global_variables");
	    Relocations.Create (reloc, proc.s, Relocations.addSym, ref);
	    Op.RelocOpen (op, reloc);
	    IF ~byvalue THEN
	       RETURN CheckOp(op);
            END;
	 ELSE
	    (* First walk up the backlink chain *)
	    codelev := proc.level;
            ASSERT(codelev >= lev);
	    Regs.UntracedValue (reg, Gen.genbp);
	    ops[1] := Op.MemOp1 (reg, 4 (*addr*), 8 (* skip EBP and EIP *), 0);
	    reg2 := reg;
	    WHILE codelev > lev DO
	       IF reg2 = reg THEN
	          Regs.CreateValue (reg2, proc.regs, own, Regs.addrM);
		  Regs.LoadReg (reg2, Gen.StdRegs);
	       END;
               ops[0] := Op.RegOp (reg2, 4);
	       Emit.Instr (proc.s, Pentium.MOV, 2, ops);
	       DEC (codelev);
	       ops[1] := Op.MemOp1 (reg2, 4 (*address*),
	                            8 (* skip old EBP and EIP*), 0);
	    END;
	    (* OK. The base pointer of the relevant segment is in reg2.
	     * Note that reg2 may still be untraced! *)
	    add := 0;
	    (* With the current stack layout the local variables start
	     * directly below %ebp. No offset is needed. *)
	    IF (var.ident.varkind IN {Sym.valueParam, Sym.refParam}) &
	       (var.mode IN {identM, stackM}) THEN
	       add := 8;  (* EIP and EBP *)
	       IF lev > 3 THEN
		  add := 12; (* EIP, EBP and Backlink *)
	       END;
	    END;
	    load := TRUE;
	    IF var.mode = offsetM THEN
	       offset := var.offset+add;
            ELSIF var.mode IN {identM, stackM} THEN
	       offset := OA.VarOffset (var.ident);
	       IF offset >= 0 THEN
	          INC(offset, add);
	       ELSE
	          (* A parameter that was passed by reference, but it
		   * was copied and is now accessed with a fixed ebp offset
                   * or a local variable.
		   *)
	          ASSERT(var.mode = identM);
		  load := FALSE;
		  ASSERT(var.ident.varkind # Sym.refParam);
	       END;
	    END;
	    op := Op.MemOp1 (reg2, 4 (* ok for offsetM! *), offset, 0);
            IF var.mode IN {offsetM, stackM} THEN
	       ASSERT(~byvalue);
	       IF reg2 # reg THEN
		  ChownOp (op, caller);
	       END;
	       RETURN CheckOp (op);
	    END;
	    ASSERT(var.mode = identM);
	    (* These are the cases where variables are passed by reference.
	     * They may have been copied by the called procedure. This is
	     * detected by a negative ebp offset above (=> load = FALSE). *)
	    IF (load & (var.ident.varkind = Sym.valueParam) &
	        (var.ident.type.form = Sym.array)) OR
	       (var.ident.varkind = Sym.refParam) THEN
               IF ~Regs.Traced (reg2) THEN
	          Regs.CreateValue (reg2, proc.regs, own, Regs.addrM);
		  Regs.LoadReg (reg2, Gen.StdRegs);
	       END;
	       ops[1] := op;
	       ops[0] := Op.RegOp (reg2, 4 (* address *));
	       Emit.Instr (proc.s, Pentium.MOV, 2, ops);
	       op := Op.MemOp1 (reg2, 4 (* corrected below *), 0, 0);
	    END;
	    op.memsz := msize;
	    IF reg2 # reg THEN
	       Regs.Chown (reg2, caller);
	    END;
	    IF ~byvalue THEN
	       RETURN op;
	    END;
	 END;
      END;
      op := GenValue (proc, op, var.type.form, msize, possible, caller);
      IF op.reg1 # NIL THEN
         SetMode (op.reg1, var.type);
      END;
      RETURN CheckOp (op);
   END GenVar;


   PROCEDURE GenIndex (proc : PC.Context; at : Sym.Attribute;
		       byvalue : BOOLEAN; possible : SET;
		       caller : Regs.Owner) : Op.Operand;
      VAR
	 scale, scale2 : INTEGER;
	 dim, elmsz, mul : LONGINT;
	 dummy : SYSTEM.ADDRESS;
	 size, final, index, op, op2 : Op.Operand;
	 ops : ARRAY 3 OF Op.Operand;
	 own : Regs.Owner;
	 type : Sym.Type;
	 tmp : Sym.Attribute;
	 var : VarDesc;
	 dope, sizes : Op.Operand;
	 reg : Regs.Value;
	 attype : Sym.Type;
	 beyond : FragmentedStreams.Label;
   BEGIN
      size := NIL;
      ASSERT(at.designator # NIL);
      Sym32.GetType (at.designator, attype);
      own := Regs.GetOwner (proc.regs);
      IF attype.dyn THEN
	 tmp := at;
	 dim := 0;
         WHILE tmp.mode = Sym.indexAt DO
	    ASSERT(tmp.designator.type.dyn);
	    INC(dim);
            tmp := tmp.designator;
	 END;
         ASSERT(tmp.mode = Sym.varAt);
	 NEW(var);
	 var.mode := stackM;
	 var.ident := tmp.ident;
	 dope := GenVar (proc, var, FALSE, Gen.StdRegs, own);
	 IF Op.IsError (dope) THEN
	    Regs.DestroyOwnerOnError (proc.regs, own);
	    RETURN dope
	 END;
         sizes := Op.Dup (dope);
	 sizes.disp := OA.SizesOffset (tmp.ident);
	 ASSERT(dim > 0);
	 INC(sizes.disp, dim*Ob32.int32Size);
	 INC(dope.disp, Ob32.pointerSize+dim*Ob32.int32Size);
	 final := NIL;
	 tmp := at;
	 WHILE tmp.mode = Sym.indexAt DO
	    DEC(dope.disp, Ob32.int32Size);
	    index := GenExpr (proc, tmp.index, TRUE, Gen.StdRegs, own);
	    IF Op.IsError (index) THEN
	       Regs.DestroyOwnerOnError (proc.regs, own);
	       RETURN index
	    END;
            IF Op.Loc (index) IN {Op.immediate, Op.immediateDyn} THEN
	       Regs.CreateValue (reg, proc.regs, own, Regs.stdM);
	       Regs.LoadReg (reg, Gen.StdRegs);
	       Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (reg, 4), index);
	       index := Op.RegOp (reg, 4);
	    END;
	    CreateLabel (beyond, "Run error: index out of range",
			 tmp.index.loc, proc.s);
	    Emit.Instr2 (proc.s, Pentium.CMP, index, dope);
	    Emit.JumpCC (proc.s, beyond, Pentium.JB-Pentium.JCC);
	    Regs.EnterLevel (proc.regs);
	    (* XXX Subtract one from dope! *)
	    EmitErrors.RangeCheck (proc, at.loc, index, dope);
	    Regs.LeaveLevel (proc.regs);
	    Regs.DoneLevel (proc.regs);
	    FragmentedStreams.AttachLabel (proc.s, beyond);
            Emit.Instr2 (proc.s, Pentium.MUL, index, sizes);
	    DEC(sizes.disp, Ob32.int32Size);
	    IF final = NIL THEN
	       final := index;
            ELSE
	       Emit.Instr2 (proc.s, Pentium.ADD, final, index);
	       Regs.DestroyOwnedValue (index.reg1, own);
	       Regs.DestroyOwnedValue (index.reg2, own);
	    END;
	    tmp := tmp.designator;
	 END;
	 DEC(dope.disp, Ob32.pointerSize);
	 ASSERT((final # NIL) & (Op.Loc (final) = Op.register));
	 Emit.Instr2 (proc.s, Pentium.ADD, final, dope);
         Regs.SetMode (final.reg1, Regs.addrM);
	 elmsz := 4;  (* Default if the result is an open array *)
	 IF ~at.type.dyn THEN
	    elmsz := Sym32.GetSize (proc.module, attype.element,
	                            proc.errors);
	 END;
	 Regs.DestroyOwnedValue (dope.reg1, own);
	 Regs.DestroyOwnedValue (dope.reg2, own);
	 final := Op.MemOp1 (final.reg1, elmsz, 0, 0);
	 IF byvalue THEN
	    final := GenValue (proc, final, at.type.form, elmsz,
	                       possible, caller);
            SetMode (final.reg1, at.type);
	 ELSE
	    Regs.Chown (final.reg1, caller);
	 END;
	 RETURN CheckOp (final);
      END;
      IF attype.form = Sym.pointer THEN
	 type := at.designator.type.reftype.element;
	 elmsz := Sym32.GetSize (proc.module, type, proc.errors);
      ELSE
	 type := at.designator.type.element;
	 elmsz := Sym32.GetSize (proc.module, type, proc.errors);
      END;
      IF at.designator.type.form = Sym.pointer THEN
         op2 := GenExpr (proc, at.designator, TRUE, Gen.StdRegs, own);
         IF Op.IsError (op2) THEN
	    Regs.DestroyOwnerOnError (proc.regs, own);
	    RETURN op2
	 END;
         ASSERT(Op.Loc(op2) = Op.register);
	 op2 := Op.MemOp1 (op2.reg1, elmsz, 0, 0);
      ELSE
         op2 := GenDesignator (proc, at.designator, Gen.StdRegs, own);
         IF Op.IsError (op2) THEN
	    Regs.DestroyOwnerOnError (proc.regs, own);
	    RETURN op2
	 END;
      END;
      op := GenExpr (proc, at.index, TRUE, Gen.StdRegs, own);
      IF Op.IsError (op) THEN
	 Regs.DestroyOwnerOnError (proc.regs, own);
	 RETURN op
      END;
      (* OK, at this point the array base is in op2 and the index is
       * in op *)
      IF attype.form = Sym.pointer THEN
	 size := GenExpr (NIL, attype.reftype.length, FALSE, {}, -1);
      ELSE
         (* Dynamic arrays were handled above. *)
	 size := GenExpr (NIL, attype.length, FALSE, {}, -1);
      END;
      ASSERT(Op.Loc(size) IN {Op.immediate, Op.immediateDyn});
      ASSERT(Op.Loc(op2) = Op.memory);
      (* op2 will later be the result operand, i.e. it must be
       * a reference to a single array element, not the whole array *)
      op2.memsz := elmsz;
      IF Op.Loc (op) IN {Op.immediate, Op.immediateDyn} THEN
	 (* Index Expression  is constant *)
	 ASSERT(op.data.kind = Op.integerConst);
	 ASSERT(size.data.kind = Op.integerConst);
	 IF op.data.intval >= size.data.intval THEN
	    CompilerErrors.Raise (proc.errors, at.index.loc,
				  "index out of range");
	    Regs.DestroyOwnerOnError (proc.regs, own);
	    RETURN Op.Error ();
	 END;
	 INC(op2.disp, elmsz * op.data.intval);
	 ChownOp (op2, caller);
	 IF ~byvalue THEN
	    RETURN CheckOp(op2);
         END;
	 ASSERT(elmsz # 0);
	 RETURN CheckOp(GenValue (proc, op2, type.form, elmsz, possible,
			  caller));
      ELSE
	 (* Index is in reg *)
	 ASSERT(Op.Loc (op) = Op.register);
	 CreateLabel (beyond, "Index out of range error", at.index.loc, proc.s);
	 Emit.Instr2 (proc.s, Pentium.CMP, op, size);
	 Emit.JumpCC (proc.s, beyond, Pentium.JB-Pentium.JCC);
	 Regs.EnterLevel (proc.regs);
	 (* XXX Subtract 1 from size! *)
	 EmitErrors.RangeCheck (proc, at.loc, op, size);
	 Regs.LeaveLevel (proc.regs);
	 Regs.DoneLevel (proc.regs);
	 FragmentedStreams.AttachLabel (proc.s, beyond);
	 (* Check if we can scale in hardware *)
	 CASE elmsz OF
	 | 1,2,4,8:
	    scale := SHORT(elmsz);
	 ELSE
	   (* Scale by Hand, it can't be done in hardware *)
	   scale := 1;
	   ops[2] := Op.ImmInt (elmsz);
	   ops[0] := op;
	   ops[1] := op;
	   ASSERT(op.memsz = 4);
	   Emit.Instr (proc.s, Pentium.IMUL, 3, ops);
	 END;
	 (* Let's see where the base is *)
	 IF (op2.reg1 = NIL) & (op2.reg2 # NIL) THEN
	    Op.Scale (op2, scale2);
	    IF scale2 = 1 THEN
	       op2.reg1 := op2.reg2;
	       op2.reg2 := NIL;
            END;
	 END;
	 IF op2.reg2 = NIL THEN
	    (* Great! Just use the index *)
	    op2.reg2 := op.reg1;
	    Op.SetScale (op2, scale);
	 ELSIF op2.reg1 = NIL THEN
	    (* Oops, index is in use, but base is free *)
	    IF scale # 1 THEN
	       (* We wanted to scale in hardware, now we have to do it
		* by hand *)
	       ops[0] := op;
	       CASE scale OF
	       |2:
		  mul := 1;
	       |4:
		  mul := 2;
	       |8:
		  mul := 3;
	       (* ELSE fail! scale should be 1, 2, 4 or 8 here. *)
	       END;
	       ops[1] := Op.ImmInt (mul);
	       Emit.Instr (proc.s, Pentium.SHL, 2, ops);
	    END;
	    op2.reg1 := op.reg1;
	 ELSE
	    (* Both registers are used by the base. We have to add
	     * the index manually *)
	    IF ~Regs.Traced (op2.reg1) THEN
	       ASSERT (Regs.Traced (op2.reg2));
	       ops[0] := Op.RegOp (op2.reg2, 4 (* pointer *));
	    ELSE
	       ops[0] := Op.RegOp (op2.reg1, 4 (* pointer *));
	    END;
	    ops[1] := op2;
	    op2.memsz := 4; (* This is ok, we just load the address *)
	    Emit.Instr (proc.s, Pentium.LEA, 2, ops);
	    Regs.SetMode (ops[0].reg1, Regs.addrM);
	    IF op2.reg2 # ops[0].reg1 THEN
	       Regs.DestroyValue (op2.reg2);
	    END;
	    op2 := Op.MemOp2 (ops[0].reg1, op.reg1, 4(* set below *), 0, 0, scale);
	 END;
	 (* Ok. op2 is the result Operand, but what if the caller
	  * requested byvalue ? *)
	 op2.memsz := elmsz;
	 ChownOp (op2, caller);
         IF byvalue THEN
	    ASSERT(elmsz # 0);
	    op := GenValue (proc, op2, type.form, elmsz, possible, caller);
            SetMode (op.reg1, type);
	    ASSERT(Op.Loc (op) IN {Op.immediate, Op.immediateDyn, Op.register, Op.error});
	    RETURN CheckOp(op);
	 END;
	 RETURN CheckOp(op2);
      END;
   END GenIndex;


   PROCEDURE GenSelect (proc : PC.Context; at : Sym.Attribute;
			byvalue : BOOLEAN; possible : SET;
		        caller : Regs.Owner) : Op.Operand;
      VAR
	 msize : LONGINT;
	 offset : LONGINT;
	 op : Op.Operand;
	 ops : ARRAY 2 OF Op.Operand;
	 type : Sym.Type;
	 own : Regs.Owner;
   BEGIN
      op := NIL;
      ASSERT(at.designator # NIL);
      own := Regs.GetOwner(proc.regs);
      IF at.designator.type.form = Sym.pointer THEN
	 ASSERT(possible # {});
	 type := at.field.type;
	 offset := Sym32.GetOffset (proc.module, at.field);
	 msize := Sym32.GetSize (proc.module, type, proc.errors);
	 op := GenExpr (proc, at.designator, TRUE, Gen.StdRegs, own);
         IF Op.IsError (op) THEN
	    Regs.DestroyOwnerOnError (proc.regs, own);
	    RETURN op
	 END;
	 ASSERT((Op.Loc(op) = Op.register) & (op.reg1 # NIL));
	 op := Op.MemOp1 (op.reg1, msize, offset, 0);
	 IF ~byvalue THEN
	    Regs.Chown (op.reg1, caller);
	    RETURN CheckOp(op);
         END;
      ELSE
	 offset := Sym32.GetOffset (proc.module, at.field);
	 type := at.field.type;
	 msize := Sym32.GetSize (proc.module, type, proc.errors);
	 op := GenDesignator (proc, at.designator, Gen.StdRegs, own);
         IF Op.IsError (op) THEN
	    Regs.DestroyOwnerOnError (proc.regs, own);
	    RETURN op
	 END;
	 INC(op.disp, offset);
	 op.memsz := msize;
	 IF ~byvalue THEN
	    ChownOp (op, caller);
	    RETURN CheckOp(op);
         END;
      END;
      ChownOp (op, caller);
      op := GenValue (proc, op, type.form, msize, possible, caller);
      SetMode (op.reg1, type);
      RETURN CheckOp(op);
   END GenSelect;


   PROCEDURE BoolDoneVal (proc : PC.Context; context : BoolContext;
		          val : BOOLEAN);
      VAR
	 ops : ARRAY 2 OF Op.Operand;
   BEGIN
      ops[0] := NIL;
      IF (context.target # NIL) & ((context.setaction = setAll) OR
		                   (val & (context.setaction = setTrue)) OR
		                   (~val & (context.setaction = setFalse))) THEN
         ops[0] := context.target;
	 IF context.neg THEN
	    ops[1] := Op.ImmBool (~val);
         ELSE
	    ops[1] := Op.ImmBool (val);
         END;
         Emit.Instr (proc.s, Pentium.MOV, 2, ops);
      END;
      Regs.SaveAll(proc.regs);
      IF val THEN
	 IF context.truelab # NIL THEN
	    Emit.Jump (proc.s, context.truelab);
	 END;
      ELSE
	 IF context.falselab # NIL THEN
	    Emit.Jump (proc.s, context.falselab);
	 END;
      END;
   END BoolDoneVal;

   PROCEDURE BoolDoneCC (proc : PC.Context; context : BoolContext;
			 cc : LONGINT);
      VAR
	 ops : ARRAY 2 OF Op.Operand;
	 l : FragmentedStreams.Label;
   BEGIN
      ops[0] := NIL;
      l := NIL;
      CASE context.setaction OF
      | setNever:
         Regs.SaveAll(proc.regs);
	 IF context.truelab # NIL THEN
	    Emit.JumpCC (proc.s, context.truelab, cc);
	    IF context.falselab # NIL THEN
	       Emit.Jump (proc.s, context.falselab)
            END;
         ELSIF context.falselab # NIL THEN
	    Emit.JumpCC (proc.s, context.falselab, NegCC(cc));
	 END;
      | setAll:
	 ops[0] := context.target;
	 IF context.neg THEN
	    Emit.Instr (proc.s, Pentium.SETCC+NegCC(cc), 1, ops);
	 ELSE
	    Emit.Instr (proc.s, Pentium.SETCC+cc, 1, ops);
         END;
         Regs.SaveAll(proc.regs);
	 IF context.truelab # NIL THEN
	    Emit.JumpCC (proc.s, context.truelab, cc);
	    IF context.falselab # NIL THEN
	       Emit.Jump (proc.s, context.falselab)
            END;
         ELSIF context.falselab # NIL THEN
	    Emit.JumpCC (proc.s, context.falselab, NegCC(cc));
	 END;
      | setTrue:
	 CreateLabel (l, "BoolDoneCC: setTrue", NIL, proc.s);
         Regs.SaveAll(proc.regs);
	 Emit.JumpCC (proc.s, l, NegCC (cc));
	 BoolDoneVal (proc, context, TRUE);
	 FragmentedStreams.AttachLabel (proc.s, l);
      | setFalse:
	 CreateLabel (l, "BoolDoneCC:  setFalse", NIL, proc.s);
         Regs.SaveAll(proc.regs);
	 Emit.JumpCC (proc.s, l, cc);
	 BoolDoneVal (proc, context, FALSE);
	 FragmentedStreams.AttachLabel (proc.s, l);
      END;
   END BoolDoneCC;

   (* Return the condition Code that can be used to test a
    * condition (aka boolean Expression).
    * Boolean Expressions have special properties: The result can only
    * be used for three things:
    * - negate it
    * - jump if result is true/false
    * - store it somewhere.
    * Register Management is safe. This is achieved by a call to
    * Regs.SaveAll at the very start of a boolean expression and
    * another Regs.SaveAll bevor each Jump.
    *)
    
   PROCEDURE GenBool (proc : PC.Context; at : Sym.Attribute;
		      context : BoolContext);
      VAR
         attach : CompilerObjects.Attachment;
	 op : Op.Operand;
	 ops : ARRAY 2 OF Op.Operand;
	 own : Regs.Owner;
	 truelab, endlab, l, beyond : TrackedLabel;
	 lab : FragmentedStreams.Label;
	 ctxt : BoolContext;
	 result : Regs.Value;
	 offset : LONGINT;
	 ok : BOOLEAN;
	 reg : Regs.Value;
	 var : VarDesc;
   BEGIN
      attach := NIL;
      ASSERT(at.type.form = Sym.boolean);
      CompilerObjects.GetAttachment (at, attach);
      IF (attach # NIL) & (attach IS Sym32.Attribute) &
	 (attach(Sym32.Attribute).kind # Sym32.noConst) THEN
	 ASSERT(attach(Sym32.Attribute).kind = Sym32.booleanConst);
	 BoolDoneVal (proc, context, attach(Sym32.Attribute).boolval);
	 RETURN;
      END;
      own := Regs.GetOwner (proc.regs);
      Regs.SaveAll(proc.regs);
      IF at.mode IN Sym.designatorModes THEN
	 ops[0] := GenDesignator (proc, at, Gen.StdRegs, own);
         IF Op.IsError (ops[0]) THEN
	    Regs.DestroyOwnerOnError (proc.regs, own);
	    RETURN
	 END;
         ops[1] := Op.ImmInt(1);
	 Emit.Instr (proc.s, Pentium.TEST, 2, ops);
	 Regs.DestroyOwnedValue (ops[0].reg1, own);
	 Regs.DestroyOwnedValue (ops[0].reg2, own);
	 BoolDoneCC (proc, context, Pentium.JNZ-Pentium.JCC);
	 RETURN;
      END;
      CASE at.mode OF
      | Sym.constAt:
	 GenBool (proc, at.ident.constexpr, context);
      (* | Sym.procAt: Type of a procAt is a procedure type. This can't
                       happen here. *)
      | Sym.callAt:
	 IF at.proc.type.builtin THEN
	    op := I386BuiltIns.GenBuiltIn (proc, at, {}, own);
            IF Op.IsError (op) THEN
	       Regs.DestroyOwnerOnError (proc.regs, own);
	       RETURN
	    END;
	    ASSERT(Op.Loc (op) = Op.condition);
	    BoolDoneCC (proc, context, op.disp);
	 ELSE
	    result := GenCall (proc, at, own);
	    ok := Regs.StackOffset (result, offset); ASSERT(ok);
	    Regs.UntracedValue (reg, Gen.genbp);
	    ops[0] := Op.MemOp1 (reg, 4, offset, 0);
	    ops[1] := Op.ImmInt (1);
	    Emit.Instr (proc.s, Pentium.TEST, 2, ops);
	    Regs.DestroyOwnedValue (result, own);
	    BoolDoneCC (proc, context, Pentium.JNZ-Pentium.JCC);
	 END;
      | Sym.unaryAt:
	 ASSERT(at.opsy = Lex.tilde);
	 NEW(ctxt);
	 ctxt.neg := ~context.neg;
	 ctxt.truelab := context.falselab;
	 ctxt.falselab := context.truelab;
	 ctxt.target := context.target;
	 CASE context.setaction OF
	 | setNever, setAll:
	    ctxt.setaction := context.setaction;
         | setTrue:
	    ctxt.setaction := setFalse;
         | setFalse:
	    ctxt.setaction := setTrue;
	 END;
	 GenBool (proc, at.rightop, ctxt);
      | Sym.binaryAt:
	 CASE at.opsy OF
	 | Lex.or:
	    NEW(ctxt);
	    ctxt.neg := context.neg;
	    ctxt.setaction := setNever;
	    ctxt.target := NIL;
	    IF context.setaction IN {setAll, setTrue} THEN
	       ctxt.setaction := setTrue;
	       ctxt.target := context.target;
	    END;
	    ctxt.falselab := NIL;
	    ctxt.truelab := context.truelab;
	    l := NIL;
	    IF ctxt.truelab = NIL THEN
	       CreateLabel (l, "GenBool: Lex.or", at.loc, proc.s);
	       ctxt.truelab := l;
	    END;
	    GenBool (proc, at.leftop, ctxt);
	    GenBool (proc, at.rightop, context);
	    IF l # NIL THEN
	       FragmentedStreams.AttachLabel (proc.s, l);
	    END;
	 | Lex.ampersand:
	    NEW(ctxt);
	    ctxt.neg := context.neg;
	    ctxt.setaction := setNever;
	    ctxt.target := NIL;
	    IF context.setaction IN {setAll, setFalse} THEN
	       ctxt.setaction := setFalse;
	       ctxt.target := context.target;
	    END;
	    ctxt.truelab := NIL;
	    ctxt.falselab := context.falselab;
	    l := NIL;
	    IF ctxt.falselab = NIL THEN
	       CreateLabel (l, "GenBool: Lex.ampersand", at.loc, proc.s);
	       ctxt.falselab := l;
	    END;
	    GenBool (proc, at.leftop, ctxt);
	    GenBool (proc, at.rightop, context);
	    IF l # NIL THEN
	       FragmentedStreams.AttachLabel (proc.s, l);
	    END;
	 | Lex.is:
	    CASE at.leftop.type.form OF
	    | Sym.pointer:
	       ASSERT(at.leftop.type.taggedptr);
	       op := GenExpr (proc, at.leftop, TRUE, Gen.StdRegs, own);
	       IF ~Op.IsError (op) THEN
		  reg := LoadPtrTag (proc, op, own);
	       END;
	    | Sym.record:
	       ASSERT((at.leftop.mode = Sym.varAt) &
		       (at.leftop.ident.varkind = Sym.refParam));
	       NEW(var);
	       var.ident := at.leftop.ident;
	       var.mode := stackM;
	       op := GenVar (proc, var, FALSE, Gen.StdRegs, own);
	       IF ~Op.IsError (op) THEN
		  reg := LoadVarParamTag (proc, op, own);
	       END;
	    END;
	    IF Op.IsError (op) THEN
	       Regs.DestroyOwnerOnError (proc.regs, own);
	       RETURN;
	    END;
	    Regs.DestroyOwnedValue (op.reg1, own);
	    Regs.DestroyOwnedValue (op.reg2, own);
	    CreateLabel (truelab, "IS truelab", at.loc, proc.s);
	    CreateLabel (endlab, "IS endlab", at.loc, proc.s);
	    GenTypes.TypeGuard (proc, reg, at.rightop.ident.type,
	                        truelab, at.loc);
	    Regs.DestroyOwnedValue (reg, own);
	    BoolDoneVal (proc, context, FALSE);
	    Emit.Jump (proc.s, endlab);
	    FragmentedStreams.AttachLabel (proc.s, truelab);
	    BoolDoneVal (proc, context, TRUE);
	    FragmentedStreams.AttachLabel (proc.s, endlab);
         | Lex.in, Lex.eql, Lex.neq, Lex.lst, Lex.grt, Lex.leq, Lex.geq:
	    IF at.leftop.type.form # Sym.boolean THEN
	       op := GenExpr  (proc, at, FALSE, {}, own);
	       IF Op.IsError (op) THEN
		  Regs.DestroyOwnerOnError (proc.regs, own);
		  RETURN
	       END;
	       ASSERT(Op.Loc (op) IN {Op.immediate, Op.immediateDyn, Op.condition});
	       IF Op.Loc(op) IN {Op.immediate, Op.immediateDyn} THEN
	          ASSERT(op.data # NIL);
	          ASSERT(op.data.kind = Op.booleanConst);
                  BoolDoneVal (proc, context, op.data.boolval);
               ELSE
	          BoolDoneCC (proc, context, op.disp);
	       END;
            ELSE
	       (* Comparison of two boolean values. This is implemented
	        * as follows (Lex.eql case):
	        * IF at.leftop THEN
		*    RETURN at.rightop
	        * ELSE
		*    RETURN ~at.rightop
	        * END;
		* In the Lex.neq case we flip the jump targets of the first
		* boolean expressen:
		* IF ~at.leftop THEN
		*    RETURN at.rightop
		* ELSE
		*    RETURN ~at.rightop
		* END;
		*)
	       NEW (ctxt);
	       ctxt.neg := at.opsy = Lex.neq;   (* Not needed (setNever!) *)
	       IF at.opsy = Lex.neq THEN
		  CreateLabel (ctxt.truelab, "GenBool: compare first false", at.loc, proc.s);
		  ctxt.falselab := NIL;
	       ELSE
		  CreateLabel (ctxt.falselab, "GenBool: compare first false", at.loc, proc.s);
		  ctxt.truelab := NIL;
	       END;
	       ctxt.target := NIL;
	       ctxt.setaction := setNever;
	       (* Evaluate at.leftop and jump if FALSE *)
	       GenBool (proc, at.leftop, ctxt);
	       (* The first expression was TRUE. We must skip the
	        * FALSE case. We do this by assigning the beyond label
		* if the origianl context didn't provide a jump target. *)
	       CreateLabel (beyond, "GenBool: compare beyond", at.loc, proc.s);
	       IF context.truelab = NIL THEN
	          context.truelab := beyond;
	       END;
	       IF context.falselab = NIL THEN
	          context.falselab := beyond;
	       END;
	       (* Evaluate the second expression. *)
	       GenBool (proc, at.rightop, context);
	       (* Jump here if first expression was FALSE *)
	       IF at.opsy = Lex.neq THEN
		  FragmentedStreams.AttachLabel (proc.s, ctxt.truelab);
	       ELSE
		  FragmentedStreams.AttachLabel (proc.s, ctxt.falselab);
	       END;
	       (* Remove the unnecessary beyond jump targets. *)
	       IF context.truelab = beyond THEN
	          context.truelab := NIL;
	       END;
	       IF context.falselab = beyond THEN
	          context.falselab := NIL;
	       END;
	       (* at.leftop was FALSE, i.e. overall result is NOT at.rightop.
	        * Note that we also have to skip the jump targets! *)
	       context.neg := ~context.neg;
	       lab := context.truelab;
	       context.truelab := context.falselab;
	       context.falselab := lab;
	       GenBool (proc, at.rightop, context);
	       (* We should have used a new context, but restoring the
	        * old contents should work as well. *)
	       lab := context.truelab;
	       context.truelab := context.falselab;
	       context.falselab := lab;
	       context.neg := ~context.neg;
	       FragmentedStreams.AttachLabel (proc.s, beyond);
            END;
	 END;
      END;
   END GenBool;

   PROCEDURE GenGuard (proc : PC.Context; at : Sym.Attribute;
		       byvalue : BOOLEAN; possible : SET;
		       caller : Regs.Owner) : Op.Operand;
      VAR
	 own : Regs.Owner;
	 ret, op2 : Op.Operand;
	 tagreg : Regs.Value;
	 var : VarDesc;
   BEGIN
      ret := NIL;
      own := Regs.GetOwner (proc.regs);
      CASE at.designator.type.form OF
      | Sym.pointer:
         ASSERT(at.designator.type.taggedptr);
	 IF byvalue THEN
	    ret := GenExpr (proc, at.designator, byvalue, possible, own);
	 ELSE
	    ret := GenDesignator (proc, at.designator, Gen.StdRegs, own);
	 END;
	 IF Op.IsError (ret) THEN
	    Regs.DestroyOwnerOnError (proc.regs, own);
	    RETURN ret;
	 END;
	 op2 := Op.Dup (ret);
	 tagreg := LoadPtrTag (proc, op2, own);
	 GenTypes.TypeGuard (proc, tagreg, at.guard.type, NIL, at.loc);
	 Regs.DestroyOwnedValue (tagreg, own);
      | Sym.record:
	 ASSERT((at.designator.mode = Sym.varAt) &
		 (at.designator.ident.varkind = Sym.refParam));
	 NEW(var);
	 var.ident := at.leftop.ident;
	 var.mode := stackM;
	 ret := GenVar (proc, var, FALSE, Gen.StdRegs, own);
	 IF Op.IsError (ret) THEN
	    Regs.DestroyOwnerOnError (proc.regs, own);
	    RETURN ret;
	 END;
	 op2 := Op.Dup (ret);
	 op2.memsz := 4;
	 tagreg := LoadVarParamTag (proc, op2, own);
	 GenTypes.TypeGuard (proc, tagreg, at.guard.type, NIL, at.loc);
	 Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (tagreg, 4), ret);
         Regs.SetMode (tagreg, Regs.addrM);
	 Regs.DestroyOwnedValue (op2.reg1, own);
	 Regs.DestroyOwnedValue (op2.reg2, own);
	 ret := Op.MemOp1 (tagreg, 4, 0, 0);
      END;
      ChownOp (ret, caller);
      RETURN CheckOp (ret);
   END GenGuard;


   PROCEDURE IterateCommaList (it : Iterators.Iterator;
			       at : Iterators.Reference;
			       mode : Iterators.Mode);
   BEGIN
      IF at = NIL THEN RETURN END;
      WITH at : Sym.Attribute DO
	 IF at.mode # Sym.binaryAt THEN
	    Iterators.Yield (it, at);
	    RETURN;
	 END;
	 IF at.opsy # Lex.comma THEN
	    Iterators.Yield (it, at);
	    RETURN;
	 END;
	 IterateCommaList (it, at.leftop, mode);
	 IterateCommaList (it, at.rightop, mode);
      END;
   END IterateCommaList;


   PROCEDURE GenFPUBinaryExpr (proc : PC.Context; at : Sym.Attribute;
			       own : Regs.Owner) : Op.Operand;
      VAR
	 ops : ARRAY 2 OF Op.Operand;
	 instr : Gen.Mnemonic;
	 left, right, tmp : Sym.Attribute;
	 reverse : BOOLEAN;
	 big : SET;
   BEGIN
      left := at.leftop; right := at.rightop;
      reverse := FALSE;
      big := { Sym.binaryAt, Sym.callAt };
      IF (right.mode = Sym.binaryAt) OR ~(left.mode IN big) THEN
	 tmp := left;
	 left := right;
	 right := tmp;
	 reverse := TRUE;
      END;
      ops[0] := GenExpr (proc, left, FALSE, Gen.StdRegs, own);
      IF Op.IsError (ops[0]) THEN
	 Regs.DestroyOwnerOnError (proc.regs, own);
	 RETURN ops[0];
      END;
      ops[0] := LoadFPUReg (proc, ops[0], left.type.form,
			    ops[0].memsz, own);
      ops[1] := GenExpr (proc, right, FALSE, Gen.StdRegs, own);
      IF Op.IsError (ops[1]) THEN
	 Regs.DestroyOwnerOnError (proc.regs, own);
	 RETURN ops[1];
      END;
      ops[1] := LoadFPUReg (proc, ops[1], right.type.form,
			    ops[1].memsz, own);
      instr := -1;
      CASE at.opsy OF
      | Lex.plus:
	 instr := Pentium.FADDP;
      | Lex.minus:
	 instr := Pentium.FSUBP;
	 IF reverse THEN
	    instr := Pentium.FSUBRP;
	 END;
      | Lex.times:
	 instr := Pentium.FMULP;
      | Lex.slash:
	 instr := Pentium.FDIVP;
	 IF reverse THEN
	    instr := Pentium.FDIVRP;
	 END;
      END;
      IF instr # -1 THEN
	 I386FPURegisters.Instr2 (proc.s, instr, ops[0], ops[1]);
	 I386FPURegisters.Pop (ops[1].reg1);
      ELSE
	 ASSERT(instr # -1); (* FALSE *)
      END;
      RETURN (ops[0]);
   END GenFPUBinaryExpr;


   PROCEDURE GenFPUComp (proc : PC.Context; at : Sym.Attribute;
			       own : Regs.Owner) : Op.Operand;
      VAR
	 ops : ARRAY 2 OF Op.Operand;
	 reg : Regs.Value;
	 cc : LONGINT;
	 left, right, tmp : Sym.Attribute;
	 big : SET;
	 opsy : INTEGER;
   BEGIN
      opsy := at.opsy;
      left := at.leftop; right := at.rightop;
      big := { Sym.binaryAt, Sym.callAt };
      IF (left.mode = Sym.binaryAt) OR ~(right.mode IN big) THEN
	 tmp := left;
	 left := right;
	 right := tmp;
	 CASE opsy OF
	 | Lex.grt: opsy := Lex.lst;
	 | Lex.leq: opsy := Lex.geq;
	 | Lex.lst: opsy := Lex.grt;
	 | Lex.geq: opsy := Lex.leq;
	 ELSE
	 END;
      END;
      ops[0] := GenExpr (proc, right, FALSE, Gen.StdRegs, own);
      IF Op.IsError (ops[0]) THEN
	 Regs.DestroyOwnerOnError (proc.regs, own);
	 RETURN ops[0];
      END;
      ops[0] := LoadFPUReg (proc, ops[0], right.type.form,
			    ops[0].memsz, own);
      ops[1] := GenExpr (proc, left, FALSE, Gen.StdRegs, own);
      IF Op.IsError (ops[1]) THEN
	 Regs.DestroyOwnerOnError (proc.regs, own);
	 RETURN ops[1];
      END;
      ops[1] := LoadFPUReg (proc, ops[1], left.type.form,
			    ops[1].memsz, own);
      IF opsy = Lex.leq THEN
         I386FPURegisters.Instr2 (proc.s, Pentium.FXCH, ops[1], ops[0]);
	 opsy := Lex.geq;
      END;
      I386FPURegisters.Instr2 (proc.s, Pentium.FUCOMPP, ops[1], ops[0]);
      I386FPURegisters.Pop (ops[1].reg1);
      I386FPURegisters.Pop (ops[0].reg1);
      Regs.CreateValue (reg, proc.regs, own, Regs.stdM);
      Regs.LoadReg (reg, { Gen.genax });
      I386FPURegisters.Instr1 (proc.s, Pentium.FNSTSW, Op.RegOp (reg, 2));
      CASE opsy OF
      | Lex.eql:
	 Emit.Instr2 (proc.s, Pentium.AND, Op.RegOp (reg, 2), Op.ImmInt (4500H));
	 Emit.Instr2 (proc.s, Pentium.CMP, Op.RegOp (reg, 2), Op.ImmInt (4000H));
	 cc := Pentium.JZ;
      | Lex.neq:
	 Emit.Instr2 (proc.s, Pentium.AND, Op.RegOp (reg, 2), Op.ImmInt (4500H));
	 Emit.Instr2 (proc.s, Pentium.CMP, Op.RegOp (reg, 2), Op.ImmInt (4000H));
	 cc := Pentium.JNZ;
      | Lex.lst:
	 Emit.Instr2 (proc.s, Pentium.AND, Op.RegOp (reg, 2), Op.ImmInt (4500H));
	 Emit.Instr2 (proc.s, Pentium.CMP, Op.RegOp (reg, 2), Op.ImmInt (0100H));
	 cc := Pentium.JZ;
      | Lex.geq:
	 Emit.Instr2 (proc.s, Pentium.TEST, Op.RegOp (reg, 2), Op.ImmInt (0500H));
	 cc := Pentium.JZ;
      | Lex.grt:
	 Emit.Instr2 (proc.s, Pentium.TEST, Op.RegOp (reg, 2), Op.ImmInt (4500H));
	 cc := Pentium.JZ;
      END;	 
      DEC (cc, Pentium.JCC);
      Regs.DestroyOwnedValue (reg, own);
      RETURN Op.CCOp (cc);
   END GenFPUComp;

   (* If byvalue is false we may return a reference (i.e.
    * an Op.memory Operand) for the expression. *)
   PROCEDURE GenExpr (proc : PC.Context; at : Sym.Attribute;
		      byvalue : BOOLEAN; possible : SET;
		      caller : Regs.Owner) : Op.Operand;
      VAR
         ok : BOOLEAN;
         var : VarDesc;
         tmp, lhs, rhs, result, ret, op, op2 : Op.Operand;
	 ops : ARRAY 3 OF Op.Operand;
	 ops2 : ARRAY 2 OF Op.Operand;
	 regarr : ARRAY 3 OF Regs.Value;
	 possibles : ARRAY 3 OF SET;
	 len1op, len2op : Op.Operand;
	 attach : CompilerObjects.Attachment;
	 own : Regs.Owner;
	 unsigned, needval : BOOLEAN;
	 range, signed : BOOLEAN;
	 type : Sym.Type;
	 reg, regax, regdx, tagreg, reg2, lenreg : Regs.Value;
	 rset : SET;
	 cc, len : LONGINT;
	 len1, len2 : BOOLEAN;
	 reloc : Relocations.RelocRequest;
	 beyond, lab, noerr : TrackedLabel;
	 cmploop, lab2, onemore, done, popf : FragmentedStreams.Label;
	 it : Iterators.Iterator;
	 tmpat : Sym.Attribute;
	 msize : LONGINT;
	 sym : ConstStrings.String;
	 attype : Sym.Type;
	 ref : Relocations.SymRef;
	 ch1, ch2 : CHAR;
	 carr : ARRAY 2 OF CHAR;

   BEGIN
      var := NIL;
      CompilerObjects.GetAttachment (at, attach);
      IF (attach # NIL) & (attach IS Sym32.Attribute) &
	 (attach(Sym32.Attribute).kind # Sym32.noConst) THEN
	 WITH attach : Sym32.Attribute DO
	    ret := ImmOpConst (proc, attach, byvalue);
	 END;
	 RETURN CheckOp(ret);
      END;
      own := Regs.GetOwner(proc.regs);
      CASE at.mode OF
      | Sym.constAt:
	 ret := GenExpr (proc, at.ident.constexpr, byvalue, possible, caller);
	 RETURN CheckOp (ret);
      | Sym.varAt:
	 ASSERT(~byvalue OR (possible # {}));
	 NEW (var);
	 var.mode := identM;
	 var.ident := at.ident;
	 Sym32.GetType (at, var.type);
	 ret := GenVar (proc, var, byvalue, possible, caller);
	 RETURN CheckOp(ret);
      | Sym.procAt:
         ASSERT((RealName (at.ident.module) # RealName (proc.module)) OR
                 (OA.ProcedureLevel (at.ident) = 3));
         ASSERT(~at.type.builtin);
	 op := GenSymVal (proc, Gen.StdRegs, RealName (at.ident.module),
	                  at.ident.name, own, FALSE);
	 IF Op.IsError (op) THEN
	    Regs.DestroyOwnerOnError (proc.regs, own);
	    RETURN op;
	 END;
	 ASSERT(Op.Loc (op) IN {Op.immediate, Op.immediateDyn});
	 RETURN CheckOp (op);
      | Sym.callAt:
	 IF at.proc.type.builtin THEN
	    ASSERT(possible # {});
	    ret := I386BuiltIns.GenBuiltIn (proc, at, possible, caller);
	    IF Op.IsError (ret) THEN
	       RETURN ret;
	    END;
	    ASSERT(ret # NIL);
	    IF byvalue & (Op.Loc (ret) = Op.memory) THEN
	       ret := GenValue (proc, ret, at.type.form, ret.memsz, possible,
	                        caller);
               SetMode (ret.reg1, at.type);
	    END;
            RETURN CheckOp(ret);
	 ELSE
	    reg := GenCall (proc, at, own);
	    ASSERT(reg # NIL);
	    IF at.proc.type.restype.form = Sym.real THEN
	       RETURN Op.FPUOp (reg);
	    END;
	    Regs.Chown (reg, caller);
	    msize := Sym32.GetSize (proc.module, at.proc.type.restype, proc.errors);
	    Regs.LoadReg (reg, Gen.LowByteRegs);
	    (* Note: The caller must store a LONGINT if an integer
	     * value is returned. *)
	    IF (msize < 4) & (at.proc.type.restype.form IN {Sym.integer, Sym.cardinal, Sym.address}) THEN
	       msize := 4;
	    END;
	    ret := Op.RegOp (reg, msize);
	    RETURN CheckOp(ret);
	 END;
      | Sym.refAt:
         (* This is ok! GenDesignator handles the dereference and returns
	  * the address of the memory area. *)
	 ret := GenDesignator (proc, at, possible, caller);
	 RETURN CheckOp(ret);
      | Sym.selectAt:
	 ASSERT(possible # {});
	 RETURN CheckOp(GenSelect (proc, at, byvalue, possible, caller));
      | Sym.indexAt:
	 ASSERT(possible # {});
	 RETURN CheckOp(GenIndex (proc, at, byvalue, possible, caller));
      | Sym.guardAt:
	 RETURN GenGuard (proc, at, byvalue, possible, caller);
      | Sym.unaryAt:
	 CASE at.opsy OF
	 | Lex.plus:
	    RETURN CheckOp (GenExpr (proc, at.rightop, byvalue, possible,
	                    caller));
         | Lex.minus:
	    op := GenExpr (proc, at.rightop, TRUE, possible, caller);
            IF Op.IsError (op) THEN
	       Regs.DestroyOwnerOnError (proc.regs, own);
	       RETURN op
	    END;
	    (* Constant Expressions are handled by Oberon32iAnalyzer and
	     * as the result of other expressions is an integer, a set
	     * or a real it should end up in a register *)
            ASSERT(Op.Loc(op) IN {Op.register, Op.fpuRegister});
	    CASE at.rightop.type.form OF
	    | Sym.real:
	       ASSERT(Op.Loc (op) = Op.fpuRegister);
	       I386FPURegisters.Instr1 (proc.s, Pentium.FCHS, op);
	    | Sym.integer, Sym.cardinal, Sym.address:
	       ops[0] := op;
	       Emit.Instr (proc.s, Pentium.NEG, 1, ops);
	    | Sym.set:
	       ops[0] := op;
	       Emit.Instr (proc.s, Pentium.NOT, 1, ops);
            (* ELSE ASSERT(FALSE) *)
	    END;
	    RETURN CheckOp(op);
         | Lex.tilde:
	    op := GenExpr (proc, at.rightop, TRUE, possible, caller);
            IF Op.IsError (op) THEN
	       Regs.DestroyOwnerOnError (proc.regs, own);
	       RETURN op
	    END;
	    ASSERT(Op.Loc(op) = Op.register);
	    ops[0] := op;
	    ops[1] := Op.ImmInt (1);
	    Emit.Instr (proc.s, Pentium.XOR, 2, ops);
	    RETURN CheckOp(op);
         (* ELSE ASSERT(FALSE) *)
	 END;
      | Sym.binaryAt:
	 IF (at.type.form = Sym.real) OR ((at.opsy = Lex.slash) & (at.type.form # Sym.set)) THEN
	    RETURN GenFPUBinaryExpr (proc, at, own);
	 END;
	 CASE at.opsy OF
	 | Lex.div, Lex.mod:
	    (* This function should be safe with regard to cardinal
	     * operands. Some things are worth noting, however:
	     *   - we choose a signed division if the left operand is signed.
	     *     This is ok as the right operand mustn't be negativ.
	     *   - negativ divisors should throw an arithmetic exception
	     *   - If the remainder is negativ we need fixups for the result:
	     *     * for div we must substract 1 from the result.
	     *     * for mod we must add the divisor to the result.
	     *)
	    rhs := GenExpr (proc, at.rightop, FALSE,
			    Gen.StdRegs - {Gen.genax, Gen.gendx}, own);
            IF Op.IsError (rhs) THEN
	       Regs.DestroyOwnerOnError (proc.regs, own);
	       RETURN rhs
	    END;
            ops[1] := rhs;
            signed := (at.leftop.type.form IN {Sym.integer, Sym.address});
	    IF Op.Loc(ops[1]) IN {Op.immediate, Op.immediateDyn} THEN
	       Regs.CreateValue (reg, proc.regs, own, Regs.stdM);
               Regs.LoadReg (reg, Gen.StdRegs - {Gen.genax, Gen.gendx}); 
	       ops[0] := Op.RegOp (reg, 4);
	       Emit.Instr (proc.s, Pentium.MOV, 2, ops);
	       ops[1] := ops[0];
               SetMode (reg, at.rightop.type);
            ELSIF ops[1].memsz # 4 THEN
	       reg := ops[1].reg1;
	       IF (reg = NIL) OR ~Regs.Traced (reg) THEN
	          reg := ops[1].reg2;
	       END;
	       IF (reg = NIL) OR ~Regs.Traced (reg) THEN
	          Regs.CreateValue (reg, proc.regs, own, Regs.stdM (* see below *));
		  Regs.LoadReg (reg, Gen.StdRegs);
	       END;
	       ops[0] := Op.RegOp (reg, 4);
	       Sym32.GetType (at.rightop, type);
	       IF type.form IN {Sym.integer, Sym.address} THEN
	          Emit.Instr (proc.s, Pentium.MOVSX, 2, ops);
               ELSE
	          Emit.Instr (proc.s, Pentium.MOVZX, 2, ops);
	       END;
	       IF ops[1].reg1 # reg THEN
	          Regs.DestroyOwnedValue (ops[1].reg1, own);
               END;
	       IF ops[1].reg2 # reg THEN
	          Regs.DestroyOwnedValue (ops[1].reg2, own);
               END;
	       ops[1] := ops[0];
               SetMode (reg, at.rightop.type);
	    END;
	    rhs := ops[1];
            ops2[0] := GenExpr (proc, at.leftop, TRUE, {Gen.genax}, own);
            IF Op.IsError (ops2[0]) THEN
	       Regs.DestroyOwnerOnError (proc.regs, own);
	       RETURN ops2[0]
	    END;
            regax := ops2[0].reg1;
	    IF Op.Loc(ops2[0]) # Op.register THEN
	       (* The operand is an integer and should hence by dynamic. *)
	       ASSERT(Op.Loc(ops2[0]) = Op.immediateDyn);
	       ASSERT(regax = NIL);
	       ops2[1] := ops2[0];
	       Regs.CreateValue (regax, proc.regs, own, Regs.stdM);
	       Regs.LoadReg (regax, {Gen.genax});
	       ops2[0] := Op.RegOp (regax, 4);
	       Emit.Instr (proc.s, Pentium.MOV, 2, ops2);
	    END;
	    ASSERT(regax # NIL);
	    Regs.AddConstraint (regax, {Gen.genax});
	    Regs.CreateValue (regdx, proc.regs, own, Regs.stdM);
	    Regs.LoadReg (regdx, {Gen.gendx});
	    Regs.AddConstraint (regdx, {Gen.gendx});
	    ops2[0] := Op.Reg2Op (regax, regdx, 4);
	    ops[0] := ops2[0];
	    Sym32.GetType (at.leftop, type);
	    IF type.form IN {Sym.integer, Sym.address} THEN
	       Emit.Instr (proc.s, Pentium.CDQ, 1, ops2);
            ELSE
	       ASSERT(type.form = Sym.cardinal);
	       ops2[0] := Op.RegOp (regdx, 4);
	       ops2[1] := Op.RegOp (regdx, 4);
               Emit.Instr (proc.s, Pentium.XOR, 2, ops2);
	    END;
	    IF signed THEN
	       Emit.Instr (proc.s, Pentium.IDIVIDE, 2, ops);
            ELSE
	       Emit.Instr (proc.s, Pentium.DIVIDE, 2, ops);
	    END;
	    IF at.opsy = Lex.div THEN
	       Regs.RemoveConstraint (regax);
	       Regs.RemoveConstraint (regdx);
	       IF signed THEN
		  (* Substract 1 from regax iff regdx is negativ. This is
		   * needed because Pentium.DIV rounds towards 0 but
		   * Oberon.DIV rounds towards -oo. *)
		  (* First set the carry flag iff regdx < 0 ... *)
		  ops[0] := Op.RegOp (regdx, 4);
		  ops[1] := ops[0];
		  Emit.Instr (proc.s, Pentium.ADD, 2, ops);
		  (* ... then substract zero with borrow. *)
		  ops[0] := Op.RegOp (regax, 4);
		  ops[1] := Op.ImmInt (0);
		  Emit.Instr (proc.s, Pentium.SBB, 2, ops);
	       END;
	       result := Op.RegOp (regax, 4);
	       Regs.Chown (regax, caller);
	       Regs.DestroyOwnedValue (regdx, own);
            ELSE (* Lex.mod *)
	       Regs.RemoveConstraint (regax);
	       Regs.RemoveConstraint (regdx);
	       IF signed THEN
		  ops[0] := Op.RegOp (regax, 4);
		  ops[1] := Op.RegOp (regdx, 4);
		  Emit.Instr (proc.s, Pentium.MOV, 2, ops);
		  ops[1] := Op.ImmIntFixed (31, 1);
		  Emit.Instr (proc.s, Pentium.SAR, 2, ops);
		  ops[1] := rhs;
		  Emit.Instr (proc.s, Pentium.AND, 2, ops);
		  ops[0] := Op.RegOp (regdx, 4);
		  ops[1] := Op.RegOp (regax, 4);
		  Emit.Instr (proc.s, Pentium.ADD, 2, ops);
               END;
	       result := Op.RegOp (regdx, 4);
	       Regs.Chown (regdx, caller);
	       Regs.DestroyOwnedValue (regax, own);
	    END;
	    Regs.DestroyOwnedValue (rhs.reg1, own);
	    Regs.DestroyOwnedValue (rhs.reg2, own);
	    Regs.LoadReg (result.reg1, possible);
            SetMode (result.reg1, at.type);
	    RETURN CheckOp(result);
	 | Lex.in:
	    ops[1] := GenExpr (proc, at.leftop, TRUE, Gen.StdRegs, own);
            IF Op.IsError (ops[1]) THEN
	       Regs.DestroyOwnerOnError (proc.regs, own);
	       RETURN ops[1]
	    END;
	    IF Op.Loc (ops[1]) IN {Op.immediate, Op.immediateDyn} THEN
	       ASSERT(ops[1].data.kind = Op.integerConst);
	       IF ops[1].data.intval >= 32 THEN
		  CompilerErrors.Raise (proc.errors, at.leftop.loc,
					"constant out of range [0..31]");
	       END;
	    ELSE
	       CreateLabel (beyond, "IN: out of range", at.leftop.loc, proc.s);
	       Emit.Instr2 (proc.s, Pentium.CMP, ops[1], Op.ImmInt (32));
	       Emit.JumpCC (proc.s, beyond, Pentium.JB-Pentium.JCC);
	       Regs.EnterLevel (proc.regs);
	       EmitErrors.RangeCheck (proc, at.leftop.loc, ops[1],
	                              Op.ImmInt (31));
	       Regs.LeaveLevel (proc.regs);
	       Regs.DoneLevel (proc.regs);
	       FragmentedStreams.AttachLabel (proc.s, beyond);
	    END;
	    ops[0] := GenExpr (proc, at.rightop, FALSE, Gen.StdRegs, own);
            IF Op.IsError (ops[0]) THEN
	       Regs.DestroyOwnerOnError (proc.regs, own);
	       RETURN ops[0]
	    END;
	    IF Op.Loc(ops[0]) IN {Op.immediate, Op.immediateDyn} THEN
	       ops2[1] := ops[0];
	       Regs.CreateValue (reg, proc.regs, own, Regs.stdM);
	       Regs.LoadReg (reg, Gen.StdRegs);
	       ops2[0] := Op.RegOp (reg, 4 (* SET *));
	       Emit.Instr (proc.s, Pentium.MOV, 2, ops2);
	       ops[0] := ops2[0];
	    END;
	    Emit.Instr (proc.s, Pentium.BT, 2, ops);
	    Regs.DestroyOwnedValue (ops[0].reg1, own);
	    Regs.DestroyOwnedValue (ops[0].reg2, own);
	    Regs.DestroyOwnedValue (ops[1].reg1, own);
	    Regs.DestroyOwnedValue (ops[1].reg2, own);
	    (* Regs.DestroyValue is not allowed to trash flags *)
	    RETURN CheckOp(Op.CCOp (Pentium.JC - Pentium.JCC));
	 (* | Lex.is: See GenBool *)
         (* | Lex.mod: See Lex.div *)
	 (* | Lex.or: See GenBool *)
	 | Lex.plus:
	    IF (at.leftop.type.form = Sym.address) OR
	       (at.rightop.type.form = Sym.address) THEN
	       ASSERT(at.leftop.type.form IN {Sym.address, Sym.integer, Sym.cardinal});
	       ASSERT(at.rightop.type.form IN {Sym.address, Sym.integer, Sym.cardinal});
	    ELSE
	       ASSERT(at.leftop.type.form = at.rightop.type.form);
	       ASSERT(at.leftop.type.form IN {Sym.integer, Sym.cardinal, Sym.set});
	    END;
	    ops[0] := GenExpr (proc, at.leftop, TRUE, possible, own);
            IF Op.IsError (ops[0]) THEN
	       Regs.DestroyOwnerOnError (proc.regs, own);
	       RETURN ops[0]
	    END;
	    needval := TRUE;
	    rset := possible;
            IF  Op.Loc(ops[0]) = Op.register THEN
	       needval := FALSE;
	       rset := Gen.StdRegs;
	    END;
	    ops[1] := GenExpr (proc, at.rightop, needval, rset, own);
            IF Op.IsError (ops[1]) THEN
	       Regs.DestroyOwnerOnError (proc.regs, own);
	       RETURN ops[1]
	    END;
            IF (Op.Loc(ops[1]) = Op.memory) & (ops[1].memsz # 4) THEN
	       reg := ops[1].reg1;
	       IF (reg = NIL) OR ~Regs.Traced (reg) THEN
	           reg := ops[1].reg2;
	       END;
	       IF (reg = NIL) OR ~Regs.Traced (reg) THEN
		   Regs.CreateValue (reg, proc.regs, own, Regs.stdM);
		   Regs.LoadReg (reg, Gen.StdRegs);
	       END;
               ops2[0] := Op.RegOp (reg, 4);
	       ops2[1] := ops[1];
	       IF at.rightop.type.form IN {Sym.integer, Sym.address} THEN
	          Emit.Instr (proc.s, Pentium.MOVSX, 2, ops2);
               ELSE
		  ASSERT(at.rightop.type.form = Sym.cardinal);
	          Emit.Instr (proc.s, Pentium.MOVZX, 2, ops2);
	       END;
	       IF ops[1].reg1 # reg THEN
		  Regs.DestroyOwnedValue (ops[1].reg1, own);
	       END;
	       IF ops[1].reg2 # reg THEN
		  Regs.DestroyOwnedValue (ops[1].reg2, own);
	       END;
	       ops[1] := ops2[0];
            END;
	    IF Op.Loc(ops[0]) IN {Op.immediate, Op.immediateDyn} THEN
	       op     := ops[0];
	       ops[0] := ops[1];
	       ops[1] := op;
	    END;
	    ASSERT(Op.Loc(ops[0]) = Op.register);
	    IF at.leftop.type.form IN {Sym.address, Sym.integer, Sym.cardinal} THEN
	       Emit.Instr (proc.s, Pentium.ADD, 2, ops);
            ELSE (* Sym.set *)
	       ASSERT(at.leftop.type.form = Sym.set);
	       Emit.Instr (proc.s, Pentium.ORI, 2, ops);
	    END;
	    ChownOp (ops[0], caller);
	    Regs.DestroyOwnedValue (ops[1].reg1, own);
	    Regs.DestroyOwnedValue (ops[1].reg2, own);
            SetMode (ops[0].reg1, at.type);
	    RETURN CheckOp(ops[0]);
	 | Lex.minus:
	    IF (at.leftop.type.form = Sym.address) OR
	       (at.rightop.type.form = Sym.address) THEN
	       ASSERT(at.leftop.type.form IN {Sym.address, Sym.cardinal, Sym.integer});
	       ASSERT(at.rightop.type.form IN {Sym.address, Sym.cardinal, Sym.integer});
	    ELSE
	       ASSERT(at.leftop.type.form = at.rightop.type.form);
	       ASSERT(at.leftop.type.form IN {Sym.integer, Sym.cardinal, Sym.set});
	    END;
	    IF at.leftop.type.form IN {Sym.integer, Sym.cardinal, Sym.address} THEN
	       ops[0] := GenExpr (proc, at.leftop, TRUE, possible, own);
               IF Op.IsError (ops[0]) THEN
	          Regs.DestroyOwnerOnError (proc.regs, own);
		  RETURN ops[0]
	       END;
	       IF Op.Loc(ops[0]) IN {Op.immediate, Op.immediateDyn} THEN
		  ops[1] := ops[0];
	          ops[0] := GenExpr (proc, at.rightop, TRUE, possible, own);
                  IF Op.IsError (ops[0]) THEN
	             Regs.DestroyOwnerOnError (proc.regs, own);
		     RETURN ops[0]
		  END;
                  ASSERT(Op.Loc(ops[0]) = Op.register);
                  Emit.Instr (proc.s, Pentium.NEG, 1, ops);
		  Emit.Instr (proc.s, Pentium.ADD, 2, ops);
		  Regs.DestroyOwnedValue (ops[1].reg1, own);
		  Regs.DestroyOwnedValue (ops[1].reg2, own);
               ELSE
		  ops[1] := GenExpr (proc, at.rightop, FALSE, Gen.StdRegs, own);
                  IF Op.IsError (ops[1]) THEN
	             Regs.DestroyOwnerOnError (proc.regs, own);
		     RETURN ops[1]
		  END;
                  IF (Op.Loc (ops[1]) = Op.memory) &
		     (ops[1].memsz # 4) THEN
		     reg := ops[1].reg1;
		     IF (reg = NIL) OR ~Regs.Traced (reg) THEN
			Regs.CreateValue (reg, proc.regs, own, Regs.stdM);
			Regs.LoadReg (reg, Gen.StdRegs);
		     END;
		     Emit.Instr2 (proc.s, Pentium.MOVSX, Op.RegOp (reg, 4),
		                  ops[1]);
		     IF ops[1].reg1 # reg THEN
		        Regs.DestroyOwnedValue (ops[1].reg1, own);
		     END;
		     IF ops[1].reg2 # reg THEN
		        Regs.DestroyOwnedValue (ops[1].reg2, own);
		     END;
		     ops[1] := Op.RegOp (reg, 4);
		  ELSIF Op.Loc (ops[1]) = Op.register THEN
		     ops[1].memsz := 4;
		  END;
                  Emit.Instr (proc.s, Pentium.SUB, 2, ops);
		  Regs.DestroyOwnedValue (ops[1].reg1, own);
		  Regs.DestroyOwnedValue (ops[1].reg2, own);
	       END;
	       ChownOp (ops[0], caller);
               SetMode (ops[0].reg1, at.type);
	       RETURN CheckOp(ops[0]);
            ELSE (* Sym.set *)
               ASSERT(at.leftop.type.form = Sym.set);
	       ops[0] := GenExpr (proc, at.rightop, TRUE, possible, own);
               IF Op.IsError (ops[0]) THEN
	          Regs.DestroyOwnerOnError (proc.regs, own);
		  RETURN ops[0]
	       END;
	       needval := Op.Loc(ops[0]) IN {Op.immediate, Op.immediateDyn};
	       rset := Gen.StdRegs;
	       IF needval THEN
		  rset := possible;
	       END;
	       ops[1] := GenExpr (proc, at.leftop, needval, rset, own);
               IF Op.IsError (ops[1]) THEN
	          Regs.DestroyOwnerOnError (proc.regs, own);
		  RETURN ops[1]
	       END;
	       IF Op.Loc(ops[0]) IN {Op.immediate, Op.immediateDyn} THEN
		  ASSERT(ops[0].data.kind = Op.setConst);
		  op := ops[0];
		  ops[0] := ops[1];
		  ops[1] := op;
		  ops[1].data.setval := -ops[1].data.setval;
		  Emit.Instr (proc.s, Pentium.AND, 2, ops);
               ELSE
		  ASSERT(Op.Loc(ops[0]) = Op.register);
		  Emit.Instr (proc.s, Pentium.NOT, 1, ops);
		  Emit.Instr (proc.s, Pentium.AND, 2, ops);
		  Regs.DestroyOwnedValue (ops[1].reg1, own);
		  Regs.DestroyOwnedValue (ops[1].reg2, own);
	       END;
	       ChownOp (ops[0], caller);
               SetMode (ops[0].reg1, at.type);
	       RETURN CheckOp(ops[0]);
	    END;
	 | Lex.times:
	   CASE at.leftop.type.form OF
	   | Sym.integer, Sym.cardinal, Sym.address:
	      ops[0] := GenExpr (proc, at.leftop, TRUE, possible, own);
              IF Op.IsError (ops[0]) THEN
	         Regs.DestroyOwnerOnError (proc.regs, own);
		 RETURN ops[0]
	      END;
              IF Op.Loc(ops[0]) IN {Op.immediate, Op.immediateDyn} THEN
		 ops[2] := ops[0];
		 ops[0] := GenExpr (proc, at.rightop, TRUE, possible, own);
                 IF Op.IsError (ops[0]) THEN
	            Regs.DestroyOwnerOnError (proc.regs, own);
		    RETURN ops[0]
		 END;
		 ops[1] := ops[0];
                 Emit.Instr (proc.s, Pentium.IMUL, 3, ops);
	      ELSE
		 ASSERT(Op.Loc(ops[0]) = Op.register);
                 ops[1] := GenExpr (proc, at.rightop, FALSE, Gen.StdRegs, own);
                 IF Op.IsError (ops[1]) THEN
	            Regs.DestroyOwnerOnError (proc.regs, own);
		    RETURN ops[1]
		 END;
		 IF (Op.Loc (ops[1]) = Op.memory) & (ops[1].memsz < 4) THEN
		    ops[1] := GenValue (proc, ops[1], at.rightop.type.form,
		                        ops[1].memsz, Gen.StdRegs, own);
                    SetMode (ops[1].reg1, at.rightop.type);
		 END;
		 IF Op.Loc (ops[1]) IN {Op.immediate, Op.immediateDyn} THEN
		    ops[2] := ops[1]; ops[1] := ops[0];
		    Emit.Instr (proc.s, Pentium.IMUL, 3, ops);
		    Regs.DestroyOwnedValue (ops[2].reg1, own);
		    Regs.DestroyOwnedValue (ops[2].reg2, own);
		 ELSE
		    Emit.Instr (proc.s, Pentium.IMUL, 2, ops);
		    Regs.DestroyOwnedValue (ops[1].reg1, own);
		    Regs.DestroyOwnedValue (ops[1].reg2, own);
		 END;
	      END;
	      ChownOp (ops[0], caller);
              SetMode (ops[0].reg1, at.type);
	      RETURN CheckOp(ops[0]);
	   | Sym.set:
	      ops[0] := GenExpr (proc, at.leftop, TRUE, possible, own);
              IF Op.IsError (ops[0]) THEN
	         Regs.DestroyOwnerOnError (proc.regs, own);
		 RETURN ops[0]
	      END;
	      needval := TRUE;
	      rset := possible;
	      IF Op.Loc(ops[0]) = Op.register THEN
		 needval := FALSE;
		 rset := Gen.StdRegs;
	      END;
	      ops[1] := GenExpr (proc, at.rightop, needval, rset, own);
              IF Op.IsError (ops[1]) THEN
	         Regs.DestroyOwnerOnError (proc.regs, own);
		 RETURN ops[1]
	      END;
	      IF Op.Loc(ops[0]) IN {Op.immediate, Op.immediateDyn} THEN
		 op     := ops[0];
		 ops[0] := ops[1];
		 ops[1] := op;
	      END;
	      ASSERT(Op.Loc(ops[0]) = Op.register);
	      Emit.Instr (proc.s, Pentium.AND, 2, ops);
	      Regs.DestroyOwnedValue (ops[1].reg1, own);
	      Regs.DestroyOwnedValue (ops[1].reg2, own);
	      ChownOp (ops[0], caller);
              SetMode (ops[0].reg1, at.type);
	      RETURN CheckOp(ops[0]);
	   END;
	 | Lex.slash:
	   ASSERT(at.leftop.type.form = Sym.set);
	   ASSERT(at.rightop.type.form = Sym.set);
	   ops[0] := GenExpr (proc, at.leftop, TRUE, possible, own);
           IF Op.IsError (ops[0]) THEN
	      Regs.DestroyOwnerOnError (proc.regs, own);
	      RETURN ops[0]
	   END;
           needval := FALSE;
	   rset := Gen.StdRegs;
	   IF Op.Loc(ops[0]) IN {Op.immediate, Op.immediateDyn} THEN
	      needval := TRUE;
	      rset := possible;
	   END;
           ops[1] := GenExpr (proc, at.rightop, needval, rset, own);
           IF Op.IsError (ops[1]) THEN
	      Regs.DestroyOwnerOnError (proc.regs, own);
	      RETURN ops[1]
	   END;
           IF needval THEN
	      op := ops[1];
	      ops[1] := ops[0];
	      ops[0] := op;
	   END;
	   ASSERT(Op.Loc (ops[0]) = Op.register);
           Emit.Instr (proc.s, Pentium.XOR, 2, ops);
	   ChownOp (ops[0], caller);
	   Regs.DestroyOwnedValue (ops[1].reg1, own);
	   Regs.DestroyOwnedValue (ops[1].reg2, own);
           SetMode (ops[0].reg1, at.type);
	   RETURN CheckOp(ops[0]);
	 (* | Lex.ampersand: See GenBool *)
	 | Lex.comma:
	    Iterators.Create (it, IterateCommaList, at, 0);
	    lhs := NIL;
	    WHILE Iterators.Get (it, tmpat) DO
	       range := (tmpat.mode = Sym.binaryAt) & (tmpat.opsy = Lex.range);
	       rset := Gen.StdRegs;
	       needval := FALSE;
	       IF ~range THEN
		  rset := {Gen.gencx};
		  needval := TRUE;
	       END;
	       rhs := GenExpr (proc, tmpat, needval, rset, own);
               IF Op.IsError (rhs) THEN
	          Regs.DestroyOwnerOnError (proc.regs, own);
		  RETURN rhs
	       END;
               IF needval & (rhs.reg1 # NIL) THEN
		  Regs.AddConstraint (rhs.reg1, {Gen.gencx});
	       END;
	       IF ~range THEN
		  IF Op.Loc (rhs) IN {Op.immediate, Op.immediateDyn} THEN
		     ASSERT(rhs.data.kind = Op.integerConst);
		     IF (rhs.data.intval < 0) OR (rhs.data.intval > 31) THEN
			CompilerErrors.Raise (proc.errors, FixupLoc (tmpat),
					      "constant out of range [0..31]");
                        Regs.DestroyOwnerOnError (proc.regs, own);
			RETURN Op.Error ();
		     END;
		     rhs.immsz := 1;
		  ELSE
		     CreateLabel (noerr, "GenExpr: noerr1", at.loc, proc.s);
		     Emit.Instr2 (proc.s, Pentium.CMP, rhs, Op.ImmInt (31));
		     Emit.JumpCC (proc.s, noerr, Pentium.JNA-Pentium.JCC);
		     Regs.EnterLevel (proc.regs);
		     EmitErrors.RangeCheck (proc, at.loc, rhs, Op.ImmInt (31));
		     Regs.LeaveLevel (proc.regs);
		     Regs.DoneLevel (proc.regs);
		     FragmentedStreams.AttachLabel (proc.s, noerr);
		     rhs.memsz := 1;
		  END;
	       END;
	       IF lhs = NIL THEN
		  (* Default behaviour: rhs is s set *)
		  lhs := rhs;
                  IF (Op.Loc (rhs) IN {Op.immediate, Op.immediateDyn}) & 
		     (rhs.data.kind = Op.integerConst) THEN
		     (* rhs is immediate but not a set *)
		     lhs := Op.ImmSet ({rhs.data.intval});
                  ELSIF ~(Op.Loc (rhs) IN {Op.immediate, Op.immediateDyn}) &
		     ~range THEN
		     (* rhs is a non constant integer *)
		     Regs.CreateValue (reg, proc.regs, own, Regs.stdM);
		     Regs.LoadReg (reg, Gen.StdRegs);
		     ops[0] := Op.RegOp (reg, 4 (* SET *));
		     ops[1] := ops[0];
		     Emit.Instr (proc.s, Pentium.XOR, 2, ops);
		     Emit.Instr (proc.s, Pentium.INCR, 1, ops);
		     ops[1] := rhs;
		     Emit.Instr (proc.s, Pentium.SHL, 2, ops);
		     Regs.DestroyOwnedValue (rhs.reg1, own);
		     Regs.DestroyOwnedValue (rhs.reg2, own);
		     lhs := ops[0];
		  END;
	       ELSE
	          IF (Op.Loc (lhs) IN {Op.immediate, Op.immediateDyn}) &
		     ~(Op.Loc (rhs) IN {Op.immediate, Op.immediateDyn}) THEN
                     Regs.CreateValue (reg, proc.regs, own, Regs.stdM);
		     Regs.LoadReg (reg, Gen.StdRegs);
		     ops[0] := Op.RegOp (reg, 4 (* SET *));
		     ops[1] := lhs;
		     Emit.Instr (proc.s, Pentium.MOV, 2, ops);
		     lhs := ops[0];
                  ELSE
		     ASSERT(Op.Loc (lhs) = Op.register);
                  END;
		  IF Op.Loc (lhs) IN {Op.immediate, Op.immediateDyn} THEN
		     ASSERT(Op.Loc (rhs) IN {Op.immediate, Op.immediateDyn});
		     ASSERT(lhs.data.kind = Op.setConst);
		     CASE rhs.data.kind OF
		     | Op.integerConst:
			ASSERT(~range);
			INCL (lhs.data.setval, rhs.data.intval);
		     | Op.setConst:
			lhs.data.setval := lhs.data.setval + rhs.data.setval;
		     END;
		  ELSE
		     ASSERT(Op.Loc (lhs) = Op.register);
		     IF ~range THEN
			(* rhs is a non constant integer *)
			Regs.CreateValue (reg, proc.regs, own, Regs.stdM);
			Regs.LoadReg (reg, Gen.StdRegs);
			ops[0] := Op.RegOp (reg, 4 (* SET *));
			ops[1] := ops[0];
			Emit.Instr (proc.s, Pentium.XOR, 2, ops);
			Emit.Instr (proc.s, Pentium.INCR, 1, ops);
			ops[1] := rhs;
			Emit.Instr (proc.s, Pentium.SHL, 2, ops);
			ops[1] := ops[0];
			ops[0] := lhs;
			Emit.Instr (proc.s, Pentium.ORI, 2, ops);
			Regs.DestroyOwnedValue (reg, own);
		     ELSE
			ops[0] := lhs;
			ops[1] := rhs;
			Emit.Instr (proc.s, Pentium.ORI, 2, ops);
		     END;
		  END;
		  (* NOTE: We can't destroy these values if we assigned
		   * rhs to lhs, i.e we have to do this here and not
		   * after the END. *)
	          Regs.DestroyOwnedValue (rhs.reg1, own);
                  Regs.DestroyOwnedValue (rhs.reg2, own);
	       END;
	    END;
	    it := NIL;
	    ASSERT(lhs # NIL);
	    ChownOp (lhs, caller);
            IF Op.Loc (lhs) = Op.register THEN
               SetMode (lhs.reg1, at.type);
            END;
	    RETURN CheckOp(lhs);
	 | Lex.eql, Lex.neq, Lex.lst, Lex.grt, Lex.leq, Lex.geq:
	    (* Boolean comparisons must be handled by GenBool. *)
	    ASSERT(at.leftop.type.form # Sym.boolean);
	    ASSERT(at.rightop.type.form # Sym.boolean);
	    unsigned := FALSE;
	    IF (at.leftop.type.form = Sym.array) OR
	       (at.rightop.type.form = Sym.array) THEN
	       unsigned := TRUE;
	       ops[0] := GenExpr (proc, at.leftop, FALSE, {Gen.gensi}, own);
               IF Op.IsError (ops[0]) THEN
	          Regs.DestroyOwnerOnError (proc.regs, own);
		  RETURN ops[0]
	       END;
	       ops[1] := GenExpr (proc, at.rightop, FALSE, {Gen.gendi}, own);
               IF Op.IsError (ops[1]) THEN
	          Regs.DestroyOwnerOnError (proc.regs, own);
		  RETURN ops[1]
	       END;
               needval := FALSE; (* TRUE if we exchanged the Operands. *)
	       (* The only way that any of the Operands can be immediate
		* is a character constant given as a string of length one. *)
	       IF (~(Op.Loc (ops[1]) IN {Op.immediate, Op.immediateDyn}) &
	          ~(Op.Loc (ops[0]) IN {Op.immediate, Op.immediateDyn})) OR
		  at.leftop.type.dyn OR at.rightop.type.dyn
	       THEN 
		  len1 := FALSE; len2 := FALSE;
		  Sym32.GetType (at.leftop, attype);
		  IF attype.dyn THEN
		     len1op := LoadArrayLen (proc, at.leftop, Gen.StdRegs, own);
		  ELSIF Op.Loc (ops[0]) IN {Op.immediate, Op.immediateDyn} THEN
		     IF ops[0].data.charval = CHR(0) THEN
			len1op := Op.ImmInt (1);
			ops[0] := Op.MemOp0 (1, Emit.StringArray (proc.rodata, "", len), 4);
		     ELSE
			len1op := Op.ImmInt (2);
			carr[0] := ops[0].data.charval; carr[1] := 0X;
			ops[0] := Op.MemOp0 (1, Emit.StringArray (proc.rodata, carr, len), 4);
		     END;
		     NEW(ref);
		     ref.modname := RealName (proc.module);
		     ConstStrings.Create (ref.symname, "__rodata");
		     Relocations.Create (reloc, proc.s, Relocations.addSym, ref);
		     Op.RelocOpen (ops[0], reloc);
		     len1 := TRUE;
		  ELSE
		     len1op := GenExpr (proc, attype.length, TRUE, {}, own);
		     ASSERT(Op.Loc (len1op) IN {Op.immediate, Op.immediateDyn});
		     ASSERT(len1op.data.kind = Op.integerConst);
		     len1 := TRUE;
		  END;
		  IF Op.IsError (len1op) THEN
		     Regs.DestroyOwnerOnError (proc.regs, own);
		     RETURN len1op
		  END;
		  Sym32.GetType (at.rightop, attype);
		  IF attype.dyn THEN
		     len2op := LoadArrayLen (proc, at.rightop, Gen.StdRegs, own);
		  ELSIF Op.Loc (ops[1]) IN {Op.immediate, Op.immediateDyn} THEN
		     IF ops[1].data.charval = CHR(0) THEN
			len2op := Op.ImmInt (1);
			ops[1] := Op.MemOp0 (1, Emit.StringArray (proc.rodata, "", len), 4);
		     ELSE
			len2op := Op.ImmInt (2);
			carr[0] := ops[1].data.charval; carr[1] := 0X;
			ops[1] := Op.MemOp0 (1, Emit.StringArray (proc.rodata, carr, len), 4);
		     END;
		     NEW(ref);
		     ref.modname := RealName (proc.module);
		     ConstStrings.Create (ref.symname, "__rodata");
		     Relocations.Create (reloc, proc.s, Relocations.addSym, ref);
		     Op.RelocOpen (ops[1], reloc);
		     len2 := TRUE;
		  ELSE
		     len2op := GenExpr (proc, attype.length, TRUE, {}, own);
		     ASSERT(Op.Loc (len2op) IN {Op.immediate, Op.immediateDyn});
		     ASSERT(len2op.data.kind = Op.integerConst);
		     len2 := TRUE;
		  END;
		  IF Op.IsError (len2op) THEN
		     Regs.DestroyOwnerOnError (proc.regs, own);
		     RETURN len2op
		  END;
		  ASSERT(len1 = (Op.Loc (len1op) IN {Op.immediate, Op.immediateDyn}));
		  ASSERT(len2 = (Op.Loc (len2op) IN {Op.immediate, Op.immediateDyn}));
		  IF len1 & len2 THEN
		     len := len1op.data.intval;
		     IF len2op.data.intval < len THEN
			len := len2op.data.intval;
		     END;
		     Regs.CreateValue (lenreg, proc.regs, own, Regs.stdM);
		     Regs.LoadReg (lenreg, Gen.StdRegs);
		     op := Op.RegOp (lenreg, 4);
		     Emit.Instr2 (proc.s, Pentium.MOV, op, Op.ImmInt (len));
		  ELSE
		     Regs.CreateValue (lenreg, proc.regs, own, Regs.stdM);
		     Regs.LoadReg (lenreg, Gen.StdRegs);
		     op := Op.RegOp (lenreg, 4);
		     Emit.Instr2 (proc.s, Pentium.MOV, op, len1op);
		     FragmentedStreams.CreateLabel (beyond);
		     Emit.Instr2 (proc.s, Pentium.CMP, op, len2op);
		     Emit.Instr0 (proc.s, Pentium.PUSHF);
		     Emit.JumpCC (proc.s, beyond, Pentium.JB-Pentium.JCC);
		     Regs.EnterLevel (proc.regs);
		     Emit.Instr2 (proc.s, Pentium.MOV, op, len2op);
		     Regs.LeaveLevel (proc.regs);
		     Regs.DoneLevel (proc.regs);
		     FragmentedStreams.AttachLabel (proc.s, beyond);
		  END;
		  Regs.DestroyOwnedValue (len1op.reg1, own);
		  Regs.DestroyOwnedValue (len1op.reg2, own);
		  Regs.DestroyOwnedValue (len2op.reg1, own);
		  Regs.DestroyOwnedValue (len2op.reg2, own);
		  ops[0] := Lea (proc, ops[0], {Gen.gensi}, own);
		  ops[1] := Lea (proc, ops[1], {Gen.gendi}, own);
		  regarr[0] := ops[0].reg1;
		  possibles[0] := Regs.GetConstraint (ops[0].reg1);
		  regarr[1] := ops[1].reg1;
		  possibles[1] := Regs.GetConstraint (ops[1].reg1);
		  regarr[2] := op.reg1;
		  possibles[2] := Regs.GetConstraint (op.reg1);
		  (* This will protect us until we reach the done label. *)
		  ok := Regs.PrepareInstruction (3, regarr, possibles);
		  ASSERT(ok);
		  ops[0].memsz := 1;
		  ops[1].memsz := 1;
                  FragmentedStreams.CreateLabel (cmploop);
                  FragmentedStreams.AttachLabel (proc.s, cmploop);
		  FragmentedStreams.CreateLabel (onemore);
		  FragmentedStreams.CreateLabel (done);
		  FragmentedStreams.CreateLabel (popf);
		  Emit.Instr2 (proc.s, Pentium.CMP, ops[0], Op.ImmInt (0));
		  Emit.JumpCC (proc.s, onemore, Pentium.JE-Pentium.JCC);
		  Emit.Instr2 (proc.s, Pentium.CMP, ops[1], Op.ImmInt (0));
		  Emit.JumpCC (proc.s, onemore, Pentium.JE-Pentium.JCC);
		  (* NOTE: CMPS has its operands reversed compared to the
		     normal intel convention.  *)
		  Emit.Instr2 (proc.s, Pentium.CMPS, ops[0], ops[1]);
		  Emit.JumpCC (proc.s, popf, Pentium.JNE-Pentium.JCC);
		  Emit.Instr1 (proc.s, Pentium.DECR, op);
		  Emit.JumpCC (proc.s, cmploop, Pentium.JNZ-Pentium.JCC);
		  (* If we end up here we reached the maximum length. *)
                  IF ~len1 OR ~len2 OR
		              (len1op.data.intval # len2op.data.intval) THEN
		     (* We must compare the next byte of the longer string
		      * with zero. *)
		     IF len1 & len2 THEN
			IF (len1op.data.intval > len2op.data.intval) THEN
			   Emit.Instr2 (proc.s, Pentium.CMP, ops[0],
			                Op.ImmIntFixed (0, 1));
			ELSE (* len1 < len2 *)
			   ASSERT(unsigned);
			   Emit.Instr2 (proc.s, Pentium.CMP, ops[1],
			                Op.ImmIntFixed (0, 1));
			   FragmentedStreams.CreateLabel (lab);
			   Emit.JumpCC (proc.s, lab, Pentium.JE-Pentium.JCC);
			   Emit.Instr0 (proc.s, Pentium.CMC);
			   FragmentedStreams.AttachLabel (proc.s, lab);
			END;
		     ELSE
		        (* Note: This is subtle:  The string table always
			 * starts with an empty string. We load its address
			 * into either edi or esi and do a last CMPS. *)
		        Emit.Instr0 (proc.s, Pentium.POPF);
			Emit.JumpCC (proc.s, done, Pentium.JE-Pentium.JCC);
			FragmentedStreams.CreateLabel (lab);
			FragmentedStreams.CreateLabel (lab2);
			Emit.JumpCC (proc.s, lab, Pentium.JB-Pentium.JCC);
			ConstStrings.Create (sym, "__rodata");
			Emit.Instr2 (proc.s, Pentium.MOV,
			    Op.RegOp (ops[1].reg1, 4),
			    GenSymVal (proc, {}, NIL, sym, own, FALSE));
			Emit.Jump (proc.s, lab2);
			FragmentedStreams.AttachLabel (proc.s, lab);
			Emit.Instr2 (proc.s, Pentium.MOV,
			       Op.RegOp (ops[0].reg1, 4),
			       GenSymVal (proc, {}, NIL, sym, own, FALSE));
			FragmentedStreams.AttachLabel (proc.s, lab2);
			Emit.Instr2 (proc.s, Pentium.CMPS, ops[0], ops[1]);
		     END;
		     Emit.Jump (proc.s, done);
		  ELSE
		     (* Both array lengths are statically known and equal.
		      * Furthermore the zero flag is set (from the wrong
		      * comparison but who carse) and there is no need
		      * to pop.
		      *)
		     Emit.Jump (proc.s, done);
                  END;
		  FragmentedStreams.AttachLabel (proc.s, onemore);
		  Emit.Instr2 (proc.s, Pentium.CMPS, ops[0], ops[1]);
		  FragmentedStreams.AttachLabel (proc.s, popf);
		  IF ~len1 OR ~len2 THEN
		     Emit.Instr1 (proc.s, Pentium.POP, op);
		  END;
		  FragmentedStreams.AttachLabel (proc.s, done);
		  Regs.DestroyOwnedValue (ops[0].reg1, own);
		  Regs.DestroyOwnedValue (ops[1].reg1, own);
		  Regs.DestroyOwnedValue (op.reg1, own);
	       ELSE
		  (* Comparison with character constant. *)
		  (* We have at least one character Constant, the other
		   * Operand can be either an array of a character. *)
		  IF Op.Loc (ops[0]) IN {Op.immediate, Op.immediateDyn} THEN
		     needval := TRUE;
		     tmp := ops[0];
		     ops[0] := ops[1];
		     ops[1] := tmp;
		     IF at.rightop.type.form = Sym.char THEN
		        len := 1;
		     ELSE
			ASSERT(at.rightop.type.length # NIL);
			op := GenExpr (proc, at.rightop.type.length,
			               TRUE, {}, -1);
			len := op.data.intval;
		     END;
		  ELSE
		     IF at.leftop.type.form = Sym.char THEN
		        len := 1;
		     ELSE
			ASSERT(at.leftop.type.length # NIL);
			op := GenExpr (proc, at.leftop.type.length, TRUE,
			               {}, -1);
			len := op.data.intval;
		     END;
		  END;
		  IF Op.Loc (ops[0]) IN {Op.immediate, Op.immediateDyn} THEN
		     ASSERT(Op.Loc(ops[0]) IN {Op.immediate, Op.immediateDyn});
		     ASSERT(ops[0].data.kind = Op.charConst);
		     ASSERT(needval);
		     ch2 := ops[0].data.charval;
		     ch1 := ops[1].data.charval;
		     CASE at.opsy OF
		     | Lex.eql:
			RETURN (Op.ImmBool (ch1 = ch2));
		     | Lex.neq:
			RETURN (Op.ImmBool (ch1 # ch2));
		     | Lex.leq:
			RETURN (Op.ImmBool (ch1 <= ch2));
		     | Lex.geq:
			RETURN (Op.ImmBool (ch1 >= ch2));
		     | Lex.lst:
			RETURN (Op.ImmBool (ch1 < ch2));
		     | Lex.grt:
			RETURN (Op.ImmBool (ch1 > ch2));
		     END;
		  END;
		  ops[0].memsz := 1;
		  Emit.Instr (proc.s, Pentium.CMP, 2, ops);
		  IF (op # NIL) & (len >= 2) & (ops[1].data.charval # 0X) THEN
		     INC(ops[0].disp);
		     CreateLabel (beyond, "StringCompare: 2nd char", at.loc, proc.s);
		     Emit.JumpCC (proc.s, beyond, Pentium.JNE-Pentium.JCC);
		     ops[1] := Op.ImmIntFixed (0, 1);
		     Emit.Instr (proc.s, Pentium.CMP, 2, ops);
		     FragmentedStreams.AttachLabel (proc.s, beyond);
                  END;
		  Regs.DestroyOwnedValue (ops[0].reg1, own);
		  Regs.DestroyOwnedValue (ops[0].reg2, own);
	       END;
	    ELSIF (at.leftop.type.form IN (Sym.basic + {Sym.pointer, Sym.proceduretype})) THEN
	       ASSERT(at.rightop.type.form IN (Sym.basic + {Sym.pointer, Sym.proceduretype}));
	       ASSERT(~(at.leftop.type.form IN {Sym.pointer, Sym.proceduretype}) OR (at.opsy = Lex.eql) OR (at.opsy = Lex.neq));
	       IF (at.leftop.type.form = Sym.real)
		   OR (at.rightop.type.form = Sym.real) THEN
		  RETURN GenFPUComp (proc, at, own);
	       END;
               rset := Gen.StdRegs;
	       IF at.leftop.type.form IN {Sym.char, Sym.byte} THEN
		  rset := Gen.LowByteRegs;
	       END;
	       unsigned := at.leftop.type.form = Sym.char;
	       ops[0] := GenExpr (proc, at.leftop, TRUE, rset, own);
               IF Op.IsError (ops[0]) THEN
	          Regs.DestroyOwnerOnError (proc.regs, own);
		  RETURN ops[0]
	       END;
               needval := TRUE;
	       IF Op.Loc (ops[0]) = Op.register THEN
		  needval := FALSE;
                  rset := Gen.StdRegs;
	       END;
	       ops[1] := GenExpr (proc, at.rightop, needval, rset, own);
               IF Op.IsError (ops[1]) THEN
	          Regs.DestroyOwnerOnError (proc.regs, own);
		  RETURN ops[1]
	       END;
               IF needval THEN
		  tmp := ops[0];
		  ops[0] := ops[1];
		  ops[1] := tmp;
	       END;
	       IF (Op.Loc (ops[1]) = Op.memory) & (ops[1].memsz < 4) THEN
	          ASSERT(Op.Loc (ops[0]) = Op.register);
		  ops[1] := GenValue (proc, ops[1], at.leftop.type.form,
		                      ops[1].memsz, Gen.StdRegs, own);
	       END;
	       IF (Op.Loc (ops[1]) = Op.immediate) & (ops[1].immsz < 4) THEN
	          ops[0].memsz := ops[1].immsz;
	       END;
	       Emit.Instr (proc.s, Pentium.CMP, 2, ops);
	       Regs.RemoveConstraint (ops[0].reg1);
	       Regs.DestroyOwnedValue (ops[0].reg1, own);
	       Regs.DestroyOwnedValue (ops[0].reg2, own);
	       Regs.DestroyOwnedValue (ops[1].reg1, own);
	       Regs.DestroyOwnedValue (ops[1].reg2, own);
	    ELSE
	       ASSERT(at.opsy = -1);  (* FALSE *)
            END;
	    IF ~needval THEN
	       CASE at.opsy OF
	       | Lex.eql:
		  cc := Pentium.JE;
	       | Lex.neq:
		  cc := Pentium.JNE;
	       | Lex.leq:
		  cc := Pentium.JLE;
	       | Lex.geq:
		  cc := Pentium.JGE;
	       | Lex.lst:
		  cc := Pentium.JL;
	       | Lex.grt:
		  cc := Pentium.JG;
	       END;
            ELSE
	       CASE at.opsy OF
	       | Lex.eql:
		  cc := Pentium.JE;
	       | Lex.neq:
		  cc := Pentium.JNE;
	       | Lex.leq:
		  cc := Pentium.JGE;
	       | Lex.geq:
		  cc := Pentium.JLE;
	       | Lex.lst:
		  cc := Pentium.JG;
	       | Lex.grt:
		  cc := Pentium.JL;
	       END;
	    END;
	    IF unsigned THEN
	       CASE cc OF
	       | Pentium.JGE:
		  cc := Pentium.JAE;
	       | Pentium.JLE:
		  cc := Pentium.JBE;
	       | Pentium.JG:
		  cc := Pentium.JA;
	       | Pentium.JL:
		  cc := Pentium.JB;
               | Pentium.JE, Pentium.JNE:
		  (* nothing *)
	       END;
	    END;
	    DEC (cc, Pentium.JCC);
	    RETURN CheckOp(Op.CCOp (cc));
         | Lex.range:
	    (* The set is calculated as -1<<leftop XOR -2<<rightop *)
	    lhs := GenExpr (proc, at.leftop, TRUE, {Gen.gencx}, own);
            IF Op.IsError (lhs) THEN
	       Regs.DestroyOwnerOnError (proc.regs, own);
	       RETURN lhs
	    END;
            CASE Op.Loc (lhs) OF
	    | Op.immediate, Op.immediateDyn:
	       ASSERT(lhs.data.kind = Op.integerConst);
	       IF (lhs.data.intval < 0) OR (lhs.data.intval > 31) THEN
		  CompilerErrors.Raise (proc.errors, FixupLoc (at.leftop), 
				       "constant out of range [0..31]");
                  Regs.DestroyOwnerOnError (proc.regs, own);
		  RETURN Op.Error ();
	       END;
	       lhs := Op.ImmSet(SYSTEM.VAL(SET, ASH(-1, lhs.data.intval)-1));
	    | Op.register:
	       CreateLabel (noerr, "nerr2", at.loc, proc.s);
	       Emit.Instr2 (proc.s, Pentium.CMP, lhs, Op.ImmInt (31));
	       Emit.JumpCC (proc.s, noerr, Pentium.JNA-Pentium.JCC);
	       Regs.EnterLevel (proc.regs);
	       EmitErrors.RangeCheck (proc, at.loc, lhs, Op.ImmInt (31));
	       Regs.LeaveLevel (proc.regs);
	       Regs.DoneLevel (proc.regs);
	       FragmentedStreams.AttachLabel (proc.s, noerr);
	       Regs.AddConstraint (lhs.reg1, {Gen.gencx});
	       lhs.memsz := 1;
               Regs.CreateValue (reg, proc.regs, own, Regs.stdM);
	       Regs.LoadReg (reg, Gen.StdRegs);
	       Emit.Instr2 (proc.s, Pentium.XOR, Op.RegOp (reg, 4),
	                    Op.RegOp (reg, 4));
	       Emit.Instr1 (proc.s, Pentium.DECR, Op.RegOp (reg, 4));
	       Emit.Instr2 (proc.s, Pentium.SHL, Op.RegOp (reg, 4), lhs);
	       Regs.DestroyOwnedValue (lhs.reg1, own);
	       lhs := Op.RegOp (reg, 4 (* SET *));
	       reg := NIL;
	    END;
	    rhs := GenExpr (proc, at.rightop, TRUE, {Gen.gencx}, own);
            IF Op.IsError (rhs) THEN
	       Regs.DestroyOwnerOnError (proc.regs, own);
	       RETURN rhs
	    END;
            CASE Op.Loc (rhs) OF
	    | Op.immediate, Op.immediateDyn:
	       ASSERT(rhs.data.kind = Op.integerConst);
	       IF (rhs.data.intval < 0) OR (rhs.data.intval > 31) THEN
		  CompilerErrors.Raise (proc.errors, FixupLoc (at.rightop), 
				       "constant out of range [0..31]");
                  Regs.DestroyOwnerOnError (proc.regs, own);
		  RETURN Op.Error();
	       END;
	       rhs := Op.ImmSet(SYSTEM.VAL(SET, ASH(-2, rhs.data.intval)-1));
	    | Op.register:
	       CreateLabel (noerr, "noerr2", at.loc, proc.s);
	       Emit.Instr2 (proc.s, Pentium.CMP, rhs, Op.ImmInt (31));
	       Emit.JumpCC (proc.s, noerr, Pentium.JNA-Pentium.JCC);
	       Emit.Instr2 (proc.s, Pentium.MOV, Op.MemOp0 (4, 0, 0), Op.ImmInt (0));
	       Regs.EnterLevel (proc.regs);
	       EmitErrors.RangeCheck (proc, at.loc, rhs, Op.ImmInt (31));
	       Regs.LeaveLevel (proc.regs);
	       Regs.DoneLevel (proc.regs);
	       FragmentedStreams.AttachLabel (proc.s, noerr);
	       Regs.AddConstraint (rhs.reg1, {Gen.gencx});
	       rhs.memsz := 1;
               Regs.CreateValue (reg, proc.regs, own, Regs.stdM);
	       Regs.LoadReg (reg, Gen.StdRegs);
	       Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (reg, 4),
	                   Op.ImmInt (-2));
	       Emit.Instr2 (proc.s, Pentium.SHL, Op.RegOp (reg, 4), rhs);
	       Regs.DestroyOwnedValue (rhs.reg1, own);
	       rhs := Op.RegOp (reg, 4 (* SET *));
	    END;
	    IF ~(Op.Loc (lhs) IN { Op.immediate, Op.immediateDyn}) THEN
	       ASSERT(Op.Loc (lhs) = Op.register);
               Emit.Instr2 (proc.s, Pentium.XOR, lhs, rhs);
	       tmp := lhs;
	       Regs.DestroyOwnedValue (rhs.reg1, own);
	    ELSIF ~(Op.Loc (rhs) IN {Op.immediate, Op.immediateDyn}) THEN
	       ASSERT(Op.Loc (rhs) = Op.register);
               Emit.Instr2 (proc.s, Pentium.XOR, rhs, lhs);
	       tmp := rhs;
	    ELSE
	       tmp := Op.ImmSet (lhs.data.setval / rhs.data.setval);
	    END;
	    ChownOp (tmp, caller);
            IF Op.Loc (tmp) = Op.register THEN
               Regs.SetMode (tmp.reg1, Regs.stdM);
            END;
	    RETURN CheckOp(tmp);
	 END;
      | Sym.constvalAt:
	 ASSERT(ret # NIL); (* FALSE *)
      (* ELSE ASSERT(FALSE) *)
      END;
      ASSERT(ret # NIL); (* FALSE *)
      RETURN NIL;
   END GenExpr;


   PROCEDURE GenDesignator (proc : PC.Context; lop : Sym.Attribute;
			    possible : SET; caller : Regs.Owner) : Op.Operand;
      VAR
         var : VarDesc;
	 ret, op : Op.Operand;
	 msize : LONGINT;
	 tagreg : Regs.Value;
	 own : Regs.Owner;

   BEGIN
      var := NIL;
      own := Regs.GetOwner (proc.regs);
      ASSERT(lop.mode IN Sym.designatorModes);
      CASE lop.mode OF
      | Sym.varAt:
         NEW(var);
	 var.mode := identM;
	 var.ident := lop.ident;
	 var.type := lop.type;
	 op := GenVar (proc, var, FALSE, possible, caller);
	 RETURN CheckOp(op);
      | Sym.refAt:
	 ASSERT(lop.designator # NIL);
	 ASSERT(lop.designator.type.form = Sym.pointer);
	 msize := Sym32.GetSize (proc.module, lop.designator.type.reftype,
			         proc.errors);
	 op := GenExpr (proc, lop.designator, TRUE, possible, caller);
         IF Op.IsError (op) THEN
	    (* No need to destroy registers *)
	    RETURN op
	 END;
	 ASSERT((Op.Loc(op) = Op.register) & (op.reg1 # NIL));
	 op := Op.MemOp1 (op.reg1, msize, 0, 0);
         Regs.SetMode (op.reg1, Regs.ptrM);
	 RETURN CheckOp(op);
      | Sym.selectAt:
	 ASSERT(lop.designator # NIL);
	 RETURN CheckOp(GenSelect (proc, lop, FALSE, possible, caller));
      | Sym.indexAt:
	 ASSERT(lop.designator # NIL);
	 RETURN CheckOp(GenIndex (proc, lop, FALSE, possible, caller));
      | Sym.guardAt:
	 RETURN GenGuard (proc, lop, FALSE, possible, caller);
      (* ELSE error *)
      END;
   END GenDesignator;


   PROCEDURE GenAssignment (proc : PC.Context;
			    leftop : LeftOp; rightop : Sym.Attribute);

      VAR
         varparamL, varparamR : BOOLEAN;
         own : Regs.Owner;
         mode, rset : SET;
         ops : ARRAY 3 OF Op.Operand;
	 carr : ARRAY 2 OF CHAR;
	 reloc : Relocations.RelocRequest;
	 ref : Relocations.SymRef;
	 src, op, op1, op2, lhs, rhs : Op.Operand;
	 context : BoolContext;
	 bytes, len, off : LONGINT;
	 align, align1, align2 : LONGINT;
	 reg1 : Gen.Register;
	 reg, lhsaddr, rhsaddr, rhstag, lhstag : Regs.Value;
	 needzero, needguard : BOOLEAN;
	 es : Streams.Stream;
	 type, attype, rhsstatictype, lhstype : Sym.Type;
	 base, rhsdim, dim : INTEGER;
	 tmp : Sym.Attribute;
	 var : VarDesc;
	 copy : FragmentedStreams.Label;

   BEGIN
      ops[0] := NIL;
      own := Regs.GetOwner(proc.regs);
      CASE leftop.type.form OF
      | Sym.integer, Sym.cardinal, Sym.set, Sym.char, Sym.byte, Sym.address,
        Sym.proceduretype, Sym.coroutine:
	 (* These should all fit into one register *)
         rset := Gen.StdRegs;
         attype := leftop.type;
	 IF leftop.at # NIL THEN
	    Sym32.GetType (leftop.at, type);
	 END;
	 IF Sym32.GetSize (proc.module, attype, proc.errors) = 1 THEN
	    (* SHORTINT, CHAR, BYTE, BOOLEAN *)
	    rset := Gen.LowByteRegs;
	 END;
         ops[1] := GenExpr (proc, rightop, TRUE, rset, own);
         IF Op.IsError (ops[1]) THEN
	    Regs.DestroyOwnerOnError (proc.regs, own);
	    RETURN
	 END;
	 IF ops[1].reg1 # NIL THEN
	    Regs.AddConstraint (ops[1].reg1, rset);
	 END;
	 ops[0] := leftop.op;
	 IF ops[0] = NIL THEN
	    ASSERT(leftop.at # NIL);
	    ops[0] := GenDesignator (proc, leftop.at, Gen.StdRegs, own);
         END;
         IF Op.IsError (ops[0]) THEN
	    Regs.DestroyOwnerOnError (proc.regs, own);
	    RETURN
	 END;
	 (* Ok, let's see how many bytes we actually want to move. This
	  * depends on the types and sizes of the operands. *)
	 CASE leftop.type.form OF
	 | Sym.set, Sym.address, Sym.proceduretype, Sym.coroutine:
	    ASSERT(((Op.Loc(ops[1]) = Op.register) &
		    (ops[1].memsz = 4)) OR
		    ((Op.Loc(ops[1]) = Op.immediate) &
		     (ops[1].immsz = ops[0].memsz)) OR
		    ((Op.Loc(ops[1]) = Op.immediateDyn) &
		     (ops[1].immsz <= ops[0].memsz)));
	    IF (Op.Loc (ops[1]) = Op.register) THEN
	       ops[1].memsz := ops[0].memsz;
	    END;
	 | Sym.byte, Sym.char:
	    ASSERT((Op.Loc(ops[1]) = Op.register) OR
	            ((Op.Loc(ops[1]) = Op.immediate) &
			  (ops[1].immsz = ops[0].memsz)) OR
		    ((Op.Loc(ops[1]) = Op.immediateDyn) &
			  (ops[1].immsz <= ops[0].memsz)));
	    IF Op.Loc (ops[1]) IN {Op.register, Op.memory} THEN
	       ops[1].memsz := 1;
	    END;
         | Sym.integer, Sym.cardinal:
	    CASE Op.Loc(ops[1]) OF
	    | Op.register:
	       ASSERT(ops[1].memsz = 4 (* LONGINT *));
	       ASSERT(ops[1].memsz >= ops[0].memsz);
	       IF ops[1].memsz > ops[0].memsz THEN
	          (* An Integer Expression is always returned as a
	           * LONGINT. Type Problems are caught by the first pass,
	           * i.e. we can just reduce the size. Fortunately the
		   * same can also be done with constants.
		   * All operations are done with full integer precision,
		   * overflows may result in unexpected behaviour. *)
		  ASSERT(ops[1].memsz = 4 (* LONGINT *));
                  ASSERT(Regs.RegCode(ops[1].reg1, reg1) &
			  (reg1 IN Gen.LowByteRegs));
		  ops[1].memsz := ops[0].memsz;
	       END;
            | Op.immediateDyn:
	       IF ops[1].immsz > ops[0].memsz THEN
		  CompilerErrors.Raise (proc.errors, FixupLoc (rightop), 
					"constant out of range");
                  Regs.DestroyOwnerOnError (proc.regs, own);
		  RETURN
               END;
            | Op.immediate:
	       IF ops[1].memsz # ops[0].memsz THEN
		  CompilerErrors.Raise (proc.errors, FixupLoc (rightop), 
					"constant out of range");
                  Regs.DestroyOwnerOnError (proc.regs, own);
		  RETURN
	        END;
	    END;
	 END;
	 IF leftop.needdptrs & (rightop.type.form = Sym.address) &
	        rightop.type.traced & (Op.Loc (ops[1]) = Op.register) THEN
	    NEW (leftop.dptrs);
	    leftop.dptrs.next := NIL;
	    leftop.dptrs.offset := ops[0].disp;
	    leftop.dptrs.reg := ops[1].reg1;
	    Regs.SetMode (leftop.dptrs.reg, Regs.addrM);
	    Regs.Chown (leftop.dptrs.reg, leftop.own);
	 ELSE
	    Emit.Instr (proc.s, Pentium.MOV, 2, ops);
	    Regs.DestroyOwnedValue (ops[1].reg1, own);
	    Regs.DestroyOwnedValue (ops[1].reg2, own);
	 END;
	 IF leftop.op = NIL THEN
	    Regs.DestroyOwnedValue (ops[0].reg1, own);
	    Regs.DestroyOwnedValue (ops[0].reg2, own);
	 END;
      | Sym.boolean:
         op := leftop.op;
	 IF op = NIL THEN
	    ASSERT(leftop.at # NIL);
	    op := GenDesignator (proc, leftop.at, Gen.StdRegs, own);
         END;
         IF Op.IsError (op) THEN
	    Regs.DestroyOwnerOnError (proc.regs, own);
	    RETURN
	 END;
         NEW (context);
	 context.target := op;
	 context.truelab := NIL;
	 context.falselab := NIL;
	 context.neg := FALSE;
	 context.setaction := setAll;
	 GenBool (proc, rightop, context);
	 IF leftop.op = NIL THEN
	    Regs.DestroyOwnedValue (context.target.reg1, own);
	    Regs.DestroyOwnedValue (context.target.reg2, own);
	 END;
      | Sym.real:
         ops[1] := GenExpr (proc, rightop, FALSE, Gen.StdRegs, own);
	 IF Op.IsError (ops[1]) THEN
	    Regs.DestroyOwnerOnError (proc.regs, own);
	    RETURN
	 END;
	 ASSERT(rightop.type # NIL);
	 ops[1] := LoadFPUReg (proc, ops[1], rightop.type.form, ops[1].memsz, own);
	 (*
	 ASSERT(Streams.Flush (Streams.stdout));
	 *)
	 ops[0] := leftop.op;
	 IF ops[0] = NIL THEN
	    ASSERT(leftop.at # NIL);
	    ops[0] := GenDesignator (proc, leftop.at, Gen.StdRegs, own);
         END;
         IF Op.IsError (ops[0]) THEN
	    Regs.DestroyOwnerOnError (proc.regs, own);
	    RETURN
	 END;
	 I386FPURegisters.StoreReal (ops[1].reg1, proc.s, ops[0]);
	 IF leftop.op = NIL THEN
	    Regs.DestroyOwnedValue (ops[0].reg1, own);
	    Regs.DestroyOwnedValue (ops[0].reg2, own);
	 END;
      | Sym.array:
	 op2 := GenExpr (proc, rightop, FALSE, {Gen.gensi}, own);
         IF Op.IsError (op2) THEN
	    Regs.DestroyOwnerOnError (proc.regs, own);
	    RETURN
	 END;
	 IF rightop.type.dyn THEN
	    (* We can't do anything like an assignment with
	     * open arrays, except pass them to another procedure. *)
	    ASSERT((leftop.type.dyn) & (leftop.op # NIL));
	 END;
	 IF leftop.op # NIL THEN
	    (* The data is assigned to a parameter *)
	    (* IF op2 is immediate (i.e. a char constant) we need backing
	     * store for the string. => Put it into the string table. *)
	    IF Op.Loc (op2) IN {Op.immediate, Op.immediateDyn} THEN
	       ASSERT(op2.data.kind = Op.charConst);
	       carr[0] := op2.data.charval; carr[1] := 0X;
	       off := Emit.StringArray (proc.rodata, carr, len);
	       op2 := Op.MemOp0 (1, off, 4 (* Relocation *));
	       NEW (ref);
	       ref.modname := RealName (proc.module);
	       ConstStrings.Create (ref.symname, "__rodata");
	       Relocations.Create (reloc, proc.s, Relocations.addSym, ref);
	       Op.RelocOpen (op2, reloc);
	    END;
	    op1 := Op.Dup (leftop.op);
	    op1.memsz := 4;
	    reg := NIL;
	    IF (op2.reg1 # NIL) & (op2.reg2 = NIL) & (op2.disp = 0) &
	       (op2.dispsz = 0) THEN
	       reg := op2.reg1;
	       IF Regs.Traced (reg) THEN
	          Regs.LoadReg (reg, Gen.StdRegs);
		  Regs.SetMode (reg, Regs.addrM);
	       END;
            ELSE
	       Regs.CreateValue (reg, proc.regs, own, Regs.addrM);
	       Regs.LoadReg (reg, Gen.StdRegs);
	       ops[0] := Op.RegOp (reg, 4 (* address *));
	       ops[1] := op2;
	       op2.memsz := 4;
	       Emit.Instr (proc.s, Pentium.LEA, 2, ops);
	       Regs.DestroyOwnedValue (op2.reg1, own);
	       Regs.DestroyOwnedValue (op2.reg2, own);
	    END;
	    IF leftop.needdptrs THEN
	       NEW (leftop.dptrs);
	       leftop.dptrs.next := NIL;
	       leftop.dptrs.offset := op1.disp;
	       leftop.dptrs.reg := reg;
	       Regs.Chown (leftop.dptrs.reg, leftop.own);
	    ELSE
	       Emit.Instr2 (proc.s, Pentium.MOV, op1, Op.RegOp (reg, 4));
	       Regs.DestroyOwnedValue (reg, own);
	    END;
	    (* We are done with op2 if we assign to a parameter. *)
	    IF leftop.type.dyn THEN
	       ASSERT(leftop.op # NIL);
	       base := 0; (* base is the number of elements of the rhs dope
			   * vector that we have to skip. *)
	       rhsdim := 0; (* rhsdim is the number of elements of the rhs
			     * dope vector that we can copy. *)
	       Sym32.GetType (rightop, rhsstatictype);
	       IF rightop.type.dyn THEN
		  tmp := rightop;
		  WHILE tmp.mode # Sym.varAt DO
		     ASSERT(tmp.mode = Sym.indexAt);
		     tmp := tmp.designator;
		     INC(base);
		  END;
		  Sym32.GetType (rightop, type);
		  WHILE type.dyn DO
		     INC(rhsdim);
		     type := type.element;
		  END;
		  rhsstatictype := type;
	       END;
	       (* dim is the number of entries in the new dope vector. *)
	       dim := 0;
	       type := leftop.type;
	       WHILE type.dyn DO
		  INC(dim);
		  type := type.element;
	       END;
	       ASSERT(dim >= rhsdim);
	       IF rhsdim > 0 THEN
		  NEW(var);
		  var.mode := stackM;
		  var.ident := tmp.ident;
		  var.type := NIL;
		  (* src will be destroyed by GenStringOp *)
		  src := GenVar (proc, var, FALSE, {Gen.gensi}, own);
		  IF Op.IsError (src) THEN
		     Regs.DestroyOwnerOnError (proc.regs, own);
		     RETURN
		  END;
		  INC (src.disp, Ob32.pointerSize+base*Ob32.int32Size);
		  INC (op1.disp, Ob32.pointerSize);
		  GenStringOp (proc, Pentium.MOVS, {Gen.rep}, op1, src,
			       Op.ImmInt (rhsdim), Ob32.int32Size, FALSE, own);
		  DEC (dim, rhsdim);
		  Regs.UntracedValue (reg, Gen.gendi);
		  ops[0] := Op.MemOp1 (reg, Ob32.int32Size,
				       Ob32.pointerSize+rhsdim*Ob32.int32Size, 0);
		  type := rhsstatictype;
		  WHILE dim > 0 DO
		     ASSERT((type.length # NIL) & (type.form = Sym.array));
		     ops[1] := GenExpr (proc, type.length, TRUE, {}, own);
		     IF Op.IsError (ops[1]) THEN
		        Regs.DestroyOwnerOnError (proc.regs, own);
			RETURN
		     END;
		     Emit.Instr (proc.s, Pentium.MOV, 2, ops);
		     DEC(dim);
		     type := type.element;
		     INC(ops[0].disp, Ob32.int32Size);
		  END;
	       ELSE
		  INC(op1.disp, Ob32.pointerSize);
		  ops[0] := op1;
		  type := rhsstatictype;
		  IF rhsstatictype.form = Sym.char THEN
		     (* Character constant passed to ARRAY OF CHAR *)
		     ops[1] := Op.ImmInt (2);
		     Emit.Instr (proc.s, Pentium.MOV, 2, ops);
		  ELSE
		     WHILE dim > 0 DO
			ASSERT((type.length # NIL) & (type.form = Sym.array));
			ops[1] := GenExpr (proc, type.length, TRUE, {}, own);
			IF Op.IsError (ops[1]) THEN
			   Regs.DestroyOwnerOnError (proc.regs, own);
			   RETURN
			END;
			Emit.Instr (proc.s, Pentium.MOV, 2, ops);
			DEC (dim);
			type := type.element;
			INC(ops[0].disp, Ob32.int32Size);
		     END;
		  END;
		  (* Note: GenCall will destroy the registers of
		   * leftop.op. *)
	       END;
	    END;
	    (* Assignment to a parameter. The data is copied by the
	     * called procedure if needed. *)
	    RETURN
	 END;
	 ASSERT(~leftop.needdptrs);
	 op1 := Op.Dup (leftop.op);
	 IF op1 = NIL THEN
	    ASSERT(leftop.at # NIL);
	    op1 := GenExpr (proc, leftop.at, FALSE, {Gen.gendi}, own);
         END;
         IF Op.IsError (op1) THEN
	    Regs.DestroyOwnerOnError (proc.regs, own);
	    RETURN
	 END;
	 attype := leftop.type;
	 IF leftop.at # NIL THEN
	    Sym32.GetType (leftop.at, attype);
	 END;
         bytes := Sym32.GetSize (proc.module, attype, proc.errors);
	 ASSERT(Op.Loc(op1) = Op.memory);
         (* We use NIL for the stream because we don't want to generate
	  * code to determine the array length. If this is false for
	  * non open arrays something is seriously broken. *)
         op := GenExpr (proc, attype.length, TRUE, {}, own);
         IF Op.IsError (op) THEN
	    Regs.DestroyOwnerOnError (proc.regs, own);
	    RETURN
	 END;
	 ASSERT(Op.Loc(op) IN {Op.immediate, Op.immediateDyn});
	 ASSERT(op.data # NIL);
	 ASSERT(op.data.kind = Op.integerConst);
	 len := op.data.intval;
         IF Op.Loc(op2) = Op.immediate THEN
	    (* Char constant assigned to string *)
	    ASSERT(op2.data.kind = Op.charConst);
	    ASSERT(leftop.type.element.form IN {Sym.char, Sym.byte});
	    needzero := op2.data.charval # 0X;
	    IF (needzero & (len < 2)) OR (len < 1) THEN
	       CompilerErrors.Open (es);
	       CompilerErrors.At1 (es, FixupLoc (rightop));
	       CompilerErrors.RefObject (es, leftop.type);
	       Write.StringS (es, "constant string expression is too long for designator");
	       CompilerErrors.Close (es, proc.errors);
	       Regs.DestroyOwnerOnError (proc.regs, own);
	       RETURN;
	    END;
	    op1.memsz := 1;
	    ops[0] := op1;
	    ops[1] := op2;
	    Emit.Instr (proc.s, Pentium.MOV, 2, ops);
	    IF needzero THEN
	       INC(op1.disp);
	       ops[1] := Op.ImmChar(0X);
	       Emit.Instr (proc.s, Pentium.MOV, 2, ops);
	    END;
	    IF leftop.op = NIL THEN
	       Regs.DestroyOwnedValue (op1.reg1, own);
	       Regs.DestroyOwnedValue (op1.reg2, own);
	    END;
	 ELSE
	    ASSERT(Op.Loc(op2) = Op.memory);
	    align := 1;
	    IF rightop.mode IN {Sym.constAt, Sym.constvalAt} THEN
	       (* This can only happen if the right hand side is a
		* character constant (handled above) or a string. *)
               ASSERT(leftop.type.element.form = Sym.char);
	       bytes := op2.memsz;
	       ASSERT(bytes <= len);
	    ELSE
	       attype := leftop.type;
	       IF leftop.at # NIL THEN
	          Sym32.GetType (leftop.at, attype);
	       END;
	       align1 := Sym32.GetAlign (proc.module, attype, proc.errors);
	       Sym32.GetType (rightop, attype);
	       align2 := Sym32.GetAlign (proc.module, attype, proc.errors);
	       WHILE ~ODD(align1) & ~ODD (align2) & (align < 4) DO
		  align := align*2;
		  align1 := align1 DIV 2;
		  align2 := align2 DIV 2;
		  (* Round up, just in case ... *)
		  bytes := (bytes +1) DIV 2;
	       END;
	    END;
	    (* We pass FALSE here: If someone really manages to allocate
	     * overlapping arrays we were fooled anyway. *)
            GenStringOp (proc, Pentium.MOVS, {Gen.rep}, op1, op2,
		         Op.ImmInt (bytes), SHORT(align), FALSE, own);
         END;
      | Sym.record:
         (* XXX What should happen if leftop.needdptrs is set? Pass the
	  * Record by reference? *)
	 lhstag := NIL;
	 IF (leftop.at # NIL) & (leftop.at.mode = Sym.varAt) &
	    (leftop.at.ident.kind = Sym.refParam) THEN
	    ASSERT(leftop.op = NIL);
	    NEW (var);
	    var.ident := leftop.at.ident;
	    var.mode := stackM;
	    lhs := GenVar (proc, var, FALSE,
			   Gen.StdRegs-{Gen.gensi, Gen.gendi}, own);
	    IF Op.IsError (lhs) THEN
	       Regs.DestroyOwnerOnError (proc.regs, own);
	       RETURN;
	    END;
	    Regs.CreateValue (lhsaddr, proc.regs, own, Regs.addrM);
	    Regs.LoadReg (lhsaddr, {Gen.gendi});
	    Regs.AddConstraint (lhsaddr, {Gen.gendi});
	    Regs.CreateValue (lhstag, proc.regs, own, Regs.stdM);
	    Regs.LoadReg (lhstag, Gen.StdRegs);
	    lhs.memsz := 4;
	    Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (lhsaddr, 4), lhs);
	    INC (lhs.disp, 4);
	    Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (lhstag, 4), lhs);
	    Regs.DestroyOwnedValue (lhs.reg1, own);
	    Regs.DestroyOwnedValue (lhs.reg2, own);
	    lhs := Op.MemOp1 (lhsaddr, 4, 0, 0);
	 ELSIF (leftop.at # NIL) & (leftop.at.mode = Sym.refAt) THEN
	    ASSERT(leftop.op = NIL);
	    lhs := GenExpr (proc, leftop.at.designator, TRUE,
			    {Gen.gendi}, own);
	    IF Op.IsError (lhs) THEN
	       Regs.DestroyOwnerOnError (proc.regs, own);
	       RETURN;
	    END;
	    CASE Op.Loc (lhs) OF
	    | Op.immediate, Op.immediateDyn:
	       Regs.CreateValue (lhsaddr, proc.regs, own, Regs.addrM);
	       Regs.LoadReg (lhsaddr, {Gen.gendi});
	       Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (lhsaddr, 4), lhs);
	    | Op.register:
	       lhsaddr := lhs.reg1;
	    END;
	    Regs.AddConstraint (lhsaddr, {Gen.gendi});
	    Regs.CreateValue (lhstag, proc.regs, own, Regs.stdM);
	    Regs.LoadReg (lhstag, Gen.StdRegs);
	    IF leftop.at.designator.type.taggedptr THEN
	       Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (lhstag, 4),
			    Op.MemOp1 (lhsaddr, 4, -4, 0));
	    ELSE
	       Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (lhstag, 4),
			    GenTypes.GenTag (proc, leftop.at.designator.type));
	    END;
	    lhs := Op.MemOp1 (lhsaddr, 4, 0, 0);
	 ELSE
	    lhs := leftop.op;
	    lhstype := leftop.type;
	    IF lhs = NIL THEN
	       lhs := GenExpr (proc, leftop.at, FALSE,
			       Gen.StdRegs-{Gen.gensi, Gen.gendi}, own);
	       IF Op.IsError (lhs) THEN
		  Regs.DestroyOwnerOnError (proc.regs, own);
		  RETURN;
	       END;
	       lhstype := leftop.at.type;
	    END;
	 END;
	 IF (rightop.mode = Sym.varAt) &
	    (rightop.ident.kind = Sym.refParam) THEN
	    NEW (var);
	    var.ident := rightop.ident;
	    var.mode := stackM;
	    rhs := GenVar (proc, var, FALSE,
			   Gen.StdRegs-{Gen.gensi, Gen.gendi}, own);
	    IF Op.IsError (lhs) THEN
	       Regs.DestroyOwnerOnError (proc.regs, own);
	       RETURN;
	    END;
	    Regs.CreateValue (rhstag, proc.regs, own, Regs.stdM); 
	    Regs.LoadReg (rhstag, Gen.StdRegs);
	    INC(rhs.disp, 4);
	    rhs.memsz := 4;
	    Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (rhstag, 4), rhs);
	    IF lhstag = NIL THEN
	       GenTypes.TypeGuard (proc, rhstag, lhstype, NIL, rightop.loc);
	       Regs.DestroyOwnedValue (rhstag, own);
	    ELSE
	       GenTypes.AssignmentTypeGuard (proc, lhstag, rhstag, rightop.loc);
	       Regs.DestroyOwnedValue (rhstag, own);
	    END;
	    Regs.CreateValue (rhsaddr, proc.regs, own, Regs.addrM);
	    Regs.LoadReg (rhsaddr, {Gen.gensi});
	    DEC (rhs.disp, 4);
	    Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (rhsaddr, 4), rhs);
	    Regs.DestroyOwnedValue (rhs.reg1, own);
	    Regs.DestroyOwnedValue (rhs.reg2, own);
	    rhs := Op.RegOp (rhsaddr, 4);
	 ELSIF (rightop.mode = Sym.refAt) THEN
	    rhs := GenExpr (proc, rightop.designator, TRUE,
			    {Gen.gensi}, own);
	    IF Op.IsError (rhs) THEN
	       Regs.DestroyOwnerOnError (proc.regs, own);
	       RETURN;
	    END;
	    CASE Op.Loc (rhs) OF
	    | Op.immediate, Op.immediateDyn:
	       Regs.CreateValue (rhsaddr, proc.regs, own, Regs.addrM);
	       Regs.LoadReg (rhsaddr, {Gen.gensi});
	       Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (rhsaddr, 4), rhs);
	    | Op.register:
	       rhsaddr := rhs.reg1;
	    END;
	    Regs.AddConstraint (rhsaddr, {Gen.gensi});
	    Regs.CreateValue (rhstag, proc.regs, own, Regs.stdM);
	    Regs.LoadReg (rhstag, Gen.StdRegs);
	    Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (rhstag,4),
			 Op.MemOp1 (rhsaddr, 4, -4, 0));
	    IF lhstag = NIL THEN
	       GenTypes.TypeGuard (proc, rhstag, lhstype, NIL, rightop.loc);
	       Regs.DestroyOwnedValue (rhstag, own);
	    ELSE
	       GenTypes.AssignmentTypeGuard (proc, lhstag, rhstag, rightop.loc);
	       Regs.DestroyOwnedValue (rhstag, own);
	    END;
	    rhs := Op.MemOp1 (rhsaddr, 4, 0, 0);
	 ELSE
	    rhs := GenExpr (proc, rightop, FALSE, Gen.StdRegs, own);
	    IF lhstag = NIL THEN
	       IF ~GenTypes.StaticTypeGuard (proc, lhstype, rightop.type,
					     rightop.loc, FALSE) THEN
		  Regs.DestroyOwnerOnError (proc.regs, own);
		  RETURN
	       END;
	    ELSE
	       Regs.CreateValue (rhstag, proc.regs, own, Regs.stdM);
	       Regs.LoadReg (rhstag, Gen.StdRegs);
	       Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (rhstag, 4),
			    GenTypes.GenTag (proc, rightop.type));
	       GenTypes.AssignmentTypeGuard (proc, lhstag, rhstag,
					     rightop.loc);
	       Regs.DestroyOwnedValue (rhstag, own);
	    END;
	    IF Op.IsError (rhs) THEN
	       Regs.DestroyOwnerOnError (proc.regs, own);
	       RETURN;
	    END;
	 END;
	 IF lhstag # NIL THEN
	    Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (lhstag, 4),
	                 Op.MemOp1 (lhstag, 4, GenTypes.sizeoff, 0));
	    GenStringOp (proc, Pentium.MOVS, {Gen.rep}, lhs, rhs, 
			 Op.RegOp (lhstag, 4), 1, FALSE, own);
	 ELSE
	    GenStringOp (proc, Pentium.MOVS, {Gen.rep}, lhs, rhs,
	        Op.ImmInt (Sym32.GetSize (proc.module, lhstype, proc.errors)),
	        1, FALSE, own);
	 END;
      | Sym.pointer:
	 varparamL := (leftop.at # NIL) & (leftop.at.mode = Sym.varAt) &
	              (leftop.at.ident.varkind = Sym.refParam);
	 varparamR := (rightop.mode = Sym.varAt) &
	              (rightop.ident.varkind = Sym.refParam);
	 Sym32.GetType (rightop, attype);
	 (* attype.reftype = NIL is a sure sign that the rhs is an
	  * explicit NIL pointer. In this case and if the reftype is
	  * an array or untagged pointer we can't do a type check
	  * either because the rhs has no reftype or because the types
	  * tags don't exist or can't be compared in the usual ways. *)
         IF varparamL & (attype.reftype # NIL) & (attype.reftype.form = Sym.record) & attype.taggedptr THEN
	    ASSERT(leftop.at # NIL);
	    NEW (var);
	    var.ident := leftop.at.ident;
	    var.mode := stackM;
	    lhs := GenVar (proc, var, FALSE, Gen.StdRegs, own);
	    IF Op.IsError (lhs) THEN
	       Regs.DestroyOwnerOnError (proc.regs, own);
	       RETURN
	    END;
	    lhstag := LoadTmpTag (proc, leftop.at, own);
	    IF lhstag = NIL THEN
	       Regs.CreateValue (lhstag, proc.regs, own, Regs.stdM);
	       Regs.LoadReg (lhstag, Gen.StdRegs);
	       INC (lhs.disp, 4);
	       Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (lhstag, 4), lhs);
	       DEC (lhs.disp, 4);
	    END;
	    lhs := GenValue (proc, lhs, Sym.pointer, 4, Gen.StdRegs, own);
            Regs.SetMode (lhs.reg1, Regs.ptrM);
	    lhs := Op.MemOp1 (lhs.reg1, 4, 0, 0);
	    IF varparamR THEN
	       NEW(var);
	       var.ident := rightop.ident;
	       var.mode := stackM;
	       rhs := GenVar (proc, var, FALSE, Gen.StdRegs, own);
	       rhs.memsz := 4;
	       IF Op.IsError (rhs) THEN
		  Regs.DestroyOwnerOnError (proc.regs, own);
		  RETURN
	       END;
	       rhstag := LoadTmpTag (proc, rightop, own);
	       IF rhstag = NIL THEN
		  Regs.CreateValue (rhstag, proc.regs, own, Regs.stdM);
		  Regs.LoadReg (rhstag, Gen.StdRegs);
		  INC (rhs.disp, 4);
		  Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (rhstag, 4), rhs);
		  DEC (rhs.disp, 4);
	       END;
	       rhs := GenValue (proc, rhs, Sym.pointer, 4, Gen.StdRegs, own);
	       ASSERT(Op.Loc (rhs) = Op.register);
	       rhs := Op.MemOp1 (rhs.reg1, 4, 0, 0);
	       rhs := GenValue (proc, rhs, Sym.pointer, 4, Gen.StdRegs, own);
               SetMode (rhs.reg1, rightop.type);
	    ELSE
	       rhs := GenExpr (proc, rightop, TRUE, Gen.StdRegs, own);
	       IF Op.IsError (rhs) THEN
		  Regs.DestroyOwnerOnError (proc.regs, own);
		  RETURN
	       END;
	       IF Op.Loc (rhs) IN {Op.immediate, Op.immediateDyn} THEN
		  Regs.CreateValue (reg, proc.regs, own, Regs.stdM);
		  Regs.LoadReg (reg, Gen.StdRegs);
		  Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (reg, 4), rhs);
		  rhs := Op.RegOp (reg, 4);
                  SetMode (reg, rightop.type);
	       ELSE
		  ASSERT(Op.Loc (rhs) = Op.register);
		  reg := rhs.reg1;
	       END;
	       ASSERT(Op.Loc (rhs) = Op.register);
	       Emit.Instr2 (proc.s, Pentium.ORI, rhs, rhs);
	       FragmentedStreams.CreateLabel (copy);
	       Emit.JumpCC (proc.s, copy, Pentium.JE-Pentium.JCC);
	       Regs.EnterLevel (proc.regs);
	       rhstag := LoadTmpTag (proc, rightop, own);
	       IF rhstag = NIL THEN
		  Regs.CreateValue (rhstag, proc.regs, own, Regs.stdM);
		  Regs.LoadReg (rhstag, Gen.StdRegs);
	          IF rightop.type.taggedptr THEN 
		     Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (rhstag, 4),
		                  Op.MemOp1 (reg, 4, -4, 0));
		  ELSE
		     Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (rhstag, 4),
				  GenTypes.GenTag (proc, rightop.type));
		  END;
	       END;
	    END;
	    ASSERT(rhstag # NIL);
	    GenTypes.AssignmentTypeGuard (proc, lhstag, rhstag, rightop.loc);
	    Regs.DestroyOwnedValue (rhstag, own);
	    IF ~varparamR THEN
	       Regs.LeaveLevel (proc.regs);
	       Regs.DoneLevel (proc.regs);
	       FragmentedStreams.AttachLabel (proc.s, copy);
	    ELSE
	       ASSERT(copy = NIL);
	    END;
	    Regs.DestroyOwnedValue (lhstag, own);
	 ELSE
	    lhs := leftop.op;
	    IF lhs = NIL THEN
	       lhs := GenDesignator (proc, leftop.at, Gen.StdRegs, own);
	    END;
	    IF Op.IsError (lhs) THEN
	       Regs.DestroyOwnerOnError (proc.regs, own);
	       RETURN
	    END;
	    rhs := GenExpr (proc, rightop, TRUE, Gen.StdRegs, own);
	 END;
	 IF leftop.needdptrs & leftop.type.taggedptr & (Op.Loc (rhs) = Op.register) THEN
	    ASSERT((leftop.op # NIL) & (leftop.type.form = Sym.pointer));
	    ASSERT((Op.Loc (rhs) = Op.register) & Regs.Traced (rhs.reg1));
	    NEW (leftop.dptrs);
	    leftop.dptrs.next := NIL;
	    leftop.dptrs.offset := leftop.op.disp;
	    leftop.dptrs.reg := rhs.reg1;
	    Regs.LoadReg (rhs.reg1, Gen.StdRegs);
            Regs.SetMode (rhs.reg1, Regs.ptrM);
	    Regs.Chown (leftop.dptrs.reg, leftop.own);
	 ELSE
	    Emit.Instr2 (proc.s, Pentium.MOV, lhs, rhs);
	    Regs.DestroyOwnedValue (rhs.reg1, own);
	 END;
	 IF leftop.op = NIL THEN
	    Regs.DestroyOwnedValue (lhs.reg1, own);
	    Regs.DestroyOwnedValue (lhs.reg2, own);
	 END;
      END;
   END GenAssignment;

   PROCEDURE RegCommit (set : Regs.RegSet; val : Regs.Value);
   BEGIN
      TmpPtrs.Commit (val);
   END RegCommit;


   PROCEDURE GenCall (proc : PC.Context; stmt : Sym.Attribute;
		      caller : Regs.Owner) : Regs.Value;
      VAR
	 varp, ok : BOOLEAN;
	 rhs, op : Op.Operand;
	 realsize, msize : LONGINT;
	 lev, codelev : INTEGER;
	 ref : Relocations.SymRef;
	 rhstag, return, reg, reg2 : Regs.Value;
	 ops1 : ARRAY 2 OF Op.Operand;
	 param : Sym.ParamList;
	 tmp1, tmp2 : Sym.Attribute;
	 lop : LeftOp;
	 own : Regs.Owner;
	 l : FragmentedStreams.Label;
	 tmps : FragmentedStreams.Stream;
	 retoffset, offset, fpuoffset : LONGINT;
	 fputop : INTEGER;
	 attype : Sym.Type;
	 var : VarDesc;
	 stackalloc : Disciplines.Object;
	 stackspace : LONGINT;
	 dptr, dptrs : DelayedPtr;
   BEGIN
      ASSERT(reg2 = NIL);
      own := Regs.GetOwner (proc.regs);
      return := NIL;
      IF stmt.proc.type.restype # NIL THEN
	 IF stmt.proc.type.restype.form = Sym.real THEN
	    retoffset := StackAlloc.Allocate (proc.stack, 8, 4, FALSE);
	 ELSE
	    Regs.CreateValue (return, proc.regs, own, Regs.stdM);
	    Regs.SaveReg (return);
	 END;
      END;
      (* There are two (known) cases where we need additional storage
       * in the caller after we allocated the parameter block:
       * - passing non memory data (i.e. some constants) to an array of byte.
       *   Most of this should be doable with saved values.
       * - passing a character or string constant to a FIXED length array.
       *   This is only done to give the called procedure something to
       *   copy the data from.
       * When we need (a fixed amount of!) data on the stack we address
       * it as %esp+stackspace. After we are done with it we increment
       * stackspace by the amount of data needed.
       *)
      NEW (stackalloc);
      FragmentedStreams.IncludeObject (proc.s, stackalloc, 0, 20);
(* PARAM
      stackspace := Sym32.ParamBlockSize (proc.module, stmt.proc.type,
                                          proc.errors);
 * PARAM *)
(* PARAM DELETE BEGIN *)
      stackspace := OA.DataBlockSize (proc.module, stmt.proc.type, proc.errors);
(* PARAM DELETE END *)
      ASSERT(stackspace MOD 4 = 0);
      IF stmt.proc.type.restype # NIL THEN
	 IF stmt.proc.type.restype.form # Sym.real THEN
	    ok := Regs.StackOffset (return, retoffset); ASSERT(ok);
	 END;
         Regs.UntracedValue (reg, Gen.gensp);
         ops1[0] := Op.MemOp1 (reg, 4, OA.ResOffset (stmt.proc.type), 0);
	 Regs.UntracedValue (reg, Gen.genbp);
         ops1[1] := Op.RegOp (reg, 4);
	 Emit.Instr (proc.s, Pentium.MOV, 2, ops1);
	 ops1[1] := Op.ImmInt (retoffset);
	 Emit.Instr (proc.s, Pentium.ADD, 2, ops1);
      END;
      param := stmt.proc.type.paramlist;
      tmp1 := stmt.firstparam;
      WHILE (tmp1 # NIL) & (param # NIL) DO
	 IF (param.paramkind = Sym.refParam) &
	    (param.type.form # Sym.array) THEN
	    msize := Ob32.pointerSize;
	    Regs.UntracedValue (reg, Gen.gensp);
            op := Op.MemOp1 (reg, msize, OA.VarOffset (param), 0);
	    varp := (tmp1.mode = Sym.varAt) &
	                     (tmp1.ident.varkind = Sym.refParam);
	    IF ~varp THEN
	       rhs := GenDesignator (proc, tmp1, Gen.StdRegs, own);
	       rhs := Lea (proc, rhs, Gen.StdRegs, own);
	       ASSERT(rhs.reg1 # NIL);
	       (* Lea already set the Register mode to Regs.addrM. We
	        * always need this for a VAR parameter. *)
	       NEW (dptr);
	       dptr.next := dptrs; dptrs := dptr;
	       dptr.reg := rhs.reg1;
	       dptr.offset := OA.VarOffset (param);
	       ASSERT(op.disp = dptr.offset);
	       IF tmp1.type.form IN {Sym.pointer, Sym.record} THEN
		  (* The static type of the parameter is known. *)
		  rhstag := LoadTmpTag (proc, tmp1, own);
		  IF rhstag = NIL THEN
		     attype := tmp1.type;
		     IF attype.form = Sym.pointer THEN
			attype := attype.reftype;
		     END;
		     INC (op.disp, 4);
		     Emit.Instr2 (proc.s, Pentium.MOV, op,
				  GenTypes.GenTag (proc, attype));
		  ELSE
		     Emit.Instr2 (proc.s, Pentium.MOV, op,
				  Op.RegOp (rhstag, 4));
		     Regs.DestroyOwnedValue (rhstag, own);
		  END;
	       END;
	    ELSE
	       NEW (var);
	       var.mode := stackM;
	       var.ident := tmp1.ident;
	       rhs := GenVar (proc, var, FALSE, Gen.StdRegs, own);
	       Regs.CreateValue (reg, proc.regs, own, Regs.addrM);
	       Regs.LoadReg (reg, Gen.StdRegs);
	       Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (reg, 4), rhs);
	       NEW (dptr); dptr.next := dptrs; dptrs := dptr;
               dptr.reg := reg;
	       dptr.offset := OA.VarOffset (param);
	       ASSERT(dptr.offset = op.disp);
	       reg := NIL;
	       IF tmp1.type.form IN {Sym.pointer, Sym.record} THEN
	          rhstag := LoadTmpTag (proc, tmp1, own);
		  INC (op.disp, 4);
		  INC (rhs.disp, 4);
		  IF rhstag # NIL THEN
		     Emit.Instr2 (proc.s, Pentium.MOV, op,
		                  Op.RegOp (rhstag, 4));
		     Regs.DestroyOwnedValue (rhstag, own);
		  ELSE
		     Regs.CreateValue (reg, proc.regs, own, Regs.stdM);
		     Regs.LoadReg (reg, Gen.StdRegs);
		     Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (reg, 4), rhs);
		     Emit.Instr2 (proc.s, Pentium.MOV, op, Op.RegOp (reg, 4));
		     Regs.DestroyOwnedValue (reg, own);
		  END;
	       END;
	       Regs.DestroyOwnedValue (rhs.reg1, own);
	       Regs.DestroyOwnedValue (rhs.reg2, own);
	    END;
	 ELSIF (param.type.form = Sym.array) & (param.type.dyn) &
	    (param.type.element.form = Sym.byte) THEN
	    (* Assignment to ARRAY OF BYTE *)
            Sym32.GetType (tmp1, attype);
	    msize := Sym32.GetSize (proc.module, attype, proc.errors);
	    realsize := msize;
	    IF (attype.form = Sym.array) & ~attype.dyn THEN
	       rhs := GenExpr (proc, tmp1.type.length, TRUE, Gen.StdRegs, own);
	       ASSERT(Op.Loc (rhs) IN {Op.immediate, Op.immediateDyn});
	       ASSERT(rhs.data.kind = Op.integerConst);
	       realsize := Sym32.GetSize (proc.module, attype.element,
	                                  proc.errors);
	       realsize := realsize * rhs.data.intval;
	    END;
	    rhs := GenExpr (proc, tmp1, FALSE, Gen.StdRegs, own);
	    IF Op.IsError (rhs) THEN
	       Regs.DestroyOwnerOnError (proc.regs, own);
	       RETURN NIL;
	    END;
	    Regs.UntracedValue (reg, Gen.gensp);
            op := Op.MemOp1 (reg, 4, OA.VarOffset (param), 0);
	    CASE Op.Loc (rhs) OF
	    | Op.immediate, Op.immediateDyn, Op.register, Op.fpuRegister:
	       (* Note: We don't need delayed pointers here.
	        * a) The rhs might be an address or pointer but as we
		*    assign it to an array of byte this doesn't matter
		*    anymore.
		* b) The address of the temporary storage points to the
		*    stack which won't be moved by a GC.
		*)
               ASSERT((msize <= 4) OR ((msize = 8) & (attype.form = Sym.real)));
	       IF (attype.form = Sym.real) THEN
		  ASSERT(msize IN { 4, 8});
	          rhs := LoadFPUReg (proc, rhs, Sym.real, rhs.memsz, own);
	       END;
	       IF Op.Loc (rhs) = Op.register THEN
	          rhs.memsz := 4;
		  msize := 4;
	       ELSIF (Op.Loc (rhs) = Op.immediate) & (rhs.data.kind = Op.charConst) THEN
	          rhs := Op.ImmInt (ORD (rhs.data.charval));
		  msize := 4;
	       END;
	       IF attype.form = Sym.real THEN
		  I386FPURegisters.StoreReal (rhs.reg1, proc.s,
		  		Op.MemOp1 (reg, msize, stackspace, 0));
	       ELSE
		  Emit.Instr2 (proc.s, Pentium.MOV,
			       Op.MemOp1 (reg, msize, stackspace, 0), rhs);
	       END;
	       Emit.Instr2 (proc.s, Pentium.MOV, op, Op.ImmInt (stackspace));
	       Emit.Instr2 (proc.s, Pentium.ADD, op, Op.RegOp (reg, 4));
	       INC (op.disp, 4);
	       Emit.Instr2 (proc.s, Pentium.MOV, op, Op.ImmInt (realsize));
	       IF msize = 8 THEN
	          INC (stackspace, 8)
	       ELSE
	          INC (stackspace, 4);
	       END;
	       IF attype.form # Sym.real THEN
		  Regs.DestroyOwnedValue (rhs.reg1, own);
	       END;
	    | Op.memory:
	       Regs.CreateValue (reg2, proc.regs, own, Regs.addrM);
	       Regs.LoadReg (reg2, Gen.StdRegs);
	       rhs.memsz := 4;
	       Emit.Instr2 (proc.s, Pentium.LEA, Op.RegOp (reg2, 4), rhs);
	       Regs.DestroyOwnedValue (rhs.reg1, own);
	       Regs.DestroyOwnedValue (rhs.reg2, own);
	       NEW (dptr); dptr.next := dptrs; dptrs := dptr;
	       dptr.reg := reg2;
	       dptr.offset := OA.VarOffset (param);
	       ASSERT(dptr.offset = op.disp);
	       reg2 := NIL;
	       INC (op.disp, 4);
	       IF attype.dyn THEN
		  offset := 0;
		  tmp2 := tmp1;
		  WHILE tmp2.mode = Sym.indexAt DO
		     INC (offset);
		     tmp2 := tmp2.designator;
		  END;
		  ASSERT(tmp2.mode = Sym.varAt);
		  NEW (var);
		  var.mode := stackM;
		  var.ident := tmp2.ident;
		  rhs := GenVar (proc, var, FALSE, Gen.StdRegs, own);
		  rhs.disp := OA.SizesOffset (var.ident);
		  rhs.memsz := 4;
		  INC (rhs.disp, Ob32.int32Size*offset);
		  Regs.CreateValue (reg2, proc.regs, own, Regs.stdM);
		  Regs.LoadReg (reg2, Gen.StdRegs);
		  Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (reg2, 4), rhs);
		  Regs.DestroyOwnedValue (rhs.reg1, own);
		  Regs.DestroyOwnedValue (rhs.reg2, own);
		  Emit.Instr2 (proc.s, Pentium.MOV, op, Op.RegOp (reg2, 4));
		  Regs.DestroyOwnedValue (reg2, own);
		  reg2 := NIL;
	       ELSE
		  Emit.Instr2 (proc.s, Pentium.MOV, op, Op.ImmInt (realsize));
	       END;
	    END;
	 ELSIF (param.type.form = Sym.array) & ~param.type.dyn &
	       (param.type.element.form IN {Sym.char, Sym.byte}) &
	       ((tmp1.type.form IN {Sym.char, Sym.byte}) OR
	        (tmp1.mode IN {Sym.constAt, Sym.constvalAt})) THEN
	    (* This is inefficient, but nobody actually wants a fixed length
	     * array of CHAR/BYTE. *)
            Sym32.GetType (tmp1, attype);
	    msize := Sym32.GetSize (proc.module, attype, proc.errors);
	    rhs := GenExpr (proc, tmp1, TRUE, Gen.StdRegs, own);
	    IF Op.IsError (rhs) THEN
	       Regs.DestroyOwnerOnError (proc.regs, own);
	       RETURN NIL;
	    END;
	    Regs.UntracedValue (reg, Gen.gensp);
	    IF Op.Loc (rhs) IN {Op.immediate, Op.immediateDyn} THEN
	       ASSERT(rhs.data.kind = Op.charConst);
	       rhs := Op.ImmInt (ORD (rhs.data.charval));
	       Emit.Instr2 (proc.s, Pentium.MOV,
	                    Op.MemOp1 (reg, 4, stackspace, 0), rhs); 
	    ELSE
	       GenStringOp (proc, Pentium.MOVS, {Gen.rep},
	                    Op.MemOp1 (reg, 4, stackspace, 0),
			    rhs, Op.ImmInt (msize), 1, FALSE, own);
	    END;
            op := Op.MemOp1 (reg, 4, OA.VarOffset (param), 0);
	    (* No need for delayed pointers. See above. *)
	    IF stackspace > 0 THEN
	       Emit.Instr2 (proc.s, Pentium.MOV, op, Op.ImmInt (stackspace)); 
	       Emit.Instr2 (proc.s, Pentium.ADD, op, Op.RegOp (reg, 4));
	    ELSE
	       Emit.Instr2 (proc.s, Pentium.MOV, op, Op.RegOp (reg, 4));
	    END;
	    offset := Sym32.GetSize (proc.module, param.type, proc.errors);
	    IF offset > msize THEN
	       msize := offset;
	    END;
	    IF msize MOD 4 # 0 THEN
	       INC (msize, 4-msize MOD 4);
	    END;
	    ASSERT(msize MOD 4 = 0);
	    INC (stackspace, msize);
	 ELSE
	    attype := param.type;
	    msize := Sym32.GetSize (proc.module, attype, proc.errors);
	    Regs.UntracedValue (reg, Gen.gensp);
            op := Op.MemOp1 (reg, msize, OA.VarOffset (param), 0);
	    NEW(lop);
	    lop.op := op;
	    lop.type := attype;
	    lop.at := NIL;
	    lop.dptrs := NIL;
	    lop.needdptrs := TRUE;
	    lop.own := own;
	    GenAssignment (proc, lop, tmp1);
	    WHILE lop.dptrs # NIL DO
	       dptr := lop.dptrs;
	       lop.dptrs := dptr.next;
	       dptr.next := dptrs;
	       dptrs := dptr;
	    END;
	    Regs.DestroyOwnedValue (op.reg1, own);
	    Regs.DestroyOwnedValue (op.reg2, own);
	 END;
	 tmp1 := tmp1.next;
	 param := param.next;
      END;
      (* Ok. Now store all the pointers and addresses. *)
      Regs.UntracedValue (reg, Gen.gensp);
      WHILE dptrs # NIL DO
         Emit.Instr2 (proc.s, Pentium.MOV, Op.MemOp1 (reg, 4, dptrs.offset, 0),
	              Op.RegOp (dptrs.reg, 4));
	 Regs.DestroyOwnedValue (dptrs.reg, own);
	 dptrs := dptrs.next;
      END;
      ASSERT((param = NIL) & (tmp1 = NIL));
      (* Ok, we'll emit a call which might cause a garbage collection.
       * This means we must do  two things:
       * 1.) save all Registers to make sure that none of them contains
       *     a pointer that can be changed by a GC.
       * 2.) commit all TmpPtrs currently in flight.
       *)
      Regs.SaveAll (proc.regs);
      Regs.Foreach (proc.regs, RegCommit);
      fputop := proc.fpuregs.top;
      IF proc.fpuregs.top >= 0 THEN
	 Regs.UntracedValue (reg, Gen.genbp);
	 fpuoffset := StackAlloc.Allocate (proc.stack, 8*(1+proc.fpuregs.top), 4, FALSE);
	 I386FPURegisters.CreateValue (reg2, proc.fpuregs);
	 ops1[0] := Op.MemOp1 (reg, 8, fpuoffset, 0);
	 WHILE proc.fpuregs.top >= 0 DO
            reg2(I386FPURegisters.Value).freg := proc.fpuregs.top;
	    I386FPURegisters.StoreReal (reg2, proc.s, ops1[0]);
	    INC (ops1[0].disp, 8);
	    INC (fpuoffset, 8);
	 END;
      END;
      (* Do we know which procedure we are calling? *)
      IF stmt.proc.mode = Sym.procAt THEN
	 IF (stmt.proc.ident.module # NIL) &
	    (RealName (stmt.proc.ident.module) # RealName (proc.module)) THEN
	    NEW(ref);
	    ref.modname := RealName (stmt.proc.ident.module);
	    ref.symname := stmt.proc.ident.name;
	    Emit.CallExtern (proc.s, proc.regs, ref);
	 ELSE
	    (* Now walk up the backlink chain *)
	    lev := OA.ProcedureLevel (stmt.proc.ident);
	    (* There is no backlink if we call a global procedure *)
	    IF lev > 3 THEN
	       codelev := proc.level;
	       ASSERT(codelev >= lev-1);
	       Regs.UntracedValue (reg, Gen.genbp);
	       ops1[1] := Op.MemOp1 (reg, 4 (* addr *), 8 (* skip EIP and EBP *), 0);
	       reg2 := reg;
	       WHILE codelev > lev-1 DO
		  IF reg2 = reg THEN
		     Regs.CreateValue (reg2, proc.regs, own, Regs.stdM);
		     Regs.LoadReg (reg2, Gen.StdRegs);
		  END;
		  ops1[0] := Op.RegOp (reg2, 4);
		  Emit.Instr (proc.s, Pentium.MOV, 2, ops1);
		  DEC (codelev);
		  ops1[1] := Op.MemOp1 (reg2, 4 (*address*),
					8 (* skip old EBP and EIP*), 0);
	       END;
	       ops1[0] := Op.RegOp (reg2, 4);
	       Emit.Instr (proc.s, Pentium.PUSH, 1, ops1);
	       IF reg2 # reg THEN
		  Regs.DestroyOwnedValue (reg2, own);
		  reg2 := NIL;
	       END;
	    END;
	    l := OA.ProcedureLabel (stmt.proc.ident);
	    Emit.Call (proc.s, l);
	 END;
      ELSE
         op := GenExpr (proc, stmt.proc, FALSE, Gen.StdRegs, own);
	 IF Op.Loc (op) IN {Op.immediate, Op.immediateDyn} THEN
	    Regs.CreateValue (reg, proc.regs, own, Regs.stdM);
	    Regs.LoadReg (reg, Gen.StdRegs);
	    Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (reg, 4), op);
	    op := Op.RegOp (reg, 4);
	 END;
	 Emit.Instr1 (proc.s, Pentium.CALL, op);
	 Regs.DestroyOwnedValue (op.reg1, own);
	 Regs.DestroyOwnedValue (op.reg2, own);
      END;
      ASSERT(stackspace MOD 4 = 0);
      IF stackspace # 0 THEN
         (* The caller removes the backlink, we remove the rest of the
	  * stackspace. This allows variable length stack space allocations
	  * and makes Oberon signal handlers possible.
	  *)
         ASSERT(stackspace > 0);
	 FragmentedStreams.Create (tmps);
	 Regs.UntracedValue (reg, Gen.gensp);
	 Emit.Instr2 (tmps, Pentium.SUB, Op.RegOp (reg, 4),
		      Op.ImmInt (stackspace));
	 FragmentedStreams.Length (tmps, msize, msize);
	 ok := Streams.Seek (tmps, 0, Streams.fromStart); ASSERT(ok);
	 FragmentedStreams.SetObjectSize (stackalloc, msize);
	 FragmentedStreams.FixObject (stackalloc);
	 ok := Streams.Copy (tmps, proc.s, msize); ASSERT(ok);
	 ok := Streams.Seek (proc.s, 0, Streams.fromEnd); ASSERT(ok);
	 Emit.Instr2 (proc.s, Pentium.ADD, Op.RegOp (reg, 4),
		      Op.ImmInt (stackspace));
      ELSE
         FragmentedStreams.SetObjectSize (stackalloc, 0);
         FragmentedStreams.FixObject (stackalloc);
	 ok := Streams.Seek (proc.s, 0, Streams.fromEnd); ASSERT(ok);
      END;
      IF return # NIL THEN
         Regs.Chown (return, caller);
	 ASSERT(Regs.GetMode (return) = Regs.stdM);
         SetMode (return, stmt.proc.type.restype);
      END;
      IF fputop >= 0 THEN
         ASSERT(proc.fpuregs.top = -1);
	 Regs.UntracedValue (reg, Gen.genbp);
	 ops1[0] := Op.MemOp1 (reg, 8, fpuoffset, 0);
	 I386FPURegisters.CreateValue (reg2, proc.fpuregs);
	 WHILE proc.fpuregs.top < fputop DO
	    DEC (fpuoffset, 8);
	    DEC (ops1[0].disp, 8);
	    I386FPURegisters.PushReal (reg2, proc.s, ops1[0]);
	 END;
	 StackAlloc.Free (proc.stack, fpuoffset);
      END;
      IF (stmt.proc.type.restype # NIL) 
         & (stmt.proc.type.restype.form = Sym.real) THEN
	 Regs.UntracedValue (reg, Gen.genbp);
	 I386FPURegisters.CreateValue (return, proc.fpuregs);
	 I386FPURegisters.PushReal (return, proc.s,
	 			    Op.MemOp1 (reg, 8, retoffset, 0));
	 StackAlloc.Free (proc.stack, retoffset);
      END;
      RETURN return;
   END GenCall;

   PROCEDURE GenReturn (proc : PC.Context);
      VAR
	 ops : ARRAY 2 OF Op.Operand;
	 reg : Regs.Value;
	 dbdisc : Disciplines.Discipline;
	 ok : BOOLEAN;
	 paramsz : LONGINT;
   BEGIN
      ops[0] := NIL;
      Regs.UntracedValue (reg, Gen.gensp);
      ops[0] := Op.RegOp (reg, 4);
      Regs.UntracedValue (reg, Gen.genbp);
      ops[1] := Op.RegOp (reg, 4);
      Emit.Instr (proc.s, Pentium.MOV, 2, ops);
      ops[0] := ops[1];
      Emit.Instr (proc.s, Pentium.POP, 1, ops);
      IF (proc.ident.class = Sym.procedureC) THEN
         (* Note: The parameter block is removed by the caller.
	  * This is the same as the C calling convention which is used for
	  * signal handlers. *)
	 IF OA.ProcedureLevel (proc.ident) > 3 THEN
	    (* Local Procedure: We must remove the backlink *)
	    Emit.Instr1 (proc.s, Pentium.RETP, Op.ImmInt (4));
         ELSE
	    Emit.Instr (proc.s, Pentium.RET, 0, ops);
	 END;
      ELSE (* Initialization part of a module *)
         Emit.Instr (proc.s, Pentium.RET, 0, ops);
      END;
   END GenReturn;


   PROCEDURE GenStmt (proc : PC.Context; stmt : Sym.Attribute;
		      exitlab : FragmentedStreams.Label);
      VAR
	 context : BoolContext;
	 beyond, loopstart, loopend  : TrackedLabel;
	 tmp1, tmp2 : Sym.Attribute;
	 cases : Sym.Attribute;
	 caseblk, elseblk : CaseBlock;
	 ranges, tmp : CaseRange;
	 offset, val, i, count, sub, align : LONGINT;
	 bytes : INTEGER;
	 offsets : ARRAY 40 OF LONGINT;
	 tblstart, l : TrackedLabel;
	 start : CaseRange;
	 heap, tmptable : CaseTable;
	 tmpstmt : Sym.Attribute;
	 own : Regs.Owner;
	 op, op1, op2 : Op.Operand;
	 ops1, ops2 : ARRAY 2 OF Op.Operand;
	 symname : ConstStrings.String;
	 symstream : Streams.Stream;
	 debugsym : FragmentedStreams.Label;
	 ret : Op.Operand;
	 needfinaldist : BOOLEAN;
	 tagreg, reg, reg2 : Regs.Value;
	 param : Sym.ParamList;
	 ok : BOOLEAN;
	 lop : LeftOp;
	 msize : LONGINT;
	 lev, codelev : INTEGER;
	 ref : Relocations.SymRef;
	 var : VarDesc;

      PROCEDURE CollectCaseRanges (ranges : CaseRange; at : Sym.Attribute;
				   blk : CaseBlock);
	 VAR
	    op : Op.Operand;
	    left, right : LONGINT;
	    ok : BOOLEAN;
      BEGIN
	 (*
         ok := Streams.Flush (Streams.stdout); ASSERT(ok);
	 *)
	 IF at = NIL THEN
	    RETURN 
	 END;
	 IF (at.mode = Sym.binaryAt) & (at.opsy = Lex.comma) THEN
	    CollectCaseRanges (ranges, at.leftop, blk);
	    CollectCaseRanges (ranges, at.rightop, blk);
	 ELSIF (at.mode = Sym.binaryAt) & (at.opsy = Lex.range) THEN
	    op := GenExpr (proc, at.leftop, FALSE, {}, -1);
            IF Op.IsError (op) THEN
	       Regs.DestroyOwnerOnError (proc.regs, own);
	       RETURN
	    END;
	    IF ~(Op.Loc(op) IN {Op.immediate, Op.immediateDyn}) THEN
	       CompilerErrors.Raise (proc.errors, FixupLoc (at.leftop), 
				    "constant expression expected");
               Regs.DestroyOwnerOnError (proc.regs, own);
               RETURN;
	    END;
	    ASSERT(op.data # NIL);
	    CASE op.data.kind OF
	    | Op.integerConst:
	       left := op.data.intval;
            | Op.charConst:
	       left := ORD (op.data.charval);
            ELSE
	       CompilerErrors.Raise (proc.errors, FixupLoc (at.leftop), 
				    "integer or character constant expected");
               Regs.DestroyOwnerOnError (proc.regs, own);
               RETURN;
	    END;
	    op := GenExpr (proc, at.rightop, FALSE, {}, -1);
            IF Op.IsError (op) THEN
	       Regs.DestroyOwnerOnError (proc.regs, own);
	       RETURN
	    END;
	    IF ~(Op.Loc(op) IN {Op.immediate, Op.immediateDyn}) THEN
	       CompilerErrors.Raise (proc.errors, FixupLoc (at.rightop), 
				    "constant expression expected");
               Regs.DestroyOwnerOnError (proc.regs, own);
               RETURN;
	    END;
	    ASSERT(op.data # NIL);
	    CASE op.data.kind OF
	    | Op.integerConst:
	       right := op.data.intval;
            | Op.charConst:
	       right := ORD (op.data.charval);
            ELSE
	       CompilerErrors.Raise (proc.errors, FixupLoc (at.rightop), 
				    "integer or character constant expected");
               Regs.DestroyOwnerOnError (proc.regs, own);
               RETURN;
	    END;
	    AddCaseRange (ranges, left, right, blk, at, proc.errors);
	 ELSE
	    op := GenExpr (proc, at, FALSE, {}, -1);
            IF Op.IsError (op) THEN
	       Regs.DestroyOwnerOnError (proc.regs, own);
	       RETURN
	    END;
	    IF ~(Op.Loc(op) IN {Op.immediate, Op.immediateDyn}) THEN
	       CompilerErrors.Raise (proc.errors, FixupLoc (at), 
				    "constant expression expected");
               Regs.DestroyOwnerOnError (proc.regs, own);
               RETURN;
	    END;
	    CASE op.data.kind OF
	    | Op.integerConst:
	       left := op.data.intval;
            | Op.charConst:
	       left := ORD (op.data.charval);
            ELSE
	       CompilerErrors.Raise (proc.errors, FixupLoc (at), 
				    "integer or character constant expected");
               Regs.DestroyOwnerOnError (proc.regs, own);
               RETURN;
	    END;
	    AddCaseRange (ranges, left, left, blk, at, proc.errors);
	 END;
      END CollectCaseRanges;


      (* count is the actual number of ranges including the last one
       * that spans up to 0xFF, 0xFFFF or 0xFFFFFFFF. *)
      PROCEDURE BuildHeap (ranges : CaseRange; count : LONGINT; VAR elm : ARRAY OF LONGINT) : CaseTable;
	 VAR
	    tbl, new, last : CaseTable;
	    needterm, n, line, thiscount, height: LONGINT;
	    term : BOOLEAN;
	    start : CaseRange;

	 PROCEDURE Skip (start : CaseRange; n : LONGINT) : CaseRange;
	 BEGIN
	    WHILE n > 0 DO
	       IF start = NIL THEN
		  RETURN NIL;
	       END;
	       start := start.next;
	       DEC(n);
	    END;
	    RETURN start;
	 END Skip;

      BEGIN
         tbl := NIL;
	 (* Write.String ("BuildHeap count = "); Write.Int(count, 0); *)
	 NEW(tbl);
	 tbl.next := NIL;
	 n := 1;
	 line := 0;
	 needterm := count-1;
	 height := 0;
	 WHILE needterm # 0 DO
	    INC(height);
	    needterm := needterm DIV 2;
	 END;
	 tbl.val := height;
	 needterm := count-1;
	 line := height - 1;
	 WHILE line >= 0 DO
	    elm[line] := 0;
	    count := (count+1) DIV 2;
	    term := ~ODD(needterm);
	    needterm := needterm DIV 2;
	    thiscount := count;
	    IF term THEN
	       DEC(thiscount);
	    END;
	    ASSERT(thiscount > 0);
	    start := Skip (ranges, n);
	    last := tbl;
	    n := 2*n;
	    WHILE thiscount > 0 DO
	       ASSERT(start # NIL);
	       DEC(thiscount);
	       INC(elm[line]);
	       NEW(new);
	       new.val := start.last - ranges.first;
	       new.next := last.next;
	       last.next := new;
	       last := new;
	       start := Skip (start, n);
	    END;
	    IF term THEN
	       INC(elm[line]);
	       NEW(new);
	       new.val := -1;
	       new.next := last.next;
	       last.next := new;
	    END;
	    DEC(line);
	 END;
	 RETURN tbl
      END BuildHeap;

   BEGIN (* GenStmt *)
      beyond := NIL;
      ASSERT(stmt.mode IN Sym.stmtModes);
      ASSERT(proc.fpuregs.top = -1); (* DEBUG *)
      own := Regs.GetOwner(proc.regs);
      ConstStrings.Init (symstream);
      Write.StringS (symstream, "__");
      IF proc.ident.name # NIL THEN
	 ConstStrings.Write (symstream, proc.ident.name);
      ELSE
         Write.StringS (symstream, "BODY");
      END;
      Write.StringS (symstream, "_");
      Write.IntS (symstream, stmt.loc.begin, 0);
      Write.StringS (symstream, "_");
      Write.IntS (symstream, stmt.loc.end, 0);
      ConstStrings.Close (symstream, symname);
      FragmentedStreams.CreateLabel (debugsym);
      FragmentedStreams.AttachLabel (proc.s, debugsym);
      Relocations.NewSymbol (proc.s, symname, debugsym);
      CASE stmt.mode OF
      | Sym.ifAt:
         NEW(context);
	 context.target := NIL;
	 context.setaction := setNever;
	 context.truelab := NIL;
	 context.neg := FALSE;
         CreateLabel (context.falselab, "GenStmt: ifat falselab", stmt.loc, proc.s);
	 IF (stmt.else # NIL) OR (stmt.elsifs # NIL) THEN
	    CreateLabel (beyond, "GenStmt: ifat beyond", stmt.loc, proc.s);
	 END;
	 GenBool (proc, stmt.expression, context);
	 Regs.EnterLevel (proc.regs);
	 tmp1 := stmt.then;
	 WHILE tmp1 # NIL DO
	    GenStmt (proc, tmp1, exitlab);
	    tmp1 := tmp1.next;
	 END;
	 Regs.LeaveLevel (proc.regs);
	 Regs.DoneLevel (proc.regs);
	 IF (stmt.else # NIL) OR (stmt.elsifs # NIL) THEN
	    Emit.Jump (proc.s, beyond);
	 END;
	 FragmentedStreams.AttachLabel (proc.s, context.falselab);
	 tmp2 := stmt.elsifs;
	 WHILE tmp2 # NIL DO
	    context.target := NIL;
	    context.setaction := setNever;
	    context.truelab := NIL;
	    context.neg := FALSE;
            CreateLabel (context.falselab, "GenStmt: elsif falselab", tmp2.loc, proc.s);
	    GenBool (proc, tmp2.expression, context);
	    Regs.EnterLevel (proc.regs);
	    tmp1 := tmp2.then;
	    WHILE tmp1 # NIL DO
	       GenStmt (proc, tmp1, exitlab);
	       tmp1 := tmp1.next;
	    END;
	    Regs.LeaveLevel (proc.regs);
	    Regs.DoneLevel (proc.regs);
	    IF (stmt.else # NIL) OR (tmp2.next # NIL) THEN
	       Emit.Jump (proc.s, beyond);
	    END;
	    FragmentedStreams.AttachLabel (proc.s, context.falselab);
	    tmp2 := tmp2.next;
	 END;
	 IF stmt.else # NIL THEN
	    Regs.EnterLevel (proc.regs);
	    tmp1 := stmt.else;
	    WHILE tmp1 # NIL DO
	       GenStmt (proc, tmp1, exitlab);
	       tmp1 := tmp1.next;
	    END;
	    Regs.LeaveLevel (proc.regs);
	    Regs.DoneLevel (proc.regs);
	 END;
	 IF beyond # NIL THEN
	    FragmentedStreams.AttachLabel (proc.s, beyond);
	 END;
      | Sym.caseAt:
	 (* Process CASE labels *)
	 cases := stmt.cases;
	 i := 0;
	 NEW(ranges);
	 ranges.next := NIL;
	 ranges.prev := NIL;
	 WHILE cases # NIL DO
	    ASSERT(cases.mode = Sym.singleCaseAt);
	    NEW(caseblk);
	    caseblk.at := cases;
	    caseblk.id := i;
	    caseblk.done := FALSE;
	    CreateLabel (caseblk.lab, "GenStmt: CASE caseblk", caseblk.at.loc, proc.s);
	    INC(i);
	    CollectCaseRanges (ranges, cases.labels, caseblk);
	    cases := cases.next;
	 END;
	 CreateLabel (tblstart, "casetable", stmt.loc, proc.s);
	 (* Road map
	  *   - Build tree in memory and calculate offsets for each line
	  *   - Generate expression and optimize if constant
	  *   - Emit code to find the destination
	  *   - Emit table aligned to a 32 bit boundary
	  *   - Emit case blocks
	  *)
         NEW(elseblk);
	 elseblk.id := -1;
	 (* We'll always pretend to have an else block. If there is none
	  * we need it to generate generate runtime errors. If the else
	  * block is empty the label is equal to beyond. *)
	 elseblk.at := stmt.else;
         elseblk.done := FALSE;
	 CreateLabel (elseblk.lab, "GenStmt: CASE else", stmt.loc, proc.s);
	 CreateLabel (beyond, "GenStmt: CASE beyond", stmt.loc, proc.s);
         tmp := ranges.next;
	 IF tmp = NIL THEN
	    CompilerErrors.Raise (proc.errors, stmt.loc, "no case labels defined");
            Regs.DestroyOwnerOnError (proc.regs, own);
	    RETURN;
	 END;
	 count := 0;
	 start := NIL;
	 WHILE tmp.next # NIL DO
	    INC(count);
	    IF tmp.first = 0 THEN
	       start := tmp;
	    END;
	    IF tmp.last + 1 # tmp.next.first THEN
	       AddCaseRange (ranges, tmp.last + 1, tmp.next.first - 1, elseblk, NIL, proc.errors);
	    END;
	    tmp := tmp.next;
	 END;
	 INC(count);  (* The last element on the list. *)
	 (* Using as few bytes as possible for each table entry will
	  * (hopfully) increase Level1 Cache performance. *)
	 sub := ranges.first;
         IF ranges.last - ranges.first < 256 THEN
	    bytes := 1;
	    IF (ranges.last - ranges.first) # 255 THEN
	       INC(count);
	    END;
	 ELSIF ranges.last - ranges.first < 256*256 THEN
	    IF (ranges.last - ranges.first) # 256*256-1 THEN
	       INC(count);
	    END;
	    bytes := 2;
	 ELSE
	    IF (ranges.last - ranges.first) # -1 THEN
	       INC(count);
	    END;
	    bytes := 4;
	 END;
	 heap := BuildHeap (ranges, count, offsets);
	 i := 1;
	 WHILE i < heap.val DO
	    INC(offsets[i], offsets[i-1]);
	    INC(i);
	 END;
	 DEC(i);
	 align := 0;
	 IF (bytes * offsets[i]) MOD 4 # 0 THEN
	    align := 4 - (bytes * offsets[i]) MOD 4;
	 END;
	 (* Code Generation starts here *)
	 (* Save all registers. Register management is close to impossible
	  * with the current setup and loaded registers here.
	  * Each case block is entered with a clear register set. *)
         Regs.SaveAll (proc.regs);
	 Regs.EnterLevel (proc.regs);  (* Just to be sure *)
         op := GenExpr (proc, stmt.expression, TRUE, Gen.StdRegs, own);
         IF Op.IsError (op) THEN
	    Regs.DestroyOwnerOnError (proc.regs, own);
	    Regs.LeaveLevel (proc.regs);
	    Regs.DoneLevel (proc.regs);
	    RETURN
	 END;
	 IF Op.Loc(op) IN {Op.immediate, Op.immediateDyn} THEN
	    caseblk := elseblk;
	    tmp := ranges.next;
	    LOOP
	       IF tmp = NIL THEN
		  EXIT;
	       END;
	       sub := op.data.intval;
	       IF (tmp.first <= sub) & (sub <= tmp.last) THEN
		  caseblk := tmp.block;
		  EXIT;
	       END;
	       tmp := tmp.next;
	    END;
	    IF caseblk.id = -1 THEN
	       tmp1 := caseblk.at;
            ELSE
               tmp1 := caseblk.at.body;
	    END;
	    IF (caseblk.id = -1) & ~stmt.haselse THEN
	       ASSERT(tmp1 = NIL);
	       Regs.EnterLevel (proc.regs);
	       EmitErrors.CaseError (proc, stmt.loc);
	       Regs.LeaveLevel (proc.regs);
	       Regs.DoneLevel (proc.regs);
	    ELSE
	       WHILE tmp1 # NIL DO
	          GenStmt (proc, tmp1, exitlab);
		  tmp1 := tmp1.next;
	       END;
	    END;
	    (* No need to destroy anything! Expression is constant *)
	 ELSE
	    ASSERT(Op.Loc(op) = Op.register);
            (* This might have been of type address but from now on it
             * is ok for the garbage collection to ignore it. *)
            Regs.SetMode (op.reg1, Regs.stdM);
	    IF sub # 0 THEN
	       op1 := Op.ImmInt (sub);
	       ops1[0] := op;
	       ops1[1] := op1;
	       Emit.Instr (proc.s, Pentium.SUB, 2, ops1);
            END;
	    ASSERT(bytes <= op.memsz);
	    ConstStrings.Init (symstream);
	    Write.StringS (symstream, "__CASETABLE_");
	    Write.IntS (symstream, PC.Unique (proc), 0);
	    ConstStrings.Close(symstream, symname);
	    Relocations.NewSymbol (proc.s, symname, tblstart);
	    op2 := GenSymVal (proc, Gen.StdRegs, NIL, symname, own, TRUE);
            IF Op.IsError (op2) THEN
	       Regs.DestroyOwnerOnError (proc.regs, own);
	       Regs.LeaveLevel (proc.regs);
	       Regs.DoneLevel (proc.regs);
	       RETURN
	    END;
	    ASSERT(Op.Loc (op2) = Op.register);
	    op2 := Op.MemOp1 (op2.reg1, 4, 0, 0);
	    needfinaldist := TRUE;
	    IF bytes < op.memsz THEN
	       ops1[0] := op;
	       val := ranges.last - ranges.first;
	       ops1[1] := Op.ImmInt (val);
	       Emit.Instr (proc.s, Pentium.CMP, 2, ops1);
	       Emit.JumpCC (proc.s, elseblk.lab, Pentium.JA-Pentium.JCC);
	       needfinaldist := FALSE;
	       op.memsz := bytes;
	    END;
            (* This will actually hold an address but this address
             * points to a fixed location in the executable. *)
	    Regs.CreateValue (reg, proc.regs, own, Regs.stdM);
	    Regs.LoadReg (reg, Gen.StdRegs);
	    op1 := Op.RegOp (reg, 4 (*address*));
	    op2.reg2 := reg;
	    Op.SetScale (op2, bytes);
	    op2.memsz := bytes;
	    ops1[0] := op1;
	    ops1[1] := op1;
	    (* Clear the index register *)
	    Emit.Instr (proc.s, Pentium.XOR, 2, ops1);
	    i := 0;
	    ops1[0] := op2; ops1[1] := op;
	    ops2[0] := op1; ops2[1] := op1;
	    WHILE i < heap.val DO
	       Emit.Instr (proc.s, Pentium.CMP, 2, ops1);
	       Emit.Instr (proc.s, Pentium.ADC, 2, ops2);
	       op2.disp := bytes * offsets[i];
	       INC(i);
	    END;
	    INC(op2.disp, align);
	    ops1[0] := Op.RegOp (ops1[0].reg1, 4 (*address*));
	    ops1[1] := op2;
	    op2.memsz := 4;
	    Op.SetScale (op2, 4 (* Last line: addresses *));
	    Emit.Instr (proc.s, Pentium.ADD, 2, ops1);
	    Emit.Instr (proc.s, Pentium.JMP, 1, ops1);
	    Regs.DestroyOwnedValue (op.reg1, own);
	    Regs.DestroyOwnedValue (op2.reg1, own);
	    Regs.DestroyOwnedValue (op2.reg2, own);
	    Emit.Align (proc.s, 32 (* Level one cache line size *));
	    FragmentedStreams.AttachLabel (proc.s, tblstart);
            tmptable := heap.next;
	    WHILE tmptable # NIL DO
	       Emit.Bytes (proc.s, tmptable.val, bytes);
	       tmptable := tmptable.next;
            END;
	    Emit.Bytes (proc.s, 0, align);
	    tmp := ranges.next;
	    WHILE tmp # NIL DO
	       Emit.Distance (proc.s, tblstart, tmp.block.lab);
	       tmp := tmp.next;
	    END;
	    IF needfinaldist THEN
	       (* This case is caught by the size comparison above if
		* bytes # op.memsz *)
	       Emit.Distance (proc.s, tblstart, elseblk.lab);
	    END;
            (* BEGIN DEBUG *)
            	Emit.Instr (proc.s, Pentium.NOP, 0, ops1);
            	Emit.Instr (proc.s, Pentium.NOP, 0, ops1);
            	Emit.Instr (proc.s, Pentium.NOP, 0, ops1);
            	Emit.Instr (proc.s, Pentium.NOP, 0, ops1);
            	Emit.Instr (proc.s, Pentium.NOP, 0, ops1);
            	Emit.Instr (proc.s, Pentium.NOP, 0, ops1);
            	Emit.Instr (proc.s, Pentium.NOP, 0, ops1);
            	Emit.Instr (proc.s, Pentium.NOP, 0, ops1);
            	Emit.Instr (proc.s, Pentium.NOP, 0, ops1);
            (* END DEBUG *)
	    tmp := ranges.next;
	    WHILE tmp # NIL DO
	       IF ~tmp.block.done & (tmp.block.id # -1) THEN
	          tmp1 := tmp.block.at.body;
	          FragmentedStreams.AttachLabel (proc.s, tmp.block.lab);
		  Regs.EnterLevel (proc.regs);
	          WHILE tmp1 # NIL DO
	             GenStmt (proc, tmp1, exitlab);
		     tmp1 := tmp1.next;
	          END;
	          tmp.block.done := TRUE;
		  Regs.LeaveLevel (proc.regs);
		  Regs.DoneLevel (proc.regs);
		  Emit.Jump (proc.s, beyond);
               END;
	       tmp := tmp.next
	    END;
	    ASSERT(~elseblk.done);
	    Regs.EnterLevel (proc.regs);
	    FragmentedStreams.AttachLabel (proc.s, elseblk.lab);
	    IF stmt.haselse THEN
	       tmp1 := elseblk.at;
	       WHILE tmp1 # NIL DO
	          GenStmt (proc, tmp1, exitlab);
		  tmp1 := tmp1.next;
	       END;
	       elseblk.done := TRUE;
	    ELSE
	       Regs.EnterLevel (proc.regs);
	       EmitErrors.CaseError (proc, stmt.loc);
	       Regs.LeaveLevel (proc.regs);
	       Regs.DoneLevel (proc.regs);
	    END;
	    Regs.LeaveLevel (proc.regs);
	    Regs.DoneLevel (proc.regs);
         END;
	 FragmentedStreams.AttachLabel (proc.s, beyond);
	 (* Shouldn't generate code. If it does at least one case block
	  * screwed registers *)
	 Regs.LeaveLevel (proc.regs);
	 Regs.DoneLevel (proc.regs);
      (* | Sym.singleCaseAt: See caseAt *)
      | Sym.whileAt:
	 NEW(context);
	 context.target := NIL;
	 context.setaction := setNever;
	 context.truelab := NIL;
	 context.neg := FALSE;
         CreateLabel (context.falselab, "GenStmt: whileAt falselab", stmt.loc, proc.s);
	 CreateLabel (loopstart, "GenStmt: whileAt loopstart", stmt.loc, proc.s);
	 FragmentedStreams.AttachLabel (proc.s, loopstart);
	 GenBool (proc, stmt.expression, context);
	 Regs.EnterLevel (proc.regs);
         tmp1 := stmt.body;
	 WHILE tmp1 # NIL DO
	    GenStmt (proc, tmp1, exitlab);
	    tmp1 := tmp1.next;
	 END;
	 Regs.LeaveLevel (proc.regs);
	 Regs.DoneLevel (proc.regs);
	 Emit.Jump (proc.s, loopstart);
	 FragmentedStreams.AttachLabel (proc.s, context.falselab);
      | Sym.repeatAt:
	 NEW(context);
	 context.target := NIL;
	 context.setaction := setNever;
	 context.truelab := NIL;
	 context.neg := FALSE;
         CreateLabel (context.falselab, "GenStmt: repeatAt falselab", stmt.loc, proc.s);
	 FragmentedStreams.AttachLabel (proc.s, context.falselab);
	 Regs.EnterLevel (proc.regs);
         tmp1 := stmt.body;
	 WHILE tmp1 # NIL DO
	    GenStmt (proc, tmp1, exitlab);
	    tmp1 := tmp1.next;
	 END;
	 Regs.LeaveLevel (proc.regs);
	 Regs.DoneLevel (proc.regs);
	 GenBool (proc, stmt.expression, context);
      | Sym.loopAt:
	 CreateLabel (loopstart, "GenStmt: LOOP loopstart", stmt.loc, proc.s);
         FragmentedStreams.AttachLabel (proc.s, loopstart);
	 CreateLabel (loopend, "GenStmt: LOOP loopend", stmt.loc, proc.s);
	 tmp1 := stmt.body;
	 WHILE tmp1 # NIL DO
	    GenStmt (proc, tmp1, loopend);
	    tmp1 := tmp1.next;
	 END;
	 Emit.Jump (proc.s, loopstart);
	 FragmentedStreams.AttachLabel (proc.s, loopend);
      | Sym.exitAt:
	 ASSERT(exitlab # NIL);
	 Regs.SaveAll (proc.regs);
	 Emit.Jump (proc.s, exitlab);
      | Sym.returnAt:
	 IF proc.ident.type.restype # NIL THEN
	    offset := OA.ResOffset (proc.ident.type);
	    INC(offset, 8);  (* old ebp and eip *)
	    IF proc.level > 3 THEN
	       INC(offset, 4);  (* backlink *)
	    END;
	    Regs.CreateValue (reg, proc.regs, own, Regs.addrM);
	    Regs.LoadReg (reg, Gen.StdRegs);
	    ops1[0] := Op.RegOp (reg, 4);
	    Regs.UntracedValue (reg, Gen.genbp);
	    ops1[1] := Op.MemOp1 (reg, 4, offset, 0);
	    Emit.Instr (proc.s, Pentium.MOV, 2, ops1);
	    msize := Sym32.GetSize (proc.module, proc.ident.type.restype, proc.errors);
	    IF proc.ident.type.restype.form IN {Sym.integer, Sym.cardinal,
	       Sym.address} THEN
	       msize := 4;
	    END;
	    IF proc.ident.type.restype.form = Sym.real THEN
	       msize := 8;
	    END;
	    ops1[0] := Op.MemOp1 (ops1[0].reg1, msize, 0, 0);
	    NEW(lop);
            lop.op := ops1[0];
	    lop.type := proc.ident.type.restype;
	    lop.dptrs := NIL;
	    lop.needdptrs := FALSE;
	    GenAssignment (proc, lop, stmt.expression);
	    Regs.DestroyOwnedValue (lop.op.reg1, own);
         END;
	 I386Regs.IncludeRestoreBlock (proc.regs);
	 GenReturn (proc);
      | Sym.withAt:
         IF stmt.variable.type.form = Sym.pointer THEN
	    ASSERT(stmt.variable.type.taggedptr);
	    NEW (var);
	    var.ident := stmt.variable;
	    var.mode := identM;
	    var.type := stmt.variable.type;
	    op := GenVar (proc, var, TRUE, Gen.StdRegs, own); 
	    ASSERT((op.reg1 # NIL) & (op.reg2 = NIL));
	    Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (op.reg1, 4),
	                 Op.MemOp1 (op.reg1, 4, -4, 0));
	    tagreg := op.reg1;
            Regs.SetMode (tagreg, Regs.stdM);
	    GenTypes.TypeGuard (proc, tagreg, stmt.type, NIL, stmt.loc);
	    GenTypes.SetTmpTag (stmt.variable, tagreg);
	 ELSE
	    ASSERT((stmt.type.form = Sym.record) &
	            (stmt.variable.varkind = Sym.refParam));
	    NEW (var);
	    var.ident := stmt.variable;
	    var.mode := stackM;
	    op := GenVar (proc, var, FALSE, Gen.StdRegs, own);
	    INC (op.disp, 4);
	    Regs.CreateValue (tagreg, proc.regs, own, Regs.stdM);
	    Regs.LoadReg (tagreg, Gen.StdRegs);
	    Emit.Instr2 (proc.s, Pentium.MOV, Op.RegOp (tagreg, 4), op);
	    Regs.DestroyOwnedValue (op.reg1, own);
	    Regs.DestroyOwnedValue (op.reg2, own);
	    GenTypes.TypeGuard (proc, tagreg, stmt.type, NIL, stmt.loc);
	    GenTypes.SetTmpTag (stmt.variable, tagreg);
	 END;
	 tmp1 := stmt.body;
	 WHILE tmp1 # NIL DO
	    GenStmt (proc, tmp1, exitlab);
	    tmp1 := tmp1.next;
	 END;
	 tagreg := GenTypes.RemoveTmpTag (stmt.variable);
         Regs.DestroyOwnedValue (tagreg, own);
      | Sym.callAt:
	 IF stmt.proc.type.builtin THEN
	    ret := I386BuiltIns.GenBuiltIn (proc, stmt, {}, -1);
            ASSERT(ret = NIL);
	 ELSE
	    reg := GenCall (proc, stmt, own);
	    ASSERT(reg = NIL);
	 END;
      | Sym.binaryAt:
         ASSERT(stmt.mode = Sym.binaryAt);
         ASSERT(stmt.opsy = Lex.becomes);
	 NEW(lop);
	 lop.op := NIL;
	 lop.at := stmt.leftop;
	 lop.dptrs := NIL;
	 lop.needdptrs := FALSE;
	 Sym32.GetType (stmt.leftop, lop.type);
         GenAssignment (proc, lop, stmt.rightop);
      END;
   END GenStmt;


   PROCEDURE GenBody (proc : PC.Context);
      VAR
         stmt : Sym.Attribute;
	 regs : Regs.RegSet;
	 i : Regs.Register;
	 reg : Regs.Value;
	 ops : ARRAY 3 OF Op.Operand;
	 src, dst, cxop, dope, sizes : Op.Operand;
	 dbdisc, vardisc : Disciplines.Discipline;
	 ok : BOOLEAN;
	 align, offset, add, msize, paramsz, local : LONGINT;
	 param : Sym.ParamList;
	 dim : INTEGER;
	 type : Sym.Type;
	 var : VarDesc;
	 ident : Sym.Ident;
	 own : Regs.Owner;
	 stack : I386StackAlloc.Stack;

   BEGIN
      stmt := NIL;
      proc.level := 1;
      IF proc.ident.class = Sym.procedureC THEN
         proc.level := OA.ProcedureLevel (proc.ident);
      END;
      GenTypes.BlockStart (proc, proc.ident.type);
      Regs.UntracedValue (reg, Gen.genbp);
      ops[0] := Op.RegOp (reg, 4);
      Emit.Instr (proc.s, Pentium.PUSH, 1, ops);
      Regs.UntracedValue (reg, Gen.gensp);
      ops[1] := Op.RegOp (reg, 4);
      Emit.Instr (proc.s, Pentium.MOV, 2, ops);
      ASSERT(proc.ident.class IN {Sym.procedureC, Sym.moduleC});
      I386StackAlloc.Create (stack, proc.s, 0, 4, StackAlloc.growsdown);
      proc.stack := stack;
      local := 0;
      IF proc.ident.class = Sym.procedureC THEN
	 local := OA.DataBlockSize (NIL, proc.ident.scope, NIL);
	 align := OA.DataBlockAlign (proc.ident.scope);
	 IF align >= 4 THEN
	    align := 4;   (* XXXX This needs more work. *)
	 END;
	 ASSERT(align <= 4);
	 IF local > 0 THEN
	    offset := StackAlloc.Allocate (proc.stack, local, align, TRUE);
	 END;
      END;
      I386Regs.Create (regs, proc.stack, proc.s);
      proc.regs := regs;
      I386FPURegisters.Create (proc.fpuregs);
      (* This EnterLevel/LeaveLevel pair makes sure that we notice leaking
       * registers sooner or later. *)
      Regs.EnterLevel (proc.regs);
      own := Regs.GetOwner (proc.regs);
      IF proc.ident.class = Sym.procedureC THEN
         (* Initialize local pointers on the stack. This makes sure
	  * that the GC doesn't stumble over them. *)
	 GenTypes.InitLocalPointers (proc, proc.ident);
         (* Make local copies of all structures that should be passed by
	  * value but are passed by reference. *)
         param := proc.ident.type.paramlist;
	 WHILE param # NIL DO
	    IF (param.type.form = Sym.array) &
	       (param.type.dyn OR (param.paramkind = Sym.valueParam)) THEN
	       (* First fill the sizes array if the array is dynamic. *)
	       IF param.type.dyn THEN
		  dim := 0; type := param.type;
		  WHILE type.dyn DO
		     type := type.element;
		     INC(dim);
		  END;
		  msize := Sym32.GetSize (proc.module, type, proc.errors);
		  NEW(var);
		  var.mode := stackM;
		  var.ident := OA.ParamIdent (param);
		  dope := GenVar (proc, var, FALSE, Gen.StdRegs, own);
		  sizes := Op.Dup (dope);
		  sizes.disp := OA.SizesOffset (var.ident);
		  INC (dope.disp, Ob32.pointerSize+dim*Ob32.int32Size);
		  INC (sizes.disp, (dim+1)*Ob32.int32Size);
		  Regs.CreateValue (reg, proc.regs, own, Regs.stdM);
		  Regs.LoadReg (reg, {Gen.gencx});
		  Regs.AddConstraint (reg, {Gen.gencx});
		  cxop := Op.RegOp (reg, 4 (* LONGINT *));
		  ops[0] := cxop;
		  ops[1] := Op.ImmInt (msize);
		  Emit.Instr (proc.s, Pentium.MOV, 2, ops);
		  WHILE dim > 0 DO
		     DEC(dope.disp, Ob32.int32Size);
		     DEC(sizes.disp, Ob32.int32Size);
		     ops[1] := cxop;
		     ops[0] := sizes;
		     Emit.Instr (proc.s, Pentium.MOV, 2, ops);
		     ops[0] := cxop;
		     ops[1] := dope;
		     Emit.Instr (proc.s, Pentium.MUL, 2, ops);
		     DEC(dim);
		  END;
		  DEC (sizes.disp, Ob32.int32Size);
		  ops[0] := sizes;
		  ops[1] := cxop;
		  Emit.Instr (proc.s, Pentium.MOV, 2, ops);
		  DEC (dope.disp, Ob32.pointerSize);
		  (* The sizes array is filled and the total size of bytes
		   * we want to copy is in cxop. *)
		  IF param.paramkind = Sym.refParam THEN
		     (* We are done with this array. Just free all
		      * used registers. *)
		     Regs.DestroyOwnedValue (cxop.reg1, own);
		     Regs.DestroyOwnedValue (dope.reg1, own);
		     Regs.DestroyOwnedValue (dope.reg2, own);
		  END;
               ELSIF param.paramkind = Sym.valueParam THEN
	          (* We'll have to copy the array data. Make sure
		   * that dope and cxop contain the same information as
		   * above. *)
                  NEW (var);
		  var.mode := stackM;
		  var.ident := OA.ParamIdent (param);
		  dope := GenVar (proc, var, FALSE, Gen.StdRegs, own);
		  msize := Sym32.GetSize (proc.module, param.type, proc.errors);
		  cxop := Op.ImmInt (msize);
	       END;
	       (* If we deal with a value parameter copy the data. *)
               IF param.paramkind = Sym.valueParam THEN
		  (* Load the pointer to the data into gensi *)
		  Regs.CreateValue (reg, proc.regs, own, Regs.stdM);
		  Regs.LoadReg (reg, {Gen.gensi});
		  src := Op.RegOp (reg, 4 (* pointer *));
		  ops[0] := src;
		  ops[1] := dope;
		  Emit.Instr (proc.s, Pentium.MOV, 2, ops);
		  (* Allocate Stack Space for the copy and align the
		   * stack pointer on a 4 byte boundary *)
		  CASE Op.Loc (cxop) OF
		  | Op.immediate, Op.immediateDyn:
		     add := 0;
		     IF cxop.data.intval MOD 4 # 0 THEN
		        add := 4 - cxop.data.intval MOD 4;
			INC(cxop.data.intval, add);
		     END;
		     offset := StackAlloc.Allocate (proc.stack,
		                                    cxop.data.intval, 4, TRUE);
		     (* NOTE: This is subtle: Anyone calling this procedure
		      * will call OA.VarOffset for the parameter. We
		      * only change the offset assigned to the identifier. *)
		     OA.SetVarOffset (var.ident, offset);
		     DEC(cxop.data.intval, add);
		     Regs.UntracedValue (reg, Gen.genbp);
		     ASSERT(offset <= 0);
		     ops[1] := Op.MemOp1 (reg, 4, offset, 0);
		  | Op.register:
		     Regs.UntracedValue (reg, Gen.gensp);
		     ops[0] := Op.RegOp (reg, 4);
		     ops[1] := cxop;
		     Emit.Instr (proc.s, Pentium.SUB, 2, ops);
		     IF msize MOD 4 # 0 THEN
		        ops[1] := Op.ImmInt (-4);
			Emit.Instr (proc.s, Pentium.AND, 2, ops);
		     END;
		     (* Store the new address on the stack *)
		     ops[0] := dope;
		     ops[1] := Op.RegOp (reg, 4);
		     Emit.Instr (proc.s, Pentium.MOV, 2, ops);
		     ops[1] := Op.MemOp1 (reg, 4, 0, 0);
		  END;
		  (* Now we are done with dope! The old value is in src. *)
		  Regs.DestroyOwnedValue (dope.reg1, own);
		  Regs.DestroyOwnedValue (dope.reg2, own);
		  Regs.CreateValue (reg, proc.regs, own, Regs.addrM);
		  Regs.LoadReg (reg, {Gen.gendi});
		  ops[0] := Op.RegOp (reg, 4 (* address *));
		  (* ops[1] is %esp *)
		  Emit.Instr (proc.s, Pentium.LEA, 2, ops);
		  dst := Op.MemOp1 (reg, 1, 0, 0);
		  src := Op.MemOp1 (src.reg1, 1, 0, 0);
                  GenStringOp (proc, Pentium.MOVS, {Gen.rep},
		               dst, src, cxop, 1, FALSE, own);
                  (* No need to destroy registers. GenStringOp will do
		   * this for us. *)
	       END;
	    ELSE
	       (* Nothing. Records might become special some day as well. *)
	    END;
	    param := param.next;
	 END;
      END;
      stmt := proc.ident.body;
      WHILE (stmt # NIL) DO
         GenStmt (proc, stmt, NIL);
         stmt := stmt.next;
      END;
      Regs.LeaveLevel (proc.regs);
      Regs.DoneLevel (proc.regs);
      I386Regs.IncludeRestoreBlock (regs);
      StackAlloc.Close (stack);
      I386Regs.Close (regs);
      I386StackAlloc.Close (stack);
      IF (proc.ident.class = Sym.procedureC) &
         (proc.ident.type.restype # NIL) THEN
	 Regs.EnterLevel (proc.regs);
	 (* XXX Location is wrong!*)
	 EmitErrors.NoReturn (proc, proc.ident.loc);
	 Regs.LeaveLevel (proc.regs);
	 Regs.DoneLevel (proc.regs);
      ELSE
         GenReturn (proc);
      END;
      GenTypes.BlockEnd (proc, proc.ident.type);
   END GenBody;


   PROCEDURE GenProcs (proc : PC.Context; scope, export : Scopes.Scope);
      VAR
         it : Iterators.Iterator;
         ident, dummy : Sym.Ident;
	 ok : BOOLEAN;
	 l : FragmentedStreams.Label;
	 obj : Disciplines.Object;
   BEGIN
      it := NIL;
      Scopes.GetIterator (scope, it);
      WHILE Iterators.Get (it, ident) DO
         IF ident.class = Sym.procedureC THEN
            Emit.Align (proc.s, 32);   (* L1 Cache alignment *)
	    l := OA.ProcedureLabel (ident);
	    FragmentedStreams.AttachLabel (proc.s, l);
	    IF (export # NIL) & Scopes.Lookup (export, ident.name, dummy) THEN
	       IF dummy = ident THEN
		  (* Exported Procedure. Generate symbol. *)
		  Relocations.NewSymbol (proc.s, ident.name, l);
	       END;
	    ELSIF OA.ProcedureLevel (ident) = 3 THEN
	       (* Global Procedure. We might need a symbol if the Procedure
	        * is assigned to a variable. *)
	       Relocations.NewSymbol (proc.s, ident.name, l);
            END;
	    proc.ident := ident;
	    (* Write.String ("PROC ENTER ");
	       ConstStrings.Write (Streams.stdout, ident.name);
	       Write.Ln;
	    *)
	    GenBody (proc);
	    (* Write.String ("PROC LEAVE");
	       Write.Ln;
	    *)
	    GenTypes.GenTagForBlock (proc, proc.ident);
         END;
	 IF ident.scope # NIL THEN
	    GenProcs (proc, ident.scope, NIL);
         END;
      END;
      it := NIL;
   END GenProcs;

   PROCEDURE GenModule (res : Res.Result; module : Sym.Ident;
			errors : RelatedEvents.Object) : BOOLEAN;
      VAR
         datablk  : Res.Block;
         codeblk  : Res.Block;
	 roblk    : Res.Block;
	 typeblk  : Res.Block;
	 sym : ConstStrings.String;
	 s : FragmentedStreams.Stream;
	 start, l : TrackedLabel;
	 endlab : FragmentedStreams.Label;
	 dummy : Streams.Count;
	 rodata : Emit.StrTable;
	 rostream : Streams.Stream;
	 proc : PC.Context;
	 ok : BOOLEAN;
	 ref : Relocations.SymRef;
	 (* Module initialization *)
	    initblk  : Res.Block;
	    it : Iterators.Iterator;
	    reg : Regs.Value;
	    off : LONGINT;
	    key : CompilerKeys.Key;
	 (* End Module initialization *)

   BEGIN
      ASSERT(module.class = Sym.moduleC);
      (* BEGIN Module init block *)
         FragmentedStreams.Create (s);
	 Res.AddBlock (res, {Res.read, Res.write, Res.execute}, initblk);
	 (* Module discovery: The startup block links the current module
	  * into the module list and calls the startup block of the dependant
	  * modules. This should result in a top sorted module list. *)
	 ConstStrings.Create (sym, "__startup");
	 Res.AddSymbol (initblk, sym, 0);
         Emit.Instr0 (s, Pentium.NOP);
         Emit.Instr0 (s, Pentium.NOP);
         Emit.Instr0 (s, Pentium.NOP);
         Emit.Instr0 (s, Pentium.NOP);
	 Emit.Instr2 (s, Pentium.MOV, Op.MemOp0 (1, 0, 4),
	              Op.ImmIntFixed (0C3H, 1));
	 Regs.UntracedValue (reg, Gen.genax);
	 NEW(ref);
	 ref.symname := sym;
	 ref.modname := RealName (module);
	 Streams.GetPos (s, off);
	 Res.AddReloc (initblk, Relocations.addSym, off - 5, 4, ref);
	 (* Build module list *)
	 Emit.Instr2 (s, Pentium.MOV, Op.RegOp (reg, 4), Op.MemOp0 (4, 0, 4));
	 ConstStrings.Create (ref.modname, "SysModules");
	 ConstStrings.Create (ref.symname, "modules");
	 Streams.GetPos (s, off);
	 Res.AddReloc (initblk, Relocations.addSym, off - 4, 4, ref);
	 Emit.Instr2 (s, Pentium.MOV, Op.MemOp0 (4, 0, 4), Op.RegOp (reg, 4));
	 ref.modname := RealName (module);
	 ConstStrings.Create (ref.symname, "__TAG__THISMODULE");
	 Streams.GetPos (s, off);
	 Res.AddReloc (initblk, Relocations.addSym, off - 4, 4, ref);

         Emit.Instr2 (s, Pentium.MOV, Op.RegOp (reg, 4), Op.ImmIntFixed (0,4));
	 ref.modname := RealName (module);
	 ConstStrings.Create (ref.symname, "__TAG__THISMODULE");
	 Streams.GetPos (s, off);
	 Res.AddReloc (initblk, Relocations.addSym, off - 4, 4, ref);
	 Emit.Instr2 (s, Pentium.MOV, Op.MemOp0 (4, 0, 4), Op.RegOp (reg, 4));
	 ConstStrings.Create (ref.modname, "SysModules");
	 ConstStrings.Create (ref.symname, "modules");
	 Streams.GetPos (s, off);
	 Res.AddReloc (initblk, Relocations.addSym, off - 4, 4, ref);

	 ref.symname := sym;
	 CompilerKeys.GetKeys (module.dependencies, it);
         WHILE Iterators.Get (it, key) DO
	    IF ConstStrings.Compare (key.modname, RealName (module)) # 0 THEN
	       Emit.Instr2 (s, Pentium.MOV, Op.RegOp (reg, 4),
	                    Op.ImmIntFixed (0, 4));
	       ref.modname := key.modname;
	       Streams.GetPos (s, off);
	       Res.AddReloc (initblk, Relocations.addSym, off - 4, 4, ref);
	       Emit.Instr1 (s, Pentium.CALL, Op.RegOp (reg, 4));
	    END;
	 END;
	 Emit.Instr0 (s, Pentium.RET);
	 Emit.Instr0 (s, Pentium.NOP);
	 Emit.Instr0 (s, Pentium.NOP);
	 Emit.Instr0 (s, Pentium.NOP);
	 Emit.Instr0 (s, Pentium.NOP);

         (* Init block. This block is called by SysMain for most modules.
	  * It calls the init blocks of all modules and finally the real
	  * init block of this module. *)
         ConstStrings.Create (sym,"__init");
	 Streams.GetPos (s, off);
	 Res.AddSymbol (initblk, sym, off);
         Emit.Instr0 (s, Pentium.NOP);
         Emit.Instr0 (s, Pentium.NOP);
         Emit.Instr0 (s, Pentium.NOP);
         Emit.Instr0 (s, Pentium.NOP);
	 Emit.Instr2 (s, Pentium.MOV, Op.MemOp0 (1, 0, 4),
	              Op.ImmIntFixed (0C3H, 1));
	 ref.symname := sym;
	 ref.modname := RealName (module);
	 Streams.GetPos (s, off);
	 Res.AddReloc (initblk, Relocations.addSym, off - 5, 4, ref);
	 ref.symname := sym;
	 CompilerKeys.GetKeys (module.dependencies, it);
         WHILE Iterators.Get (it, key) DO
	    IF ConstStrings.Compare (key.modname, RealName (module)) # 0 THEN
	       Emit.Instr2 (s, Pentium.MOV, Op.RegOp (reg, 4),
	                    Op.ImmIntFixed (0, 4));
	       ref.modname := key.modname;
	       Streams.GetPos (s, off);
	       Res.AddReloc (initblk, Relocations.addSym, off - 4, 4, ref);
	       Emit.Instr1 (s, Pentium.CALL, Op.RegOp (reg, 4));
	    END;
	 END;

	 Emit.Instr2 (s, Pentium.MOV, Op.RegOp (reg, 4), Op.ImmIntFixed (0, 4));
	 ref.modname := RealName (module);
	 ConstStrings.Create (ref.symname, "__realinit");
	 Streams.GetPos (s, off);
	 Res.AddReloc (initblk, Relocations.addSym, off - 4, 4, ref);
	 Emit.Instr1 (s, Pentium.CALL, Op.RegOp (reg, 4));

	 Emit.Instr0 (s, Pentium.RET);
	 Emit.Instr0 (s, Pentium.NOP);
	 Emit.Instr0 (s, Pentium.NOP);
	 Emit.Instr0 (s, Pentium.NOP);
	 Emit.Instr0 (s, Pentium.NOP);

	 ConstStrings.Create (sym, "__entry"); 
	 Streams.GetPos (s, off);
	 Res.AddSymbol (initblk, sym, off);
	 Emit.Instr2 (s, Pentium.MOV, Op.RegOp (reg, 4),
	              Op.ImmIntFixed (0, 4));
	 ref.modname := RealName (module);
	 ConstStrings.Create (ref.symname, "__startup");
	 Streams.GetPos (s, off);
	 Res.AddReloc (initblk, Relocations.addSym, off - 4, 4, ref);
	 Emit.Instr1 (s, Pentium.CALL, Op.RegOp (reg, 4));
	 Regs.UntracedValue (reg, Gen.genax);
	 Emit.Instr2 (s, Pentium.XOR, Op.RegOp (reg, 4), Op.RegOp (reg, 4));
	 Emit.Instr1 (s, Pentium.INCR, Op.RegOp (reg, 4));
	 Regs.UntracedValue (reg, Gen.genbx);
	 Emit.Instr2 (s, Pentium.XOR, Op.RegOp (reg, 4), Op.RegOp (reg, 4));
	 Emit.Instr1 (s, Pentium.INT, Op.ImmIntFixed (080H, 1));
	 Emit.Instr0 (s, Pentium.NOP);
	 Emit.Instr0 (s, Pentium.NOP);
	 Emit.Instr0 (s, Pentium.NOP);
	 Streams.GetPos (s, off);
	 ASSERT(FragmentedStreams.NumberOfUnfixedObjects (s) = 0);
	 initblk.datalen := off;
	 initblk.memlen := off;
	 initblk.align := 1;
         ok := PersistentTexts.Create (initblk.data, s); ASSERT(ok);
      (* END Module init block *)
      res.name := RealName (module);
      Res.AddBlock (res, {Res.read, Res.write}, datablk);
      ConstStrings.Create (sym, "__global_variables_block");
      Res.AddSymbol (datablk, sym, 0);
      NEW(ref);
      ref.modname := RealName (module);
      GenTypes.CreateGTAGName (ref.symname);
      Res.AddReloc (datablk, Relocations.setSym, 0, 4, ref);
      ConstStrings.Create (sym, "__global_variables");
      Res.AddSymbol (datablk, sym, 4);
      GenVars (module.scope, module.export, datablk);
      Res.AddBlock (res, {Res.read}, roblk);
      ConstStrings.Create (sym, "__rodata");
      Res.AddSymbol (roblk, sym, 0);
      Res.AddBlock (res, {Res.read, Res.execute}, codeblk);
      ConstStrings.Create (sym, "__realinit");
      Res.AddSymbol (codeblk, sym, 0);
      Res.AddBlock (res, {Res.read}, typeblk);
      ConstStrings.Create (sym, "__type_tags");
      Res.AddSymbol (typeblk, sym, 0);
      FragmentedStreams.Create (s);
      CreateLabel (start, "stream start", NIL, s);
      FragmentedStreams.AttachLabel (s, start);
      ConstStrings.Create (sym, "__CODESTART");
      Relocations.NewSymbol (s, sym, start);
      Emit.CreateStringTable (rodata);
      (* This is mainly done to make sure that we get an ELF compliant
       * string table in the read only block. *)
      dummy := Emit.StringArray (rodata, "", dummy);
      NEW(proc);
      proc.s := s;
      proc.rodata := rodata;
      proc.module := module;
      proc.ident := module;
      proc.errors := errors;
      proc.typeblk := typeblk;
      proc.typelist := NIL;
      proc.unique := 0;
      Emit.CreateFixedData (proc.types);
      GenBody (proc);
      GenTypes.GenTagForBlock (proc, proc.ident);
      GenProcs (proc, module.scope, module.export);
      FragmentedStreams.CreateLabel (endlab);
      FragmentedStreams.AttachLabel (proc.s, endlab);
      ConstStrings.Create (sym, "__CODEEND");
      Relocations.NewSymbol (proc.s, sym, endlab);
      (* Do not try to fix objects if there were errors. Some information
       * may not be availiable. E.g. target labels can be unattached. *)
      IF RelatedEvents.EventsPending (errors) THEN
	 RETURN FALSE
      END;
      Emit.UnfixedObjects (proc.s, start);
      GenTypes.MarkExportedTypes (proc);
      GenTypes.GenAllTypes (proc);
      ASSERT(FragmentedStreams.NumberOfUnfixedObjects (s) = 0);
      ok := PersistentTexts.Create (codeblk.data, s); ASSERT(ok);
      FragmentedStreams.Length (s, codeblk.datalen, codeblk.memlen);
      ASSERT((codeblk.datalen > 0) & (codeblk.datalen = codeblk.memlen));
      codeblk.align := 32 (* Level one Cache size *);
      I386Relocations.Process (s, s, codeblk, start);
      GenTypes.GenBlockList (proc);
      GenTypes.GenModuleTag (proc);
      Emit.OpenFixedData (proc.rodata, rostream);
      ok := Streams.Seek (rostream, 0, Streams.fromEnd); ASSERT(ok);
      Streams.GetPos(rostream, roblk.datalen);
      roblk.memlen := roblk.datalen;
      roblk.align := rodata.align;
      roblk.data := NIL;
      IF roblk.datalen > 0 THEN
	 ok := PersistentTexts.Create (roblk.data, rostream); ASSERT(ok);
      END;
      Emit.OpenFixedData (proc.types, rostream);
      ok := Streams.Seek (rostream, 0, Streams.fromEnd); ASSERT(ok);
      Streams.GetPos (rostream, typeblk.datalen);
      typeblk.memlen := typeblk.datalen;
      typeblk.align := proc.types.align;
      typeblk.data := NIL;
      IF typeblk.datalen > 0 THEN
	 ok := PersistentTexts.Create (typeblk.data, rostream); ASSERT(ok);
      END;
      (*
      ok := Streams.Flush (Streams.stdout); ASSERT(ok);
      *)
      l := trackedlabels;
      WHILE l # NIL DO
         IF start.mys = l.mys THEN
	    FragmentedStreams.Difference (start, l, dummy, dummy);
	    (*
	    Write.IntS (Streams.stderr, dummy, 8);
	    Write.StringS (Streams.stderr, " ");
	    Write.StringS (Streams.stderr, l.desc);
	    IF l.loc # NIL THEN
	       Write.StringS (Streams.stderr, " ");
	       Write.IntS (Streams.stderr, l.loc.begin, 0);
	       Write.StringS (Streams.stderr, " ");
	       Write.IntS (Streams.stderr, l.loc.end, 0);
	    END;
	    Write.LnS (Streams.stderr);
	    *)
	 END;
	 l := l.next;
      END;
      RETURN TRUE
   END GenModule;

BEGIN
   leveldid := Disciplines.Unique();
   labeltrackid := 0;
   trackedlabels := NIL;
END I386ObCodeGen.
