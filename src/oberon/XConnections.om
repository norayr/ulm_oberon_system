(* Ulm's Oberon Library
   Copyright (C) 1989-2005 by University of Ulm, SAI, D-89069 Ulm, Germany
   ----------------------------------------------------------------------------
   Ulm's Oberon Library is free software; you can redistribute it
   and/or modify it under the terms of the GNU Library General Public
   License as published by the Free Software Foundation; either version
   2 of the License, or (at your option) any later version.

   Ulm's Oberon Library is distributed in the hope that it will be
   useful, but WITHOUT ANY WARRANTY; without even the implied warranty
   of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   ----------------------------------------------------------------------------
   E-mail contact: oberon@mathematik.uni-ulm.de
   ----------------------------------------------------------------------------
   $Id$
   ----------------------------------------------------------------------------
   $Log$
   ----------------------------------------------------------------------------
*)

MODULE XConnections;

   IMPORT ASCII, Conditions, Disciplines, DNSRecords, DNSResolvers,
      DNSStdResolvers, Errors, EventConditions, Events, IPv4Addresses,
      IPv4TCPSockets, Jobs, LocalSemaphores, MemOps, MemStreams, Objects,
      RelatedEvents, Resources, Scan, Semaphores, Sets, Signals,
      StreamConditions, Streams, Strings, SubStreams, SYS := SYSTEM, Tasks,
      Types, UnixDomainSockets, UnixEnvironment, UnixHost, Write, XAuthority;

   TYPE
      Connection = POINTER TO ConnectionRec;

   CONST
      (* X event types *)
      keyPress = 0;
      keyRelease = 1;
      buttonPress = 2;
      buttonRelease = 3;
      enterWindow = 4;
      leaveWindow = 5;
      pointerMotion = 6;
      pointerMotionHint = 7;
      button1Motion = 8;
      button2Motion = 9;
      button3Motion = 10;
      button4Motion = 11;
      button5Motion = 12;
      buttonMotion = 13;
      keymapState = 14;
      exposure = 15;
      visibilityChange = 16;
      structureNotify = 17;
      resizeRedirect = 18;
      substructureNotify = 19;
      substructureRedirect = 20;
      focusChange = 21;
      propertyChange = 22;
      colormapChange = 23;
      ownerGrabButton = 24;
      eventTypes = 25;
   TYPE
      EventType = SHORTINT; (* keyPress .. eventTypes *)
      EventTypeSet = SET; (* OF EventType *)
      EventTypeName = ARRAY 32 OF CHAR;
   VAR
      eventTypeName: ARRAY eventTypes OF EventTypeName;

   CONST
      shiftKey = 0;
      lockKey = 1;
      controlKey = 2;
      mod1Key = 3;
      mod2Key = 4;
      mod3Key = 5;
      mod4Key = 6;
      mod5Key = 7;
      button1Key = 8;
      button2Key = 9;
      button3Key = 10;
      button4Key = 11;
      button5Key = 12;
      specialKeys = 13;
   TYPE
      Key = SHORTINT; (* shiftKey .. button5Key *)
      KeySet = SET; (* OF Key *)
      KeyName = ARRAY 16 OF CHAR;
   VAR
      keyName: ARRAY specialKeys OF KeyName;

   CONST
      keys = 256;
      setlen = keys DIV (MAX(SET) + 1);
   TYPE
      KeymapStateSet = ARRAY setlen OF SET;

   TYPE
      WindowID = Types.Int32;
      PixmapID = Types.Int32;
      DrawableID = Types.Int32;
      ResourceID = Types.Int32;
      AtomID = Types.Int32;
      ColormapID = Types.Int32;
      VisualID = Types.Int32;
      FontID = Types.Int32;
      GContextID = Types.Int32;
      Pixel = Types.Int32;

   CONST
      (* request op codes *)
      createWindow = 1;
      changeWindowAttributes = 2;
      getWindowAttributes = 3;
      mapWindow = 8;
      getGeometry = 14;
      createGC = 55;
      polyLine = 65;

   CONST
      (* X event codes used by server generated packets;
         note that codes 0 and 1 are reserved for errors and replies
      *)
      keyPressEvent = 2;
      keyReleaseEvent = 3;
      buttonPressEvent = 4;
      motionNotifyEvent = 6;
      enterNotifyEvent = 7;
      leaveNotifyEvent = 8;
      focusInEvent = 9;
      focusOutEvent = 10;
      keymapNotifyEvent = 11;
      exposeEvent = 12;
      graphicsExposeEvent = 13;
      noExposeEvent = 14;
      visibilityNotifyEvent = 15;
      createNotifyEvent = 16;
      destroyNotifyEvent = 17;
      unmapNotifyEvent = 18;
      mapNotifyEvent = 19;
      mapRequestEvent = 20;
      reparentNotifyEvent = 21;
      configureNotifyEvent = 22;
      configureRequestEvent = 23;
      gravityNotifyEvent = 24;
      resizeRequestEvent = 25;
      circulateNotifyEvent = 26;
      circulateRequestEvent = 27;
      propertyNotifyEvent = 28;
      selectionClearEvent = 29;
      selectionRequestEvent = 30;
      selectionNotifyEvent = 31;
      colormapNotifyEvent = 32;
      clientMessageEvent = 33;
      mappingNotifyEvent = 34;
      events = 35;
   TYPE
      XEventCode = INTEGER; (* keyPressEvent .. mappingNotifyEvent *)
      XEventName = ARRAY 32 OF CHAR;
   VAR
      xeventName: ARRAY events OF XEventName;
   TYPE
      XEvent = POINTER TO XEventRec;
      XEventRec =
	 RECORD
	    (Events.EventRec)
	    code: XEventCode;
	    sequenceNumber: INTEGER;
	    con: Connection;
	 END;
      ButtonPressEvent = POINTER TO ButtonPressEventRec;
      ButtonPressEventRec =
	 RECORD
	    (XEventRec)
	    button: INTEGER;
	    timestamp: Types.Int32;
	    root, event, child: WindowID;
	    rootx, rooty, eventx, eventy: INTEGER;
	    state: KeySet;
	    sameScreen: BOOLEAN;
	 END;
      CirculateNotifyEvent = POINTER TO CirculateNotifyEventRec;
      CirculateNotifyEventRec =
	 RECORD
	    (XEventRec)
	    event, window: WindowID;
	    place: INTEGER; (* top = 0, bottom = 1 *)
	 END;
      CirculateRequestEvent = POINTER TO CirculateRequestEventRec;
      CirculateRequestEventRec =
	 RECORD
	    (XEventRec)
	    parent, window: WindowID;
	    place: INTEGER; (* top = 0, bottom = 1 *)
	 END;
      ClientMessageEvent = POINTER TO ClientMessageEventRec;
      ClientMessageEventRec =
	 RECORD
	    (XEventRec)
	    format: INTEGER; (* 8, 16, or 32 *)
	    window: WindowID;
	    atom: AtomID;
	    data: Streams.Stream;
	 END;
      ColormapNotifyEvent = POINTER TO ColormapNotifyEventRec;
      ColormapNotifyEventRec =
	 RECORD
	    (XEventRec)
	    window: WindowID;
	    colormap: ColormapID;
	    new: BOOLEAN;
	    state: INTEGER;
	 END;
      ConfigureNotifyEvent = POINTER TO ConfigureNotifyEventRec;
      ConfigureNotifyEventRec =
	 RECORD
	    (XEventRec)
	    event, window, aboveSibling: WindowID;
	    x, y: INTEGER;
	    width, height: INTEGER;
	    borderWidth: INTEGER;
	    overrideRedirect: BOOLEAN;
	 END;
      ConfigureRequestEvent = POINTER TO ConfigureRequestEventRec;
      ConfigureRequestEventRec =
	 RECORD
	    (XEventRec)
	    stackMode: INTEGER;
	       (*
		  0: Above
		  1: Below
		  2: TopIf
		  3: BottomIf
		  4: Opposite
	       *)
	    parent, window, sibling: WindowID;
	    x, y: INTEGER;
	    width, height: INTEGER;
	    borderWidth: INTEGER;
	    valueMask: SET;
	       (*
		  0: x
		  1: y
		  2: width
		  3: height
		  4: borderWidth
		  5: sibling
		  6: stackMode
	       *)
	 END;
      CreateNotifyEvent = POINTER TO CreateNotifyEventRec;
      CreateNotifyEventRec =
	 RECORD
	    (XEventRec)
	    parent, window: WindowID;
	    x, y: INTEGER;
	    width, height: INTEGER;
	    borderWidth: INTEGER;
	    overrideRedirect: BOOLEAN;
	 END;
      DestroyNotifyEvent = POINTER TO DestroyNotifyEventRec;
      DestroyNotifyEventRec =
	 RECORD
	    (XEventRec)
	    event, window: WindowID;
	 END;
      EnterOrLeaveNotifyEvent = POINTER TO EnterOrLeaveNotifyEventRec;
      EnterOrLeaveNotifyEventRec =
	 RECORD
	    (XEventRec)
	    detail: INTEGER;
	       (*
		  0: Ancestor
		  1: Virtual
		  2: Inferior
		  3: Nonlinear
		  4: NonlinearVirtual
	       *)
	    time: Types.Int32;
	    root, event, child: WindowID;
	    rootx, rooty: INTEGER;
	    eventx, eventy: INTEGER;
	    state: KeySet;
	    mode: INTEGER;
	       (*
		  0: Normal
		  1: Grab
		  2: Ungrab
	       *)
	    sameScreen: BOOLEAN;
	    focus: BOOLEAN;
	 END;
      ExposeEvent = POINTER TO ExposeEventRec;
      ExposeEventRec =
	 RECORD
	    (XEventRec)
	    window: WindowID;
	    x, y: INTEGER;
	    width, height: INTEGER;
	    count: INTEGER;
	 END;
      FocusEvent = POINTER TO FocusEventRec;
      FocusEventRec =
	 RECORD
	    (XEventRec)
	    detail: INTEGER;
	       (*
		  0: Ancestor
		  1: Virtual
		  2: Inferior
		  3: Nonlinear
		  4: NonlinearVirtual
		  5: Pointer
		  6: PointerRoot
		  7: None
	       *)
	    event: WindowID;
	    mode: INTEGER;
	       (*
		  0: Normal
		  1: Grab
		  2: WhileGrabbed
	       *)
	 END;
      GraphicsExposeEvent = POINTER TO GraphicsExposeEventRec;
      GraphicsExposeEventRec =
	 RECORD
	    (XEventRec)
	    drawable: DrawableID;
	    x, y: INTEGER;
	    width, height: INTEGER;
	    majorOpcode, minorOpcode: INTEGER;
	    count: INTEGER;
	 END;
      GravityNotifyEvent = POINTER TO GravityNotifyEventRec;
      GravityNotifyEventRec =
	 RECORD
	    (XEventRec)
	    event, window: WindowID;
	    x, y: INTEGER;
	 END;
      KeymapNotifyEvent = POINTER TO KeymapNotifyEventRec;
      KeymapNotifyEventRec =
	 RECORD
	    (XEventRec)
	    keys: KeymapStateSet;
	 END;
      KeyEvent = POINTER TO KeyEventRec;
      KeyEventRec =
	 RECORD
	    (XEventRec)
	    keycode: INTEGER;
	    time: Types.Int32;
	    root, event, child: WindowID;
	    rootx, rooty: INTEGER;
	    eventx, eventy: INTEGER;
	    state: KeySet;
	    sameScreen: BOOLEAN;
	 END;
      MapNotifyEvent = POINTER TO MapNotifyEventRec;
      MapNotifyEventRec =
	 RECORD
	    (XEventRec)
	    event, window: WindowID;
	    overrideRedirect: BOOLEAN;
	 END;
      MappingNotifyEvent = POINTER TO MappingNotifyEventRec;
      MappingNotifyEventRec =
	 RECORD
	    (XEventRec)
	    request: INTEGER;
	       (*
		  0: Modifier
		  1: Keyboard
		  2: Pointer
	       *)
	    firstKeycode: INTEGER;
	    count: INTEGER;
	 END;
      MapRequestEvent = POINTER TO MapRequestEventRec;
      MapRequestEventRec =
	 RECORD
	    (XEventRec)
	    parent, window: WindowID;
	 END;
      MotionNotifyEvent = POINTER TO MotionNotifyEventRec;
      MotionNotifyEventRec =
	 RECORD
	    (XEventRec)
	    detail: INTEGER;
	       (*
		  0: Normal
		  1: Hint
	       *)
	    time: Types.Int32;
	    root, event, child: WindowID;
	    rootx, rooty: INTEGER;
	    eventx, eventy: INTEGER;
	    state: KeySet;
	    sameScreen: BOOLEAN;
	 END;
      NoExposeEvent = POINTER TO NoExposeEventRec;
      NoExposeEventRec =
	 RECORD
	    (XEventRec)
	    drawable: DrawableID;
	    majorOpcode, minorOpcode: INTEGER;
	 END;
      PropertyNotifyEvent = POINTER TO PropertyNotifyEventRec;
      PropertyNotifyEventRec =
	 RECORD
	    (XEventRec)
	    window: WindowID;
	    atom: AtomID;
	    time: Types.Int32;
	    state: INTEGER;
	       (*
		  0: NewValue
		  1: Deleted
	       *)
	 END;
      ReparentNotifyEvent = POINTER TO ReparentNotifyEventRec;
      ReparentNotifyEventRec =
	 RECORD
	    (XEventRec)
	    event, window, parent: WindowID;
	    x, y: INTEGER;
	    overrideRedirect: BOOLEAN;
	 END;
      ResizeRequestEvent = POINTER TO ResizeRequestEventRec;
      ResizeRequestEventRec =
	 RECORD
	    (XEventRec)
	    window: WindowID;
	    width, height: INTEGER;
	 END;
      SelectionClearEvent = POINTER TO SelectionClearEventRec;
      SelectionClearEventRec =
	 RECORD
	    (XEventRec)
	    time: Types.Int32;
	    owner: WindowID;
	    selection: AtomID;
	 END;
      SelectionNotifyEvent = POINTER TO SelectionNotifyEventRec;
      SelectionNotifyEventRec =
	 RECORD
	    (XEventRec)
	    time: Types.Int32;
	    requestor: WindowID;
	    selection: AtomID;
	    target: AtomID;
	    property: AtomID;
	 END;
      SelectionRequestEvent = POINTER TO SelectionRequestEventRec;
      SelectionRequestEventRec =
	 RECORD
	    (XEventRec)
	    time: Types.Int32;
	    owner, requestor: WindowID;
	    selection: AtomID;
	    target: AtomID;
	    property: AtomID;
	 END;
      UnmapNotifyEvent = POINTER TO UnmapNotifyEventRec;
      UnmapNotifyEventRec =
	 RECORD
	    (XEventRec)
	    event, window: WindowID;
	    fromConfigure: BOOLEAN;
	 END;
      VisibilityNotifyEvent = POINTER TO VisibilityNotifyEventRec;
      VisibilityNotifyEventRec =
	 RECORD
	    (XEventRec)
	    window: WindowID;
	    state: INTEGER;
	       (*
		  0: Unobscured
		  1: PartiallyObscured
		  2: FullyObscured
	       *)
	 END;
   TYPE
      EventParserProc = PROCEDURE (s: Streams.Stream;
                                   con: Connection;
				   VAR event: XEvent);
      EventName = ARRAY 32 OF CHAR;
   VAR
      eventParser: ARRAY 256 OF EventParserProc;
      eventName: ARRAY 256 OF EventName;

   CONST
      gravityForget = 0;
      gravityUnmap = 0;
      gravityNorthWest = 1;
      gravityNorth = 2;
      gravityNorthEast = 3;
      gravityWest = 4;
      gravityCenter = 5;
      gravityEast = 6;
      gravitySouthWest = 7;
      gravitySouth = 8;
      gravitySouthEast = 9;
      gravityStatic = 10;
   TYPE
      Gravity = INTEGER;

   CONST
      (* value-mask for CreateWindow *)
      atBackgroundPixmap = 0;
      atBackgroundPixel = 1;
      atBorderPixmap = 2;
      atBorderPixel = 3;
      atBitGravity = 4;
      atWinGravity = 5;
      atBackingStore = 6;
      atBackingPlanes = 7;
      atBackingPixel = 8;
      atOverrideRedirect = 9;
      atSaveUnder = 10;
      atEventMask = 11;
      atDoNotPropagateMask = 12;
      atColormap = 13;
      atCursor = 14;
      attributes = 15;

   TYPE
      WindowAttributeSet = SET;
      WindowAttributes = POINTER TO WindowAttributesRec;
      WindowAttributesRec =
	 RECORD
	    (Objects.ObjectRec)
	    defined: WindowAttributeSet;
	    backgroundPixmap: PixmapID;
	    backgroundPixel: Types.Int32;
	    borderPixmap: PixmapID;
	    borderPixel: Types.Int32;
	    bitGravity: Gravity;
	    winGravity: Gravity;
	    backingStore: INTEGER;
	    backingPlanes: Types.Int32;
	    backingPixel: Types.Int32;
	    overrideRedirect: BOOLEAN;
	    saveUnder: BOOLEAN;
	    eventMask: EventTypeSet;
	    doNotPropagateMask: EventTypeSet;
	    colormap: ColormapID;
	    cursor: Types.Int32;
	 END;
      ExtraWindowAttributes = POINTER TO ExtraWindowAttributesRec;
	 (* returned by GetWindowAttributes *)
      ExtraWindowAttributesRec =
	 RECORD
	    (Objects.ObjectRec)
	    visual: VisualID;
	    class: INTEGER;
	    mapIsInstalled: BOOLEAN;
	    mapState: INTEGER;
	    allEventMasks: EventTypeSet;
	 END;
      Geometry = POINTER TO GeometryRec;
      GeometryRec =
	 RECORD
	    (Objects.ObjectRec)
	    depth: INTEGER;
	    root: WindowID;
	    x, y: INTEGER;
	    width, height: INTEGER;
	    borderWidth: INTEGER;
	 END;

   CONST
      (* value-mask for CreateGC *)
      gcFunction = 0;
      gcPlaneMask = 1;
      gcForeground = 2;
      gcBackground = 3;
      gcLineWidth = 4;
      gcLineStyle = 5;
      gcCapStyle = 6;
      gcJoinStyle = 7;
      gcFillStyle = 8;
      gcFillRule = 9;
      gcTile = 10;
      gcStipple = 11;
      gcTileStippleXOrigin = 12;
      gcTileStippleYOrigin = 13;
      gcFont = 14;
      gcSubwindowMode = 15;
      gcGraphicsExposures = 16;
      gcClipXOrigin = 17;
      gcClipYOrigin = 18;
      gcClipMask = 19;
      gcDashOffset = 20;
      gcDashes = 21;
      gcArcMode = 22;
      gcAttributes = 23;
      (* GC functions *)
      gcfClear = 0;
      gcfAnd = 1;
      gcfAndReverse = 2;
      gcfCopy = 3;
      gcfAndInverted = 4;
      gcfNoOp = 5;
      gcfXor = 6;
      gcfOr = 7;
      gcfNor = 8;
      gcfEquiv = 9;
      gcfInvert = 10;
      gcfOrReverse = 11;
      gcfCopyInverted = 12;
      gcfOrInverted = 13;
      gcfNand = 14;
      gcfSet = 15;
      (* GC line styles *)
      gclsSolid = 0;
      gclsOnOffDash = 1;
      gclsDoubleDash = 2;
      (* GC cap styles *)
      gccsNotLast = 0;
      gccsButt = 1;
      gccsRound = 2;
      gccsProjecting = 3;
      (* GC join styles *)
      gcjsMiter = 0;
      gcjsRound = 1;
      gcjsBevel = 2;
      (* GC fill styles *)
      gcfsSolid = 0;
      gcfsTiled = 1;
      gcfsStippled = 2;
      (* GC fill rule *)
      gcfrEvenOdd = 0;
      gcfrWinding = 1;
      (* GC subwindow mode *)
      gcswClipByChildren = 0;
      gcswIncludeInferiors = 1;
      (* GC arc modes *)
      gcswChord = 0;
      gcswPieSlice = 1;
   TYPE
      GraphicalContextAttributeSet = SET; (* OF gcFunction .. gcArcMode *)
      GCFunction = INTEGER; (* gcfClear .. gcfSet *)
      LineStyle = INTEGER; (* gclsSolid .. gclsDoubleDash *)
      CapStyle = INTEGER; (* gccsNotLast .. gccsProjecting *)
      JoinStyle = INTEGER; (* gcjsMiter .. gcjsBevel *)
      FillStyle = INTEGER; (* gcfsSolid .. gcfsStippled *)
      FillRule = INTEGER; (* gcfrEvenOdd .. gcfrWinding *)
      SubWindowMode = INTEGER; (* gcswClipByChildren .. gcswIncludeInferiors *)
      ArcMode = INTEGER; (* gcswChord .. gcswPieSlice *)
      GraphicalContextAttributes = POINTER TO GraphicalContextAttributesRec;
      GraphicalContextAttributesRec =
	 RECORD
	    (Objects.ObjectRec)
	    defined: GraphicalContextAttributeSet;
	    function: GCFunction;
	    planeMask: Types.Int32;
	    foreground: Types.Int32;
	    background: Types.Int32;
	    lineWidth: INTEGER;
	    lineStyle: LineStyle;
	    capStyle: CapStyle;
	    joinStyle: JoinStyle;
	    fillStyle: FillStyle;
	    fillRule: FillRule;
	    tile: PixmapID;
	    stipple: PixmapID;
	    tileStippleXOrigin: INTEGER;
	    tileStippleYOrigin: INTEGER;
	    font: FontID;
	    subwindowMode: SubWindowMode;
	    graphicsExposures: BOOLEAN;
	    clipXOrigin: INTEGER;
	    clipYOrigin: INTEGER;
	    clipMask: PixmapID;
	    dashOffset: INTEGER;
	    dashes: INTEGER;
	    arcmode: ArcMode;
	 END;

   TYPE
      ListOfPoints = POINTER TO ListOfPointsRec;
      ListOfPointsRec =
	 RECORD
	    (Objects.ObjectRec)
	    x, y: INTEGER;
	    next: ListOfPoints;
	 END;

   CONST
      (* X error types *)
      requestError = 1;
      valueError = 2;
      windowError = 3;
      pixmapError = 4;
      atomError = 5;
      cursorError = 6;
      fontError = 7;
      matchError = 8;
      drawableError = 9;
      accessError = 10;
      allocError = 11;
      colormapError = 12;
      gContextError = 13;
      idChoiceError = 14;
      nameError = 15;
      lengthError = 16;
      implementationError = 17;
      xErrors = 18;
   TYPE
      XErrorCode = INTEGER; (* requestError .. unknownError *)
      ErrorCodeName = ARRAY 32 OF CHAR;
   VAR
      errorCodeName: ARRAY xErrors OF ErrorCodeName;
   TYPE
      XErrorEvent = POINTER TO XErrorEventRec;
      XErrorEventRec =
	 RECORD
	    (Events.EventRec)
	    con: Connection;
	    code: XErrorCode;
	    sequenceNumber: INTEGER;
	    majorOpcode, minorOpcode: INTEGER;
	    errorParameter: Types.Int32;
	    packet: Streams.Stream;
	 END;
   VAR
      xErrorEventType: Events.EventType;

   TYPE
      Format = POINTER TO FormatRec;
      FormatRec =
	 RECORD
	    depth: INTEGER;
	    bitsPerPixel: INTEGER;
	    scanlinePad: INTEGER;
	    next: Format;
	 END;
      Visual = POINTER TO VisualRec;
      VisualRec =
	 RECORD
	    visualID: Types.Int32;
	    class: INTEGER;
	    bitsPerRGBValue: INTEGER;
	    colormapEntries: INTEGER;
	    redMask: Types.Int32;
	    greenMask: Types.Int32;
	    blueMask: Types.Int32;
	    next: Visual;
	 END;
      Depth = POINTER TO DepthRec;
      DepthRec =
	 RECORD
	    depth: INTEGER;
	    visuals: Visual;
	    next: Depth;
	 END;
      Screen = POINTER TO ScreenRec;
      ScreenRec =
	 RECORD
	    root: WindowID;
	    colorMap: Types.Int32;
	    whitePixel: PixmapID;
	    blackPixel: PixmapID;
	    currentInputMasks: Types.Int32;
	    widthInPixels: INTEGER;
	    heightInPixels: INTEGER;
	    minInstalledMaps: INTEGER;
	    maxInstalledMaps: INTEGER;
	    rootVisual: Types.Int32;
	    backingStores: INTEGER;
	    saveUnders: BOOLEAN;
	    rootDepth: INTEGER;
	    depths: Depth;
	    (* private *)
	    next: Screen;
	 END;
      Server = POINTER TO ServerRec;
      ServerRec =
	 RECORD
	    major, minor: INTEGER;
	    releaseNumber: Types.Int32;
	    resourceIDbase: Types.Int32;
	    resourceIDmask: Types.Int32;
	    motionBufferSize: Types.Int32;
	    maximumRequestLength: INTEGER;
	    numberOfScreens: INTEGER;
	    numberOfFormats: INTEGER;
	    imageByteOrder: INTEGER;
	    bitmapFormatBitOrder: INTEGER;
	    bitmapFormatScanlineUnit: INTEGER;
	    bitmapFormatScanlinePad: INTEGER;
	    minKeyCode, maxKeyCode: INTEGER;
	    vendor: ARRAY 128 OF CHAR;
	    listOfFormats: Format;
	    listOfScreens: Screen;
	 END;

   CONST
      sequenceNumbers = 10000H; (* # of distinct sequence numbers *)
   TYPE
      OpenRequest = POINTER TO OpenRequestRec;
      OpenRequestRec =
	 RECORD
	    sequenceNumber: INTEGER;
	    signal: Signals.Signal;
	    reply: Streams.Stream;
	    xerror: XErrorEvent;
	    next: OpenRequest;
	 END;

   TYPE
      ConnectionRec =
	 RECORD
	    (Disciplines.ObjectRec)
	    display: ARRAY 128 OF CHAR;
	    server: Server;
	    screen: Screen; (* selected stream *)
	    s: Streams.Stream;
	    mutex: Semaphores.Semaphore; (* for read/write access of s *)
	    nextSequenceNumber: INTEGER;
	    openRequests: OpenRequest;
	    eventType: ARRAY 256 OF Events.EventType;
	    id: Types.Int32; (* counter for resource ids *)
	    closed: BOOLEAN;
	 END;

   CONST
      (* errors while connecting to X server  *)
      connectionRejected = 0;
      invalidDisplaySpecification = 1;
      missingDisplaySpecification = 2;
      invalidScreenNumber = 3;
      localConnectionFailed = 4;
      networkConnectionFailed = 5;
      greetingFailed = 6;
      invalidWelcome = 7;
      noSuchScreenNumber = 8;
      (* errors during a running X session *)
      outOfResourceIDs = 9;
      errors = 10;
   TYPE
      ErrorCode = SHORTINT;
      ErrorEvent = POINTER TO ErrorEventRec;
      ErrorEventRec =
	 RECORD
	    (Events.EventRec)
	    errorcode: ErrorCode;
	 END;
      ConnectionErrorEvent = POINTER TO ConnectionErrorEventRec;
      ConnectionErrorEventRec =
	 RECORD
	    (ErrorEventRec)
	    display: ARRAY 80 OF CHAR;
	    reason: ARRAY 128 OF CHAR;
	 END;
      SessionErrorEvent = POINTER TO SessionErrorEventRec;
      SessionErrorEventRec =
	 RECORD
	    (ErrorEventRec)
	    con: Connection;
	 END;
   VAR
      error: Events.EventType;
      errormsg: ARRAY errors OF Events.Message;

   TYPE
      InputHandlerJob = POINTER TO InputHandlerJobRec;
      InputHandlerJobRec =
	 RECORD
	    (Jobs.JobRec)
	    con: Connection;
	 END;
   TYPE
      DeliverEventJob = POINTER TO DeliverEventJobRec;
      DeliverEventJobRec =
	 RECORD
	    (Jobs.JobRec)
	    event: Events.Event;
	 END;

   (* === general error handling =========================================== *)

   PROCEDURE Error(con: Connection;
                   errorcode: ErrorCode);
      VAR
	 event: SessionErrorEvent;
   BEGIN
      NEW(event); event.type := error;
      event.message := errormsg[errorcode];
      event.errorcode := errorcode;
      event.con := con;
      RelatedEvents.Raise(con, event);
   END Error;

   PROCEDURE ConnectionError(errors: RelatedEvents.Object;
                             errorcode: ErrorCode;
			     ds: Streams.Stream;
		             reason: ARRAY OF CHAR);
      VAR
	 event: ConnectionErrorEvent;
	 ok: BOOLEAN;
	 ss: Streams.Stream;
   BEGIN
      NEW(event); event.type := error;
      event.message := errormsg[errorcode];
      event.errorcode := errorcode;
      IF ds = NIL THEN
	 event.display := "";
      ELSE
	 Strings.Open(ss, event.display);
	 Streams.SetPos(ds, 0);
	 ok := Streams.Copy(ds, ss, -1);
      END;
      COPY(reason, event.reason);
      RelatedEvents.Raise(errors, event);
   END ConnectionError;

   PROCEDURE WriteError(s: Streams.Stream; event: Events.Event);
   BEGIN
      IF event IS ConnectionErrorEvent THEN
	 WITH event: ConnectionErrorEvent DO
	    IF event.display # "" THEN
	       Write.StringS(s, "X display ");
	       Write.CharS(s, ASCII.quote);
	       Write.StringS(s, event.display);
	       Write.CharS(s, ASCII.quote);
	       Write.StringS(s, ": ");
	    END;
	    Write.StringS(s, event.message);
	    IF event.reason # "" THEN
	       Write.StringS(s, ": ");
	       Write.StringS(s, event.reason);
	    END;
	 END;
      ELSIF event IS SessionErrorEvent THEN
	 WITH event: SessionErrorEvent DO
	    Write.StringS(s, event.message);
	 END;
      ELSE
	 Write.StringS(s, event.message);
      END;
   END WriteError;

   PROCEDURE WriteXError(s: Streams.Stream; event: Events.Event);
   BEGIN
      WITH event: XErrorEvent DO
	 IF event.con.display # "" THEN
	    Write.StringS(s, "X display ");
	    Write.CharS(s, ASCII.quote);
	    Write.StringS(s, event.con.display);
	    Write.CharS(s, ASCII.quote);
	    Write.StringS(s, ": ");
	 END;
	 Write.StringS(s, event.message);
	 Write.StringS(s, " on X opcode (");
	 Write.IntS(s, event.majorOpcode, 1);
	 Write.CharS(s, ",");
	 Write.IntS(s, event.minorOpcode, 1);
	 Write.StringS(s, ") for ");
	 Write.IntS(s, event.errorParameter, 1);
      END;
   END WriteXError;

   (* === private procedures =============================================== *)

   PROCEDURE Card(set: SET) : INTEGER;
      VAR
	 count: INTEGER;
	 index: INTEGER;
   BEGIN
      count := 0; index := 0;
      WHILE index <= MAX(SET) DO
	 IF index IN set THEN
	    INC(count);
	 END;
	 INC(index);
      END;
      RETURN count
   END Card;

   PROCEDURE ConvertIntToSet32(int: Types.Int32) : SET;
      VAR
	 set: SET;
	 index: INTEGER;
   BEGIN
      IF Types.msbIsMax = 1 THEN
	 set := SYS.VAL(SET, int);
      ELSE
	 set := {};
	 index := 0;
	 WHILE index < 32 DO
	    IF ODD(int) THEN
	       INCL(set, index);
	    END;
	    int := int DIV 2;
	    INC(index);
	 END;
      END;
      RETURN set
   END ConvertIntToSet32;

   PROCEDURE ConvertSet32ToInt(set: SET) : Types.Int32;
      VAR
	 int: Types.Int32;
	 index: INTEGER;
	 mask: Types.Int32;
   BEGIN
      IF Types.msbIsMax = 1 THEN
	 int := SYS.VAL(Types.Int32, set);
      ELSE
	 index := 0; mask := 1; int := 0;
	 WHILE index < 32 DO
	    IF index IN set THEN
	       int := int + mask;
	    END;
	    mask := mask * 2;
	    INC(index);
	 END;
      END;
      RETURN int
   END ConvertSet32ToInt;

   PROCEDURE ConvertIntToSet16(int: INTEGER) : KeySet;
      VAR
	 set: KeySet;
	 index: INTEGER;
   BEGIN
      set := {};
      index := 0;
      WHILE index < 16 DO
	 IF ODD(int) THEN
	    INCL(set, index);
	 END;
	 int := int DIV 2;
	 INC(index);
      END;
      RETURN set
   END ConvertIntToSet16;

   PROCEDURE ConvertSet16ToInt(set: KeySet) : INTEGER;
      VAR
	 int: INTEGER;
	 index: INTEGER;
	 mask: INTEGER;
   BEGIN
      index := 0; mask := 1; int := 0;
      WHILE index < 16 DO
	 IF index IN set THEN
	    int := int + mask;
	 END;
	 mask := mask * 2;
	 INC(index);
      END;
      RETURN int
   END ConvertSet16ToInt;

   PROCEDURE Pad(len: LONGINT) : INTEGER;
   BEGIN
      RETURN SHORT((4 - (len MOD 4)) MOD 4)
   END Pad;

   PROCEDURE WritePad(s: Streams.Stream; len: LONGINT) : BOOLEAN;
   BEGIN
      WHILE len > 0 DO
	 IF ~Streams.WriteByte(s, 0X) THEN RETURN FALSE END;
	 DEC(len);
      END;
      RETURN TRUE
   END WritePad;

   PROCEDURE WriteCard8(s: Streams.Stream; card8: INTEGER) : BOOLEAN;
   BEGIN
      RETURN Streams.WriteByte(s, CHR(card8 MOD 256))
   END WriteCard8;

   PROCEDURE WriteCard16(s: Streams.Stream; card16: INTEGER) : BOOLEAN;
      VAR
	 byte1, byte2: BYTE;
   BEGIN
      CASE Types.byteorder OF
      | Types.bigEndian:
	    byte1 := CHR(card16 DIV 256 MOD 256);
	    byte2 := CHR(card16 MOD 256);
      | Types.littleEndian:
	    byte1 := CHR(card16 MOD 256);
	    byte2 := CHR(card16 DIV 256 MOD 256);
      END;
      RETURN Streams.WriteByte(s, byte1) & Streams.WriteByte(s, byte2)
   END WriteCard16;

   PROCEDURE WriteInt16(s: Streams.Stream; int16: INTEGER) : BOOLEAN;
      VAR
	 i16: Types.Int16;
   BEGIN
      ASSERT((int16 >= MIN(Types.Int16)) & (int16 <= MAX(Types.Int16)));
      i16 := Types.ToInt16(int16);
      RETURN Streams.Write(s, i16)
   END WriteInt16;

   PROCEDURE WriteCard32(s: Streams.Stream; card32: Types.Int32) : BOOLEAN;
   BEGIN
      RETURN Streams.Write(s, card32)
   END WriteCard32;

   PROCEDURE WriteString8(s: Streams.Stream;
                          VAR buf: ARRAY OF BYTE; (* read-only *)
			  len: LONGINT) : BOOLEAN;
   BEGIN
      RETURN Streams.WritePart(s, buf, 0, len) &
	     WritePad(s, Pad(len))
   END WriteString8;

   PROCEDURE WriteAttributes(s: Streams.Stream;
                             ats: WindowAttributes) : BOOLEAN;
      VAR
	 valueMask: Types.Int32;
	 atIndex: INTEGER;
	 value: Types.Int32;
   BEGIN
      valueMask := ConvertSet32ToInt(ats.defined);
      IF ~WriteCard32(s, valueMask) THEN RETURN FALSE END;
      atIndex := 0;
      WHILE atIndex < attributes DO
	 IF atIndex IN ats.defined THEN
	    CASE atIndex OF
            | atBackgroundPixmap:
		  value := ats.backgroundPixmap;
            | atBackgroundPixel:
		  value := ats.backgroundPixel;
            | atBorderPixmap:
		  value := ats.borderPixmap;
            | atBorderPixel:
		  value := ats.borderPixel;
            | atBitGravity:
		  value := ats.bitGravity;
            | atWinGravity:
		  value := ats.winGravity;
            | atBackingStore:
		  value := ats.backingStore;
            | atBackingPlanes:
		  value := ats.backingPlanes;
            | atBackingPixel:
		  value := ats.backingPixel;
            | atOverrideRedirect:
		  value := SYS.VAL(SHORTINT, ats.overrideRedirect);
            | atSaveUnder:
		  value := SYS.VAL(SHORTINT, ats.saveUnder);
            | atEventMask:
		  value := ConvertSet32ToInt(ats.eventMask);
            | atDoNotPropagateMask:
		  value := ConvertSet32ToInt(ats.doNotPropagateMask);
            | atColormap:
		  value := ats.colormap;
            | atCursor:
		  value := ats.cursor;
	    END;
	    IF ~WriteCard32(s, value) THEN RETURN FALSE END;
	 END;
	 INC(atIndex);
      END;
      RETURN TRUE
   END WriteAttributes;

   PROCEDURE WriteGCAttributes(s: Streams.Stream;
                               ats: GraphicalContextAttributes) : BOOLEAN;
      VAR
	 valueMask: Types.Int32;
	 atIndex: INTEGER;
	 value: Types.Int32;
   BEGIN
      valueMask := ConvertSet32ToInt(ats.defined);
      IF ~WriteCard32(s, valueMask) THEN RETURN FALSE END;
      atIndex := 0;
      WHILE atIndex < gcAttributes DO
	 IF atIndex IN ats.defined THEN
	    CASE atIndex OF
            | gcFunction:
		  value := ats.function;
            | gcPlaneMask:
		  value := ats.planeMask;
            | gcForeground:
		  value := ats.foreground;
            | gcBackground:
		  value := ats.background;
            | gcLineWidth:
		  value := ats.lineWidth;
            | gcLineStyle:
		  value := ats.lineStyle;
            | gcCapStyle:
		  value := ats.capStyle;
            | gcJoinStyle:
		  value := ats.joinStyle;
            | gcFillStyle:
		  value := ats.fillStyle;
            | gcFillRule:
		  value := ats.fillRule;
            | gcTile:
		  value := ats.tile;
            | gcStipple:
		  value := ats.stipple;
            | gcTileStippleXOrigin:
		  value := ats.tileStippleXOrigin;
            | gcTileStippleYOrigin:
		  value := ats.tileStippleYOrigin;
            | gcFont:
		  value := ats.font;
            | gcSubwindowMode:
		  value := ats.subwindowMode;
            | gcGraphicsExposures:
		  value := SYS.VAL(SHORTINT, ats.graphicsExposures);
            | gcClipXOrigin:
		  value := ats.clipXOrigin;
            | gcClipYOrigin:
		  value := ats.clipYOrigin;
            | gcClipMask:
		  value := ats.clipMask;
            | gcDashOffset:
		  value := ats.dashOffset;
            | gcDashes:
		  value := ats.dashes;
            | gcArcMode:
		  value := ats.arcmode;
	    END;
	    IF ~WriteCard32(s, value) THEN RETURN FALSE END;
	 END;
	 INC(atIndex);
      END;
      RETURN TRUE
   END WriteGCAttributes;

   PROCEDURE ReadPad(s: Streams.Stream; len: LONGINT) : BOOLEAN;
      VAR
	 pad: BYTE;
   BEGIN
      WHILE len > 0 DO
	 IF ~Streams.ReadByte(s, pad) THEN RETURN FALSE END;
	 DEC(len);
      END;
      RETURN TRUE
   END ReadPad;

   PROCEDURE ReadBool(s: Streams.Stream; VAR bool: BOOLEAN) : BOOLEAN;
      VAR
	 byte: CHAR;
   BEGIN
      IF ~Streams.ReadByte(s, byte) THEN RETURN FALSE END;
      CASE byte OF
      | 0X: bool := FALSE; RETURN TRUE
      | 1X: bool := TRUE; RETURN TRUE
      ELSE
	 RETURN FALSE
      END;
   END ReadBool;

   PROCEDURE ReadCard8(s: Streams.Stream; VAR card8: INTEGER) : BOOLEAN;
      VAR
	 byte: CHAR;
   BEGIN
      IF ~Streams.ReadByte(s, byte) THEN RETURN FALSE END;
      card8 := ORD(byte);
      RETURN TRUE
   END ReadCard8;

   PROCEDURE ReadCard16(s: Streams.Stream; VAR card16: INTEGER) : BOOLEAN;
      VAR
	 byte1, byte2: BYTE;
   BEGIN
      IF ~Streams.ReadByte(s, byte1) OR ~Streams.ReadByte(s, byte2) THEN
	 RETURN FALSE
      END;
      CASE Types.byteorder OF
      | Types.bigEndian:
	    card16 := ORD(byte1) * 256 + ORD(byte2);
      | Types.littleEndian:
	    card16 := ORD(byte2) * 256 + ORD(byte1);
      END;
      RETURN TRUE
   END ReadCard16;

   PROCEDURE ReadInt16(s: Streams.Stream; VAR int16: INTEGER) : BOOLEAN;
      VAR
	 i16: Types.Int16;
   BEGIN
      IF ~Streams.Read(s, i16) THEN RETURN FALSE END;
      int16 := i16;
      RETURN TRUE
   END ReadInt16;

   PROCEDURE ReadCard32(s: Streams.Stream; VAR card32: Types.Int32) : BOOLEAN;
   BEGIN
      RETURN Streams.Read(s, card32)
   END ReadCard32;

   PROCEDURE ReadString8(s: Streams.Stream;
                         VAR buf: ARRAY OF BYTE;
			 len: LONGINT) : BOOLEAN;
      VAR
	 nbytes: LONGINT;
   BEGIN
      IF len > LEN(buf) THEN
	 (* actual stuff is longer than the buffer:
	    we fill just the buffer and skip the rest
	 *)
	 nbytes := LEN(buf);
	 IF ~Streams.ReadPart(s, buf, 0, nbytes) THEN RETURN FALSE END;
	 RETURN ReadPad(s, len - nbytes)
      ELSE
	 IF ~Streams.ReadPart(s, buf, 0, len) THEN RETURN FALSE END;
	 IF len < LEN(buf) THEN
	    (* assure 0X-termination in case of strings *)
	    buf[len] := 0X;
	 END;
	 RETURN TRUE
      END;
   END ReadString8;

   PROCEDURE ReadFormat(s: Streams.Stream; VAR format: Format) : BOOLEAN;
   BEGIN
      NEW(format); format.next := NIL;
      RETURN ReadCard8(s, format.depth) &
             ReadCard8(s, format.bitsPerPixel) &
	     ReadCard8(s, format.scanlinePad) &
	     ReadPad(s, 5)
   END ReadFormat;

   PROCEDURE ReadListOfFormats(s: Streams.Stream;
                               numberOfFormats: INTEGER;
			       VAR list: Format) : BOOLEAN;
      VAR
	 head, tail, format: Format;
   BEGIN
      head := NIL; tail := NIL;
      WHILE numberOfFormats > 0 DO
	 IF ~ReadFormat(s, format) THEN RETURN FALSE END;
	 IF head = NIL THEN
	    head := format;
	 ELSE
	    tail.next := format;
	 END;
	 tail := format;
	 DEC(numberOfFormats);
      END;
      list := head;
      RETURN TRUE
   END ReadListOfFormats;

   PROCEDURE ReadVisual(s: Streams.Stream; VAR visual: Visual) : BOOLEAN;
   BEGIN
      NEW(visual); visual.next := NIL;
      RETURN ReadCard32(s, visual.visualID) &
             ReadCard8(s, visual.class) &
	     ReadCard8(s, visual.bitsPerRGBValue) &
	     ReadCard16(s, visual.colormapEntries) &
	     ReadCard32(s, visual.redMask) &
	     ReadCard32(s, visual.greenMask) &
	     ReadCard32(s, visual.blueMask) &
	     ReadPad(s, 4)
   END ReadVisual;

   PROCEDURE ReadListOfVisuals(s: Streams.Stream;
                               numberOfVisuals: INTEGER;
			       VAR list: Visual) : BOOLEAN;
      VAR
	 head, tail, visual: Visual;
   BEGIN
      head := NIL; tail := NIL;
      WHILE numberOfVisuals > 0 DO
	 IF ~ReadVisual(s, visual) THEN RETURN FALSE END;
	 IF head = NIL THEN
	    head := visual;
	 ELSE
	    tail.next := visual;
	 END;
	 tail := visual;
	 DEC(numberOfVisuals);
      END;
      list := head;
      RETURN TRUE
   END ReadListOfVisuals;

   PROCEDURE ReadDepth(s: Streams.Stream; VAR depth: Depth) : BOOLEAN;
      VAR
	 numberOfVisuals: INTEGER;
   BEGIN
      NEW(depth); depth.next := NIL;
      RETURN ReadCard8(s, depth.depth) &
             ReadPad(s, 1) &
	     ReadCard16(s, numberOfVisuals) &
	     ReadPad(s, 4) &
	     ReadListOfVisuals(s, numberOfVisuals, depth.visuals)
   END ReadDepth;

   PROCEDURE ReadListOfDepths(s: Streams.Stream;
			      numberOfDepths: INTEGER;
                              VAR list: Depth) : BOOLEAN;
      VAR
	 head, tail, depth: Depth;
   BEGIN
      head := NIL; tail := NIL;
      WHILE numberOfDepths > 0 DO
	 IF ~ReadDepth(s, depth) THEN RETURN FALSE END;
	 IF head = NIL THEN
	    head := depth;
	 ELSE
	    tail.next := depth;
	 END;
	 tail := depth;
	 DEC(numberOfDepths);
      END;
      list := head;
      RETURN TRUE
   END ReadListOfDepths;

   PROCEDURE ReadScreen(s: Streams.Stream; VAR screen: Screen) : BOOLEAN;
      VAR
	 numberOfDepths: INTEGER;
   BEGIN
      NEW(screen); screen.next := NIL;
      RETURN ReadCard32(s, screen.root) &
             ReadCard32(s, screen.colorMap) &
	     ReadCard32(s, screen.whitePixel) &
	     ReadCard32(s, screen.blackPixel) &
	     ReadCard32(s, screen.blackPixel) &
	     ReadCard32(s, screen.currentInputMasks) &
	     ReadCard16(s, screen.widthInPixels) &
	     ReadCard16(s, screen.heightInPixels) &
	     ReadCard16(s, screen.minInstalledMaps) &
	     ReadCard16(s, screen.maxInstalledMaps) &
	     ReadCard32(s, screen.rootVisual) &
	     ReadCard8(s, screen.backingStores) &
	     ReadBool(s, screen.saveUnders) &
	     ReadCard8(s, screen.rootDepth) &
	     ReadCard8(s, numberOfDepths) &
	     ReadListOfDepths(s, numberOfDepths, screen.depths)
   END ReadScreen;

   PROCEDURE ReadListOfScreens(s: Streams.Stream;
			       numberOfScreens: INTEGER;
                               VAR list: Screen) : BOOLEAN;
      VAR
	 head, tail, screen: Screen;
   BEGIN
      head := NIL; tail := NIL;
      WHILE numberOfScreens > 0 DO
	 IF ~ReadScreen(s, screen) THEN RETURN FALSE END;
	 IF head = NIL THEN
	    head := screen;
	 ELSE
	    tail.next := screen;
	 END;
	 tail := screen;
	 DEC(numberOfScreens);
      END;
      list := head;
      RETURN TRUE
   END ReadListOfScreens;

   PROCEDURE ^GetEventType(con: Connection;
                          type: INTEGER;
			  VAR eventType: Events.EventType);

   PROCEDURE ReadButtonPressEvent(s: Streams.Stream;
				  con: Connection;
                                  VAR event: XEvent);
      VAR
	 ev: ButtonPressEvent;
	 state: INTEGER;
	 ok: BOOLEAN;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) & (ev.code = buttonPressEvent) &
            ReadCard8(s, ev.button) &
	    ReadCard16(s, ev.sequenceNumber) &
	    ReadCard32(s, ev.timestamp) &
	    ReadCard32(s, ev.root) &
	    ReadCard32(s, ev.event) &
	    ReadCard32(s, ev.child) &
	    ReadCard16(s, ev.rootx) &
	    ReadCard16(s, ev.rooty) &
	    ReadCard16(s, ev.eventx) &
	    ReadCard16(s, ev.eventy) &
	    ReadCard16(s, state) &
	    ReadBool(s, ev.sameScreen);
      ASSERT(ok);
      ev.state := ConvertIntToSet16(state);
      GetEventType(con, buttonPressEvent, ev.type);
      COPY(eventName[buttonPressEvent], ev.message);
      event := ev;
   END ReadButtonPressEvent;

   PROCEDURE ReadCirculateNotifyEvent(s: Streams.Stream;
                                      con: Connection;
				      VAR event: XEvent);
      VAR
	 ev: CirculateNotifyEvent;
	 ok: BOOLEAN;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) & (ev.code = circulateNotifyEvent) &
            ReadPad(s, 1) &
	    ReadCard16(s, ev.sequenceNumber) &
	    ReadCard32(s, ev.event) &
	    ReadCard32(s, ev.window) &
	    ReadPad(s, 4) &
	    ReadCard8(s, ev.place);
      ASSERT(ok);
      GetEventType(con, circulateNotifyEvent, ev.type);
      COPY(eventName[circulateNotifyEvent], ev.message);
      event := ev;
   END ReadCirculateNotifyEvent;

   PROCEDURE ReadCirculateRequestEvent(s: Streams.Stream;
                                       con: Connection;
				       VAR event: XEvent);
      VAR
	 ev: CirculateRequestEvent;
	 ok: BOOLEAN;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) & (ev.code = circulateRequestEvent) &
            ReadPad(s, 1) &
	    ReadCard16(s, ev.sequenceNumber) &
	    ReadCard32(s, ev.parent) &
	    ReadCard32(s, ev.window) &
	    ReadPad(s, 4) &
	    ReadCard8(s, ev.place);
      ASSERT(ok);
      GetEventType(con, circulateRequestEvent, ev.type);
      COPY(eventName[circulateRequestEvent], ev.message);
      event := ev;
   END ReadCirculateRequestEvent;

   PROCEDURE ReadClientMessageEvent(s: Streams.Stream;
                                    con: Connection;
				    VAR event: XEvent);
      VAR
	 ev: ClientMessageEvent;
	 ok: BOOLEAN;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) & (ev.code = clientMessageEvent) &
            ReadCard8(s, ev.format) &
	    ReadCard16(s, ev.sequenceNumber) &
	    ReadCard32(s, ev.window) &
	    ReadCard32(s, ev.atom) &
	    SubStreams.Open(ev.data, s, 12, 20, con);
      ASSERT(ok);
      GetEventType(con, clientMessageEvent, ev.type);
      COPY(eventName[clientMessageEvent], ev.message);
      event := ev;
   END ReadClientMessageEvent;

   PROCEDURE ReadColormapNotifyEvent(s: Streams.Stream;
                                     con: Connection;
				     VAR event: XEvent);
      VAR
	 ev: ColormapNotifyEvent;
	 ok: BOOLEAN;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) & (ev.code = colormapNotifyEvent) &
            ReadPad(s, 1) &
	    ReadCard16(s, ev.sequenceNumber) &
	    ReadCard32(s, ev.window) &
	    ReadCard32(s, ev.colormap) &
	    ReadBool(s, ev.new) &
	    ReadCard8(s, ev.state);
      ASSERT(ok);
      GetEventType(con, colormapNotifyEvent, ev.type);
      COPY(eventName[colormapNotifyEvent], ev.message);
      event := ev;
   END ReadColormapNotifyEvent;

   PROCEDURE ReadConfigureNotifyEvent(s: Streams.Stream;
                                      con: Connection;
				      VAR event: XEvent);
      VAR
	 ev: ConfigureNotifyEvent;
	 ok: BOOLEAN;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) & (ev.code = configureNotifyEvent) &
            ReadPad(s, 1) &
	    ReadCard16(s, ev.sequenceNumber) &
	    ReadCard32(s, ev.event) &
	    ReadCard32(s, ev.window) &
	    ReadCard32(s, ev.aboveSibling) &
	    ReadInt16(s, ev.x) &
	    ReadInt16(s, ev.y) &
	    ReadCard16(s, ev.width) &
	    ReadCard16(s, ev.height) &
	    ReadCard16(s, ev.borderWidth) &
	    ReadBool(s, ev.overrideRedirect);
      ASSERT(ok);
      GetEventType(con, configureNotifyEvent, ev.type);
      COPY(eventName[configureNotifyEvent], ev.message);
      event := ev;
   END ReadConfigureNotifyEvent;

   PROCEDURE ReadConfigureRequestEvent(s: Streams.Stream;
                                       con: Connection;
				       VAR event: XEvent);
      VAR
	 ev: ConfigureRequestEvent;
	 ok: BOOLEAN;
	 valueMask: INTEGER;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) & (ev.code = configureRequestEvent) &
            ReadCard8(s, ev.stackMode) &
	    ReadCard16(s, ev.sequenceNumber) &
	    ReadCard32(s, ev.parent) &
	    ReadCard32(s, ev.window) &
	    ReadCard32(s, ev.sibling) &
	    ReadInt16(s, ev.x) &
	    ReadInt16(s, ev.y) &
	    ReadCard16(s, ev.width) &
	    ReadCard16(s, ev.height) &
	    ReadCard16(s, ev.borderWidth) &
	    ReadCard16(s, valueMask);
      ASSERT(ok);
      ev.valueMask := ConvertIntToSet16(valueMask);
      GetEventType(con, configureRequestEvent, ev.type);
      COPY(eventName[configureRequestEvent], ev.message);
      event := ev;
   END ReadConfigureRequestEvent;

   PROCEDURE ReadCreateNotifyEvent(s: Streams.Stream;
                                   con: Connection;
				   VAR event: XEvent);
      VAR
	 ev: CreateNotifyEvent;
	 ok: BOOLEAN;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) & (ev.code = createNotifyEvent) &
            ReadPad(s, 1) &
	    ReadCard16(s, ev.sequenceNumber) &
	    ReadCard32(s, ev.parent) &
	    ReadCard32(s, ev.window) &
	    ReadInt16(s, ev.x) &
	    ReadInt16(s, ev.y) &
	    ReadCard16(s, ev.width) &
	    ReadCard16(s, ev.height) &
	    ReadCard16(s, ev.borderWidth) &
	    ReadBool(s, ev.overrideRedirect);
      ASSERT(ok);
      GetEventType(con, createNotifyEvent, ev.type);
      COPY(eventName[createNotifyEvent], ev.message);
      event := ev;
   END ReadCreateNotifyEvent;

   PROCEDURE ReadDestroyNotifyEvent(s: Streams.Stream;
                                    con: Connection;
				    VAR event: XEvent);
      VAR
	 ev: DestroyNotifyEvent;
	 ok: BOOLEAN;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) & (ev.code = destroyNotifyEvent) &
            ReadPad(s, 1) &
	    ReadCard16(s, ev.sequenceNumber) &
	    ReadCard32(s, ev.event) &
	    ReadCard32(s, ev.window);
      ASSERT(ok);
      GetEventType(con, destroyNotifyEvent, ev.type);
      COPY(eventName[destroyNotifyEvent], ev.message);
      event := ev;
   END ReadDestroyNotifyEvent;

   PROCEDURE ReadEnterOrLeaveNotifyEvent(s: Streams.Stream;
                                         con: Connection;
				         VAR event: XEvent);
      VAR
	 ev: EnterOrLeaveNotifyEvent;
	 ok: BOOLEAN;
	 state: INTEGER;
	 bitset: INTEGER;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) &
	       (ev.code IN {enterNotifyEvent, leaveNotifyEvent}) &
            ReadCard8(s, ev.detail) &
	    ReadCard16(s, ev.sequenceNumber) &
	    ReadCard32(s, ev.time) &
	    ReadCard32(s, ev.root) &
	    ReadCard32(s, ev.event) &
	    ReadCard32(s, ev.child) &
	    ReadInt16(s, ev.rootx) &
	    ReadInt16(s, ev.rooty) &
	    ReadInt16(s, ev.eventx) &
	    ReadInt16(s, ev.eventy) &
	    ReadCard16(s, state) &
            ReadCard8(s, ev.mode) &
            ReadCard8(s, bitset);
      ASSERT(ok);
      ev.state := ConvertIntToSet16(state);
      ev.focus := ODD(bitset); bitset := bitset DIV 2;
      ev.sameScreen := ODD(bitset);
      GetEventType(con, ev.code, ev.type);
      COPY(eventName[ev.code], ev.message);
      event := ev;
   END ReadEnterOrLeaveNotifyEvent;

   PROCEDURE ReadExposeEvent(s: Streams.Stream;
                             con: Connection;
			     VAR event: XEvent);
      VAR
	 ev: ExposeEvent;
	 ok: BOOLEAN;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) & (ev.code = exposeEvent) &
            ReadPad(s, 1) &
	    ReadCard16(s, ev.sequenceNumber) &
	    ReadCard32(s, ev.window) &
	    ReadCard16(s, ev.x) &
	    ReadCard16(s, ev.y) &
	    ReadCard16(s, ev.width) &
	    ReadCard16(s, ev.height) &
	    ReadCard16(s, ev.count);
      ASSERT(ok);
      GetEventType(con, exposeEvent, ev.type);
      COPY(eventName[exposeEvent], ev.message);
      event := ev;
   END ReadExposeEvent;

   PROCEDURE ReadFocusEvent(s: Streams.Stream;
                            con: Connection;
			    VAR event: XEvent);
      VAR
	 ev: FocusEvent;
	 ok: BOOLEAN;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) &
	       (ev.code IN {focusInEvent, focusOutEvent}) &
            ReadCard8(s, ev.detail) &
	    ReadCard16(s, ev.sequenceNumber) &
	    ReadCard32(s, ev.event) &
            ReadCard8(s, ev.mode);
      ASSERT(ok);
      GetEventType(con, ev.code, ev.type);
      COPY(eventName[ev.code], ev.message);
      event := ev;
   END ReadFocusEvent;

   PROCEDURE ReadGraphicsExposeEvent(s: Streams.Stream;
                                     con: Connection;
			             VAR event: XEvent);
      VAR
	 ev: GraphicsExposeEvent;
	 ok: BOOLEAN;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) & (ev.code = graphicsExposeEvent) &
            ReadPad(s, 1) &
	    ReadCard16(s, ev.sequenceNumber) &
	    ReadCard32(s, ev.drawable) &
	    ReadCard16(s, ev.x) &
	    ReadCard16(s, ev.y) &
	    ReadCard16(s, ev.width) &
	    ReadCard16(s, ev.height) &
	    ReadCard16(s, ev.minorOpcode) &
	    ReadCard16(s, ev.count) &
	    ReadCard8(s, ev.majorOpcode);
      ASSERT(ok);
      GetEventType(con, graphicsExposeEvent, ev.type);
      COPY(eventName[graphicsExposeEvent], ev.message);
      event := ev;
   END ReadGraphicsExposeEvent;

   PROCEDURE ReadGravityNotifyEvent(s: Streams.Stream;
                                    con: Connection;
			            VAR event: XEvent);
      VAR
	 ev: GravityNotifyEvent;
	 ok: BOOLEAN;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) & (ev.code = gravityNotifyEvent) &
            ReadPad(s, 1) &
	    ReadCard16(s, ev.sequenceNumber) &
	    ReadCard32(s, ev.event) &
	    ReadCard32(s, ev.window) &
	    ReadCard16(s, ev.x) &
	    ReadCard16(s, ev.y);
      ASSERT(ok);
      GetEventType(con, gravityNotifyEvent, ev.type);
      COPY(eventName[gravityNotifyEvent], ev.message);
      event := ev;
   END ReadGravityNotifyEvent;

   PROCEDURE ReadKeymapNotifyEvent(s: Streams.Stream;
                                   con: Connection;
			           VAR event: XEvent);
      VAR
	 ev: KeymapNotifyEvent;
	 ok: BOOLEAN;
	 key: INTEGER;
	 set8: INTEGER;
	 i: INTEGER;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) & (ev.code = keymapNotifyEvent);
      ASSERT(ok);
      Sets.InitSet(ev.keys);
      key := 8; (* the first 8 bits are not included in this event *)
      WHILE key < keys DO
	 ok := ReadCard8(s, set8); ASSERT(ok);
	 i := 0;
	 WHILE i < 8 DO
	    IF ODD(set8) THEN
	       Sets.Incl(ev.keys, key);
	    END;
	    set8 := set8 DIV 2;
	    INC(i); INC(key);
	 END;
      END;
      GetEventType(con, keymapNotifyEvent, ev.type);
      COPY(eventName[keymapNotifyEvent], ev.message);
      event := ev;
   END ReadKeymapNotifyEvent;

   PROCEDURE ReadKeyEvent(s: Streams.Stream;
                          con: Connection;
			  VAR event: XEvent);
      VAR
	 ev: KeyEvent;
	 ok: BOOLEAN;
	 state: INTEGER;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) &
	       (ev.code IN {keyPressEvent, keyReleaseEvent}) &
            ReadCard8(s, ev.keycode) &
	    ReadCard16(s, ev.sequenceNumber) &
	    ReadCard32(s, ev.time) &
	    ReadCard32(s, ev.root) &
	    ReadCard32(s, ev.event) &
	    ReadCard32(s, ev.child) &
	    ReadInt16(s, ev.rootx) &
	    ReadInt16(s, ev.rooty) &
	    ReadInt16(s, ev.eventx) &
	    ReadInt16(s, ev.eventy) &
	    ReadCard16(s, state) &
	    ReadBool(s, ev.sameScreen);
      ASSERT(ok);
      ev.state := ConvertIntToSet16(state);
      GetEventType(con, ev.code, ev.type);
      COPY(eventName[ev.code], ev.message);
      event := ev;
   END ReadKeyEvent;

   PROCEDURE ReadMapNotifyEvent(s: Streams.Stream;
                                con: Connection;
				VAR event: XEvent);
      VAR
	 ev: MapNotifyEvent;
	 ok: BOOLEAN;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) & (ev.code = mapNotifyEvent) &
            ReadPad(s, 1) &
	    ReadCard16(s, ev.sequenceNumber) &
	    ReadCard32(s, ev.event) &
	    ReadCard32(s, ev.window) &
	    ReadBool(s, ev.overrideRedirect);
      ASSERT(ok);
      GetEventType(con, mapNotifyEvent, ev.type);
      COPY(eventName[mapNotifyEvent], ev.message);
      event := ev;
   END ReadMapNotifyEvent;

   PROCEDURE ReadMappingNotifyEvent(s: Streams.Stream;
                                    con: Connection;
			            VAR event: XEvent);
      VAR
	 ev: MappingNotifyEvent;
	 ok: BOOLEAN;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) & (ev.code = mappingNotifyEvent) &
            ReadPad(s, 1) &
	    ReadCard16(s, ev.sequenceNumber) &
	    ReadCard8(s, ev.request) &
	    ReadCard8(s, ev.firstKeycode) &
	    ReadCard8(s, ev.count);
      ASSERT(ok);
      GetEventType(con, mappingNotifyEvent, ev.type);
      COPY(eventName[mappingNotifyEvent], ev.message);
      event := ev;
   END ReadMappingNotifyEvent;

   PROCEDURE ReadMapRequestEvent(s: Streams.Stream;
                                 con: Connection;
			         VAR event: XEvent);
      VAR
	 ev: MapRequestEvent;
	 ok: BOOLEAN;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) & (ev.code = mapRequestEvent) &
            ReadPad(s, 1) &
	    ReadCard16(s, ev.sequenceNumber) &
	    ReadCard32(s, ev.parent) &
	    ReadCard32(s, ev.window);
      ASSERT(ok);
      GetEventType(con, mapRequestEvent, ev.type);
      COPY(eventName[mapRequestEvent], ev.message);
      event := ev;
   END ReadMapRequestEvent;

   PROCEDURE ReadMotionNotifyEvent(s: Streams.Stream;
				   con: Connection;
                                   VAR event: XEvent);
      VAR
	 ev: MotionNotifyEvent;
	 state: INTEGER;
	 ok: BOOLEAN;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) & (ev.code = motionNotifyEvent) &
            ReadCard8(s, ev.detail) &
	    ReadCard16(s, ev.sequenceNumber) &
	    ReadCard32(s, ev.time) &
	    ReadCard32(s, ev.root) &
	    ReadCard32(s, ev.event) &
	    ReadCard32(s, ev.child) &
	    ReadCard16(s, ev.rootx) &
	    ReadCard16(s, ev.rooty) &
	    ReadCard16(s, ev.eventx) &
	    ReadCard16(s, ev.eventy) &
	    ReadCard16(s, state) &
	    ReadBool(s, ev.sameScreen);
      ASSERT(ok);
      ev.state := ConvertIntToSet16(state);
      GetEventType(con, motionNotifyEvent, ev.type);
      COPY(eventName[motionNotifyEvent], ev.message);
      event := ev;
   END ReadMotionNotifyEvent;

   PROCEDURE ReadNoExposeEvent(s: Streams.Stream;
                                 con: Connection;
			         VAR event: XEvent);
      VAR
	 ev: NoExposeEvent;
	 ok: BOOLEAN;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) & (ev.code = noExposeEvent) &
            ReadPad(s, 1) &
	    ReadCard16(s, ev.sequenceNumber) &
	    ReadCard32(s, ev.drawable) &
	    ReadCard16(s, ev.minorOpcode) &
	    ReadCard8(s, ev.majorOpcode);
      ASSERT(ok);
      GetEventType(con, noExposeEvent, ev.type);
      COPY(eventName[noExposeEvent], ev.message);
      event := ev;
   END ReadNoExposeEvent;

   PROCEDURE ReadPropertyNotifyEvent(s: Streams.Stream;
				     con: Connection;
				     VAR event: XEvent);
      VAR
	 ev: PropertyNotifyEvent;
	 ok: BOOLEAN;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) & (ev.code = propertyNotifyEvent) &
            ReadPad(s, 1) &
	    ReadCard16(s, ev.sequenceNumber) &
	    ReadCard32(s, ev.window) &
	    ReadCard32(s, ev.atom) &
	    ReadCard32(s, ev.time) &
	    ReadCard8(s, ev.state);
      ASSERT(ok);
      GetEventType(con, propertyNotifyEvent, ev.type);
      COPY(eventName[propertyNotifyEvent], ev.message);
      event := ev;
   END ReadPropertyNotifyEvent;

   PROCEDURE ReadReparentNotifyEvent(s: Streams.Stream;
				     con: Connection;
				     VAR event: XEvent);
      VAR
	 ev: ReparentNotifyEvent;
	 ok: BOOLEAN;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) & (ev.code = reparentNotifyEvent) &
            ReadPad(s, 1) &
	    ReadCard16(s, ev.sequenceNumber) &
	    ReadCard32(s, ev.event) &
	    ReadCard32(s, ev.window) &
	    ReadCard32(s, ev.parent) &
	    ReadInt16(s, ev.x) &
	    ReadInt16(s, ev.y) &
	    ReadBool(s, ev.overrideRedirect);
      ASSERT(ok);
      GetEventType(con, reparentNotifyEvent, ev.type);
      COPY(eventName[reparentNotifyEvent], ev.message);
      event := ev;
   END ReadReparentNotifyEvent;

   PROCEDURE ReadResizeRequestEvent(s: Streams.Stream;
				    con: Connection;
				    VAR event: XEvent);
      VAR
	 ev: ResizeRequestEvent;
	 ok: BOOLEAN;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) & (ev.code = resizeRequestEvent) &
            ReadPad(s, 1) &
	    ReadCard16(s, ev.sequenceNumber) &
	    ReadCard32(s, ev.window) &
	    ReadCard16(s, ev.width) &
	    ReadCard16(s, ev.height);
      ASSERT(ok);
      GetEventType(con, resizeRequestEvent, ev.type);
      COPY(eventName[resizeRequestEvent], ev.message);
      event := ev;
   END ReadResizeRequestEvent;

   PROCEDURE ReadSelectionClearEvent(s: Streams.Stream;
				     con: Connection;
				     VAR event: XEvent);
      VAR
	 ev: SelectionClearEvent;
	 ok: BOOLEAN;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) & (ev.code = selectionClearEvent) &
            ReadPad(s, 1) &
	    ReadCard16(s, ev.sequenceNumber) &
	    ReadCard32(s, ev.time) &
	    ReadCard32(s, ev.owner) &
	    ReadCard32(s, ev.selection);
      ASSERT(ok);
      GetEventType(con, selectionClearEvent, ev.type);
      COPY(eventName[selectionClearEvent], ev.message);
      event := ev;
   END ReadSelectionClearEvent;

   PROCEDURE ReadSelectionNotifyEvent(s: Streams.Stream;
				      con: Connection;
				      VAR event: XEvent);
      VAR
	 ev: SelectionNotifyEvent;
	 ok: BOOLEAN;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) & (ev.code = selectionNotifyEvent) &
            ReadPad(s, 1) &
	    ReadCard16(s, ev.sequenceNumber) &
	    ReadCard32(s, ev.time) &
	    ReadCard32(s, ev.requestor) &
	    ReadCard32(s, ev.selection) &
	    ReadCard32(s, ev.target) &
	    ReadCard32(s, ev.property);
      ASSERT(ok);
      GetEventType(con, selectionNotifyEvent, ev.type);
      COPY(eventName[selectionNotifyEvent], ev.message);
      event := ev;
   END ReadSelectionNotifyEvent;

   PROCEDURE ReadSelectionRequestEvent(s: Streams.Stream;
				       con: Connection;
				       VAR event: XEvent);
      VAR
	 ev: SelectionRequestEvent;
	 ok: BOOLEAN;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) & (ev.code = selectionRequestEvent) &
            ReadPad(s, 1) &
	    ReadCard16(s, ev.sequenceNumber) &
	    ReadCard32(s, ev.time) &
	    ReadCard32(s, ev.owner) &
	    ReadCard32(s, ev.requestor) &
	    ReadCard32(s, ev.selection) &
	    ReadCard32(s, ev.target) &
	    ReadCard32(s, ev.property);
      ASSERT(ok);
      GetEventType(con, selectionRequestEvent, ev.type);
      COPY(eventName[selectionRequestEvent], ev.message);
      event := ev;
   END ReadSelectionRequestEvent;

   PROCEDURE ReadUnmapNotifyEvent(s: Streams.Stream;
                                  con: Connection;
				  VAR event: XEvent);
      VAR
	 ev: UnmapNotifyEvent;
	 ok: BOOLEAN;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) & (ev.code = unmapNotifyEvent) &
            ReadPad(s, 1) &
	    ReadCard16(s, ev.sequenceNumber) &
	    ReadCard32(s, ev.event) &
	    ReadCard32(s, ev.window) &
	    ReadBool(s, ev.fromConfigure);
      ASSERT(ok);
      GetEventType(con, unmapNotifyEvent, ev.type);
      COPY(eventName[unmapNotifyEvent], ev.message);
      event := ev;
   END ReadUnmapNotifyEvent;

   PROCEDURE ReadVisibilityNotifyEvent(s: Streams.Stream;
                                       con: Connection;
				       VAR event: XEvent);
      VAR
	 ev: VisibilityNotifyEvent;
	 ok: BOOLEAN;
   BEGIN
      NEW(ev);
      ok := ReadCard8(s, ev.code) & (ev.code = visibilityNotifyEvent) &
            ReadPad(s, 1) &
	    ReadCard16(s, ev.sequenceNumber) &
	    ReadCard32(s, ev.window) &
	    ReadCard8(s, ev.state);
      ASSERT(ok);
      GetEventType(con, visibilityNotifyEvent, ev.type);
      COPY(eventName[visibilityNotifyEvent], ev.message);
      event := ev;
   END ReadVisibilityNotifyEvent;

   PROCEDURE Disconnect(connection: Connection);
      VAR
	 request: OpenRequest;
   BEGIN
      IF ~SYS.TAS(connection.closed) THEN
	 Semaphores.P(connection.mutex);
	 Streams.Release(connection.s);
	 Semaphores.V(connection.mutex);
	 Resources.Notify(connection, Resources.terminated);
	 (* deliver signals for open requests to
	    avoid hanging tasks
	 *)
	 request := connection.openRequests;
	 connection.openRequests := NIL;
	 WHILE request # NIL DO
	    Signals.Raise(request.signal);
	    request := request.next;
	 END;
      END;
   END Disconnect;

   PROCEDURE CreateErrorEvent(con: Connection;
                              s: Streams.Stream;
			      VAR event: XErrorEvent);
      VAR
	 code: INTEGER; (* general code, should be 0 *)
	 errorCode: INTEGER; (* error code *)
	 sequenceNumber: INTEGER;
	 errorParameter: Types.Int32;
	 majorOpcode, minorOpcode: INTEGER;
	 ok: BOOLEAN;
	 msg: Streams.Stream;
   BEGIN
      ok := ReadCard8(s, code) & ReadCard8(s, errorCode) &
            ReadCard16(s, sequenceNumber) &
	    ReadCard32(s, errorParameter) &
	    ReadCard16(s, minorOpcode) &
	    ReadCard8(s, majorOpcode);
      ASSERT(ok);
      Streams.SetPos(s, 0);
      NEW(event);
      event.type := xErrorEventType;
      Strings.Open(msg, event.message);
      Write.StringS(msg, "X Error ");
      IF (errorCode >= 1) & (errorCode < LEN(errorCodeName)) THEN
	 Write.StringS(msg, errorCodeName[errorCode]);
      ELSE
	 Write.IntS(msg, errorCode, 1);
      END;
      event.con := con;
      event.code := errorCode;
      event.sequenceNumber := sequenceNumber;
      event.majorOpcode := majorOpcode;
      event.minorOpcode := minorOpcode;
      event.errorParameter := errorParameter;
      event.packet := s;
   END CreateErrorEvent;

   PROCEDURE NextSequenceNumber(con: Connection);
   BEGIN
      con.nextSequenceNumber :=
	 (con.nextSequenceNumber + 1) MOD sequenceNumbers;
   END NextSequenceNumber;

   PROCEDURE InsertOpenRequest(con: Connection; VAR request: OpenRequest);
      VAR
	 openRequest: OpenRequest;
   BEGIN
      NEW(openRequest);
      openRequest.sequenceNumber := con.nextSequenceNumber;
      NextSequenceNumber(con);
      Signals.Create(openRequest.signal);
      openRequest.reply := NIL;
      openRequest.next := con.openRequests;
      con.openRequests := openRequest;
      request := openRequest;
   END InsertOpenRequest;

   PROCEDURE DeliverEvent(job: Jobs.Job);
   BEGIN
      WITH job: DeliverEventJob DO
	 Events.Raise(job.event);
      END;
   END DeliverEvent;

   PROCEDURE Raise(event: Events.Event);
      VAR
	 job: DeliverEventJob;
   BEGIN
      NEW(job); job.event := event;
      Jobs.Submit(job, DeliverEvent);
   END Raise;

   PROCEDURE InputHandler(job: Jobs.Job);
      CONST
	 maxpacketlen = 512;
	 minlen = 32;
      TYPE
	 Packet = POINTER TO ARRAY maxpacketlen OF BYTE;
      VAR
	 con: Connection;
	 in: Streams.Stream;
	 readCondition: Conditions.Condition;
	 termCondition: Conditions.Condition;
	 conditions: Conditions.ConditionSet;
	 eventType: Events.EventType;
	 resEvent: Resources.Event;
	 packet: Packet;
	 nbytes: Streams.Count;
	 prevInput: Streams.Stream; (* previous input, may be NIL *)
	 prevCount: Streams.Count; (* length of prevInput, if # NIL *)
	 newInput: Streams.Stream; (* represents new input packet *)
	 joinedInput: Streams.Stream; (* tied from prevInput & newInput *)
	 exactLength: Streams.Count; (* exact response length, if known *)
	 lengthKnown: BOOLEAN;
	 code: INTEGER; (* code of first byte of response *)
	 sequenceNumber: INTEGER; (* in case of server replies *)

      PROCEDURE JoinStreams;
	 VAR
	    ok: BOOLEAN;
      BEGIN
	 ok := SubStreams.Join(joinedInput,
	    prevInput, newInput, con);
	 ASSERT(ok);
      END JoinStreams;

      PROCEDURE SendResponse(s: Streams.Stream);
	 VAR
	    prevRequest, request: OpenRequest;
	    parser: EventParserProc;
	    event: XEvent;
	    errorEvent: XErrorEvent;

	 PROCEDURE FindOpenRequest(sequenceNumber: INTEGER;
	                           VAR request: OpenRequest) : BOOLEAN;
	    VAR
	       prevRequest: OpenRequest;
	 BEGIN
	    prevRequest := NIL; request := con.openRequests;
	    WHILE (request # NIL) &
		  (request.sequenceNumber # sequenceNumber) DO
	       prevRequest := request;
	       request := request.next;
	    END;
	    IF request = NIL THEN RETURN FALSE END;
	    (* remove open request out of the linear list *)
	    IF prevRequest = NIL THEN
	       con.openRequests := request.next;
	    ELSE
	       prevRequest.next := request.next;
	    END;
	    RETURN TRUE
	 END FindOpenRequest;

      BEGIN (* SendResponse *)
	 CASE code OF
	 | 0:
	       CreateErrorEvent(con, s, errorEvent);
	       IF FindOpenRequest(sequenceNumber, request) THEN
		  request.reply := NIL;
		  request.xerror := errorEvent;
		  Signals.Raise(request.signal);
	       ELSE
		  RelatedEvents.Raise(con, errorEvent);
	       END;
	 | 1:
	       IF FindOpenRequest(sequenceNumber, request) THEN
		  request.reply := s;
		  request.xerror := NIL;
		  Signals.Raise(request.signal);
	       END;
	 | 2..255:
	       parser := eventParser[code];
	       IF parser # NIL THEN
		  parser(s, con, event);
		  event.con := con;
		  Raise(event);
	       END;
	 END;
      END SendResponse;

      PROCEDURE Split(s: Streams.Stream;
		      cutoff, nbytes: Streams.Count;
                      VAR part1, part2: Streams.Stream);
	 VAR
	    ok: BOOLEAN;
      BEGIN
	 ok := SubStreams.Open(part1, s, 0, cutoff, con) &
	       SubStreams.Open(part2, s, cutoff, nbytes - cutoff, con);
	 ASSERT(ok);
      END Split;

      PROCEDURE InspectHeader;
	 (* take a look at the header of a packet of which at least
	    the first 32 bytes are visible and set following variables:
	       exactLength: exact length of the entire response packet
	       lengthKnown: is set to TRUE
	       code: integer representing the first byte of the packet
	 *)
	 VAR
	    extraLength: Types.Int32;
	    ok: BOOLEAN;
      BEGIN
	 ok := ReadCard8(joinedInput, code); ASSERT(ok);
	 IF code = 0 THEN
	    (* error packet *)
	    exactLength := 32;
	    ok := ReadPad(joinedInput, 1) &
		  ReadCard16(joinedInput, sequenceNumber);
	    ASSERT(ok);
	 ELSIF code = 1 THEN
	    (* reply to a request *)
	    ok := ReadPad(joinedInput, 1) &
		  ReadCard16(joinedInput, sequenceNumber) &
		  ReadCard32(joinedInput, extraLength);
	    ASSERT(ok);
	    exactLength := 32 + extraLength * 4;
	 ELSE
	    (* event packet *)
	    exactLength := 32;
	 END;
	 lengthKnown := TRUE;
	 Streams.SetPos(joinedInput, 0);
      END InspectHeader;

   BEGIN (* InputHandler *)
      con := job(InputHandlerJob).con; in := con.s;
      IF con.closed THEN RETURN END;
      Conditions.CreateSet(conditions);
      StreamConditions.Create(readCondition, in, StreamConditions.read);
      IF readCondition = NIL THEN
	 (* the input stream is apparently already closed *)
	 RETURN
      END;
      Conditions.Incl(conditions, readCondition);
      Resources.TakeInterest(con, eventType);
      EventConditions.Create(termCondition, eventType);
      Conditions.Incl(conditions, termCondition);
      prevInput := NIL; prevCount := 0; lengthKnown := FALSE;
      LOOP
	 Tasks.WaitForOneOf(conditions);
	 IF EventConditions.TestAndGet(termCondition, resEvent) THEN
	    IF resEvent.change = Resources.terminated THEN
	       EXIT
	    END;
	 ELSE
	    (* input stream is ready for reading;
	       note that we are just allowed to read in this case
	       to avoid a locked connection stream as
	       write operations occur in parallel
	    *)
	    NEW(packet);
	    Semaphores.P(con.mutex);
	    nbytes := Streams.ReadPacket(in, packet^, 0, maxpacketlen);
	    Semaphores.V(con.mutex);
	    IF nbytes = 0 THEN
	       Disconnect(con); EXIT
	    END;
	    MemStreams.Open(newInput, SYS.ADR(packet^),
	       nbytes, MemStreams.read);
	    (* join streams, if there is input left
	       from previous read operations
	    *)
	    IF prevInput = NIL THEN
	       joinedInput := newInput;
	    ELSE
	       JoinStreams;
	       INC(nbytes, prevCount);
	       prevInput := NIL; prevCount := 0;
	    END;
	    (* process all packets in joinedInput *)
	    LOOP
	       IF nbytes < minlen THEN EXIT END;
	       IF ~lengthKnown THEN
		  InspectHeader;
	       END;
	       IF nbytes < exactLength THEN EXIT END;
	       IF nbytes = exactLength THEN
		  SendResponse(joinedInput);
		  lengthKnown := FALSE;
		  joinedInput := NIL;
		  EXIT
	       END;
	       Split(joinedInput, exactLength, nbytes, prevInput, newInput);
	       SendResponse(prevInput);
	       DEC(nbytes, exactLength);
	       lengthKnown := FALSE;
	       joinedInput := newInput; prevInput := NIL;
	    END;
	    (* keep rest of unprocessed input in prevInput *)
	    IF joinedInput # NIL THEN
	       prevInput := joinedInput; prevCount := nbytes;
	       joinedInput := NIL;
	    END;
	 END;
      END;
      EventConditions.Drop(termCondition);
   END InputHandler;

   PROCEDURE GetConnection(VAR s: Streams.Stream;
			   ds: Streams.Stream; (* display spec as stream *)
                           VAR auth: XAuthority.AuthRec;
			   VAR server: Server;
			   VAR screenNumber: INTEGER;
			   errors: RelatedEvents.Object) : BOOLEAN;
      CONST
	 XPort = 6000;
	 socketpath = "/tmp/.X11-unix/X";
	 major = 11; minor = 0; (* desired X11 protocol *)
      VAR
	 hostname: DNSRecords.Name;
	 displayNumber: INTEGER;

      PROCEDURE ParseDisplay(s: Streams.Stream;
                             VAR hostname: ARRAY OF CHAR;
			     VAR display: INTEGER;
			     VAR screenNumber: INTEGER) : BOOLEAN;
      BEGIN
	 (* first try the full format including screen number *)
	 Scan.S3(s, "%[^:]:%d.%d", hostname, display, screenNumber);
	 IF s.count = 3 THEN RETURN TRUE END;
	 (* as next try the same without screen number *)
	 screenNumber := 0;
	 Streams.SetPos(s, 0);
	 Scan.S2(s, "%[^:]:%d", hostname, display);
	 IF s.count = 2 THEN RETURN TRUE END;
	 RETURN FALSE
      END ParseDisplay;

      PROCEDURE SetDisplayNumber;
	 VAR ds: Streams.Stream;
      BEGIN
	 NEW(auth.number);
	 auth.number.string[0] := 0X; Strings.Open(ds, auth.number.string);
	 Write.IntS(ds, displayNumber, 0);
	 Streams.Release(ds);
	 auth.number.len := SHORT(Strings.Len(auth.number.string));
      END SetDisplayNumber;

      PROCEDURE TryLocalConnection() : BOOLEAN;
	 VAR
	    socketname: ARRAY 512 OF CHAR;
	    sns: Streams.Stream;
      BEGIN
	 socketname[0] := 0X; Strings.Open(sns, socketname);
	 Write.StringS(sns, socketpath); Write.IntS(sns, displayNumber, 0);
	 Streams.Release(sns);
	 IF ~UnixDomainSockets.Open(s, socketname, Streams.onebuf, errors) THEN
	    RETURN FALSE
	 END;
	 auth.family := XAuthority.familyLocal;
	 NEW(auth.address);
	 UnixHost.GetHostName(auth.address.string);
	 auth.address.len := SHORT(Strings.Len(auth.address.string));
	 RETURN TRUE
      END TryLocalConnection;

      PROCEDURE TryNetworkConnection() : BOOLEAN;
	 VAR
	    addresses: DNSResolvers.IPv4AddressList;
	    ipaddr: IPv4Addresses.Address;
	    hs: Streams.Stream;

	 PROCEDURE Try(ipaddr: IPv4Addresses.Address) : BOOLEAN;
	    VAR
	       socketaddr: IPv4Addresses.SocketAddress;
	       myhostname: DNSRecords.Name;
	 BEGIN
	    IPv4Addresses.SetPort(socketaddr, XPort + displayNumber);
	    socketaddr.host := ipaddr;
	    IF ~IPv4TCPSockets.Open(s, socketaddr, Streams.onebuf, errors) THEN
	       RETURN FALSE
	    END;
	    NEW(auth.address);
	    IF (hostname = "localhost") OR (hostname = "127.0.0.1") THEN
	       (* in case of localhost we have to lookup
		  the hostname in the authorization db
		  with auth.family set to familyLocal
	       *)
	       UnixHost.GetHostName(auth.address.string);
	       auth.address.len := SHORT(Strings.Len(auth.address.string));
	       auth.family := XAuthority.familyLocal;
	    ELSE
	       auth.address.len := SHORT(SYS.SIZE(IPv4Addresses.Address));
	       MemOps.Copy(SYS.ADR(ipaddr), SYS.ADR(auth.address.string),
		  auth.address.len);
	       auth.family := XAuthority.familyInternet;
	    END;
	    RETURN TRUE
	 END Try;

      BEGIN (* TryNetworkConnection *)
	 IF ~DNSResolvers.GetIPv4AddrByHost(DNSResolvers.std,
	       hostname, addresses, errors) THEN
	    Strings.Open(hs, hostname);
	    IF IPv4Addresses.ReadText(hs, ipaddr) & Try(ipaddr) THEN
	       RETURN TRUE
	    END;
	    RETURN FALSE
	 END;
	 WHILE addresses # NIL DO
	    IF Try(addresses.addr) THEN RETURN TRUE END;
	    addresses := addresses.next;
	 END;
	 RETURN FALSE
      END TryNetworkConnection;

      PROCEDURE GetAuth;
      BEGIN
	 IF XAuthority.GetAuthByAddr(auth, errors) THEN
	    IF auth.name = NIL THEN NEW(auth.name); auth.name.len := 0; END;
	    IF auth.data = NIL THEN NEW(auth.data); auth.data.len := 0; END;
	 ELSE
	    NEW(auth.name); auth.name.len := 0;
	    NEW(auth.data); auth.data.len := 0;
	 END;
      END GetAuth;

      PROCEDURE SendGreeting() : BOOLEAN;
	 VAR
	    bytesex: CHAR;
      BEGIN
	 CASE Types.byteorder OF
	 | Types.bigEndian:
	       bytesex := "B";
	 | Types.littleEndian:
	       bytesex := "l";
	 END;
	 RETURN Streams.WriteByte(s, bytesex) &
		WritePad(s, 1) &
	        WriteCard16(s, major) &
	        WriteCard16(s, minor) &
		WriteCard16(s, auth.name.len) &
		WriteCard16(s, auth.data.len) &
		WritePad(s, 2) &
		WriteString8(s, auth.name.string, auth.name.len) &
		WriteString8(s, auth.data.string, auth.data.len) &
		Streams.Flush(s)
      END SendGreeting;

      PROCEDURE ReadResponse() : BOOLEAN;
	 VAR
	    success: BOOLEAN;
	    len: INTEGER;
	    units: INTEGER;
	    reason: ARRAY 128 OF CHAR;
	    serverMajor, serverMinor: INTEGER;
	    releaseNumber: Types.Int32;
	    resourceIDbase: Types.Int32;
	    resourceIDmask: Types.Int32;
	    motionBufferSize: Types.Int32;
	    vendorLength: INTEGER;
	    maximumRequestLength: INTEGER;
	    numberOfScreens: INTEGER;
	    numberOfFormats: INTEGER;
	    imageByteOrder: INTEGER;
	    bitmapFormatBitOrder: INTEGER;
	    bitmapFormatScanlineUnit: INTEGER;
	    bitmapFormatScanlinePad: INTEGER;
	    minKeyCode, maxKeyCode: INTEGER;
	    vendor: ARRAY 128 OF CHAR;
	    listOfFormats: Format;
	    listOfScreens: Screen;
      BEGIN
	 IF ~ReadBool(s, success) THEN
	    ConnectionError(errors, invalidWelcome, ds, "");
	    RETURN FALSE
	 END;
	 IF success THEN
	    IF ~ReadPad(s, 1) OR
		  ~ReadCard16(s, serverMajor) OR
		  ~ReadCard16(s, serverMinor) OR
		  ~ReadCard16(s, units) OR
		  ~ReadCard32(s, releaseNumber) OR
		  ~ReadCard32(s, resourceIDbase) OR
		  ~ReadCard32(s, resourceIDmask) OR
		  ~ReadCard32(s, motionBufferSize) OR
		  ~ReadCard16(s, vendorLength) OR
		  ~ReadCard16(s, maximumRequestLength) OR
		  ~ReadCard8(s, numberOfScreens) OR
		  ~ReadCard8(s, numberOfFormats) OR
		  ~ReadCard8(s, imageByteOrder) OR
		  ~ReadCard8(s, bitmapFormatBitOrder) OR
		  ~ReadCard8(s, bitmapFormatScanlineUnit) OR
		  ~ReadCard8(s, bitmapFormatScanlinePad) OR
		  ~ReadCard8(s, minKeyCode) OR
		  ~ReadCard8(s, maxKeyCode) OR
		  ~ReadPad(s, 4) OR
		  ~ReadString8(s, vendor, vendorLength) OR
		  ~ReadPad(s, Pad(vendorLength)) OR
		  ~ReadListOfFormats(s, numberOfFormats, listOfFormats) OR
		  ~ReadListOfScreens(s, numberOfScreens, listOfScreens) THEN
	       ConnectionError(errors, invalidWelcome, ds, "");
	       RETURN FALSE
	    END;
	    NEW(server);
	    server.major := serverMajor;
	    server.minor := serverMinor;
	    server.releaseNumber := releaseNumber;
	    server.resourceIDbase := resourceIDbase;
	    server.resourceIDmask := resourceIDmask;
	    server.motionBufferSize := motionBufferSize;
	    server.maximumRequestLength := maximumRequestLength;
	    server.numberOfScreens := numberOfScreens;
	    server.numberOfFormats := numberOfFormats;
	    server.imageByteOrder := imageByteOrder;
	    server.bitmapFormatBitOrder := bitmapFormatBitOrder;
	    server.bitmapFormatScanlineUnit := bitmapFormatScanlineUnit;
	    server.bitmapFormatScanlinePad := bitmapFormatScanlinePad;
	    server.minKeyCode := minKeyCode;
	    server.maxKeyCode := maxKeyCode;
	    COPY(vendor, server.vendor);
	    server.listOfFormats := listOfFormats;
	    server.listOfScreens := listOfScreens;
	    RETURN TRUE
	 ELSE
	    IF ~ReadCard8(s, len) OR
		  ~ReadCard16(s, serverMajor) OR
		  ~ReadCard16(s, serverMinor) OR
		  ~ReadCard16(s, units) OR
		  ~ReadString8(s, reason, units * 4) THEN
	       ConnectionError(errors, invalidWelcome, ds, "");
	       RETURN FALSE (* because of read error *)
	    END;
	    ConnectionError(errors, connectionRejected, ds, reason);
	    RETURN FALSE (* because we weren't successful *)
	 END;
      END ReadResponse;

   BEGIN (* GetConnection *)
      IF ~ParseDisplay(ds, hostname, displayNumber, screenNumber) THEN
	 ConnectionError(errors, invalidDisplaySpecification, ds, "");
	 RETURN FALSE
      END;
      IF screenNumber < 0 THEN
	 ConnectionError(errors, invalidScreenNumber, ds, "");
	 RETURN FALSE
      END;
      IF hostname = "" THEN
	 IF ~TryLocalConnection() THEN
	    ConnectionError(errors, localConnectionFailed, ds, "");
	    RETURN FALSE
	 END;
      ELSE
	 IF ~TryNetworkConnection() THEN
	    ConnectionError(errors, networkConnectionFailed, ds, "");
	    RETURN FALSE
	 END;
      END;
      SetDisplayNumber;
      GetAuth;
      RelatedEvents.Forward(s, errors);
      IF ~SendGreeting() THEN
	 ConnectionError(errors, greetingFailed, ds, "");
	 Streams.Release(s);
	 RETURN FALSE
      END;
      IF ~ReadResponse() THEN
	 Streams.Release(s);
	 RETURN FALSE
      END;
      IF screenNumber >= server.numberOfScreens THEN
	 ConnectionError(errors, noSuchScreenNumber, ds, "");
	 Streams.Release(s);
	 RETURN FALSE
      END;
      ASSERT(s # NIL);
      RETURN TRUE
   END GetConnection;

   PROCEDURE TerminationHandler(event: Events.Event);
   BEGIN
      WITH event: Resources.Event DO
	 IF event.change IN {Resources.terminated, Resources.unreferenced} THEN
	    Disconnect(event.resource(Connection));
	 END;
      END;
   END TerminationHandler;

   (* === module initialization ============================================ *)

   PROCEDURE Init;
      VAR
	 index: INTEGER;
   BEGIN
      (* names of event types *)
      eventTypeName[keyPress] := "KeyPress";
      eventTypeName[keyRelease] := "KeyRelease";
      eventTypeName[buttonPress] := "ButtonPress";
      eventTypeName[buttonRelease] := "ButtonRelease";
      eventTypeName[enterWindow] := "EnterWindow";
      eventTypeName[leaveWindow] := "LeaveWindow";
      eventTypeName[pointerMotion] := "PointerMotion";
      eventTypeName[pointerMotionHint] := "PointerMotionHint";
      eventTypeName[button1Motion] := "Button1Motion";
      eventTypeName[button2Motion] := "Button2Motion";
      eventTypeName[button3Motion] := "Button3Motion";
      eventTypeName[button4Motion] := "Button4Motion";
      eventTypeName[button5Motion] := "Button5Motion";
      eventTypeName[buttonMotion] := "ButtonMotion";
      eventTypeName[keymapState] := "KeymapState";
      eventTypeName[exposure] := "Exposure";
      eventTypeName[visibilityChange] := "VisibilityChange";
      eventTypeName[structureNotify] := "StructureNotify";
      eventTypeName[resizeRedirect] := "ResizeRedirect";
      eventTypeName[substructureNotify] := "SubstructureNotify";
      eventTypeName[substructureRedirect] := "SubstructureRedirect";
      eventTypeName[focusChange] := "FocusChange";
      eventTypeName[propertyChange] := "PropertyChange";
      eventTypeName[colormapChange] := "ColormapChange";
      eventTypeName[ownerGrabButton] := "OwnerGrabButton";
      (* names of error codes *)
      errorCodeName[0] := "invalid";
      errorCodeName[requestError] := "Request";
      errorCodeName[valueError] := "Value";
      errorCodeName[windowError] := "Window";
      errorCodeName[pixmapError] := "Pixmap";
      errorCodeName[atomError] := "Atom";
      errorCodeName[cursorError] := "Cursor";
      errorCodeName[fontError] := "Font";
      errorCodeName[matchError] := "Match";
      errorCodeName[drawableError] := "Drawable";
      errorCodeName[accessError] := "Access";
      errorCodeName[allocError] := "Alloc";
      errorCodeName[colormapError] := "Colormap";
      errorCodeName[gContextError] := "GContext";
      errorCodeName[idChoiceError] := "IDChoice";
      errorCodeName[nameError] := "Name";
      errorCodeName[lengthError] := "Length";
      errorCodeName[implementationError] := "Implementation";
      Events.Define(xErrorEventType);
      Errors.AssignWriteProcedure(xErrorEventType, WriteXError);
      (* names of special keys *)
      keyName[shiftKey] := "Shift";
      keyName[lockKey] := "Lock";
      keyName[controlKey] := "Control";
      keyName[mod1Key] := "Mod1";
      keyName[mod2Key] := "Mod2";
      keyName[mod3Key] := "Mod3";
      keyName[mod4Key] := "Mod4";
      keyName[mod5Key] := "Mod5";
      keyName[button1Key] := "Button1";
      keyName[button2Key] := "Button2";
      keyName[button3Key] := "Button3";
      keyName[button4Key] := "Button4";
      keyName[button5Key] := "Button5";
      (* initialize eventParser array *)
      index := 0;
      WHILE index < LEN(eventParser) DO
	 eventParser[index] := NIL;
	 INC(index);
      END;
      eventParser[buttonPressEvent] := ReadButtonPressEvent;
      eventParser[circulateNotifyEvent] := ReadCirculateNotifyEvent;
      eventParser[circulateRequestEvent] := ReadCirculateRequestEvent;
      eventParser[clientMessageEvent] := ReadClientMessageEvent;
      eventParser[colormapNotifyEvent] := ReadColormapNotifyEvent;
      eventParser[configureNotifyEvent] := ReadConfigureNotifyEvent;
      eventParser[configureRequestEvent] := ReadConfigureRequestEvent;
      eventParser[createNotifyEvent] := ReadCreateNotifyEvent;
      eventParser[destroyNotifyEvent] := ReadDestroyNotifyEvent;
      eventParser[enterNotifyEvent] := ReadEnterOrLeaveNotifyEvent;
      eventParser[exposeEvent] := ReadExposeEvent;
      eventParser[focusInEvent] := ReadFocusEvent;
      eventParser[focusOutEvent] := ReadFocusEvent;
      eventParser[graphicsExposeEvent] := ReadGraphicsExposeEvent;
      eventParser[gravityNotifyEvent] := ReadGravityNotifyEvent;
      eventParser[keymapNotifyEvent] := ReadKeymapNotifyEvent;
      eventParser[keyPressEvent] := ReadKeyEvent;
      eventParser[keyReleaseEvent] := ReadKeyEvent;
      eventParser[leaveNotifyEvent] := ReadEnterOrLeaveNotifyEvent;
      eventParser[mapNotifyEvent] := ReadMapNotifyEvent;
      eventParser[mappingNotifyEvent] := ReadMappingNotifyEvent;
      eventParser[mapRequestEvent] := ReadMapRequestEvent;
      eventParser[motionNotifyEvent] := ReadMotionNotifyEvent;
      eventParser[noExposeEvent] := ReadNoExposeEvent;
      eventParser[propertyNotifyEvent] := ReadPropertyNotifyEvent;
      eventParser[reparentNotifyEvent] := ReadReparentNotifyEvent;
      eventParser[resizeRequestEvent] := ReadResizeRequestEvent;
      eventParser[selectionClearEvent] := ReadSelectionClearEvent;
      eventParser[selectionNotifyEvent] := ReadSelectionNotifyEvent;
      eventParser[selectionRequestEvent] := ReadSelectionRequestEvent;
      eventParser[unmapNotifyEvent] := ReadUnmapNotifyEvent;
      eventParser[visibilityNotifyEvent] := ReadVisibilityNotifyEvent;
      (* initialize X event names *)
      xeventName[0] := ""; xeventName[1] := "";
      xeventName[keyPressEvent] := "KeyPress";
      xeventName[keyReleaseEvent] := "KeyRelease";
      xeventName[buttonPressEvent] := "ButtonPress";
      xeventName[motionNotifyEvent] := "MotionNotify";
      xeventName[enterNotifyEvent] := "EnterNotify";
      xeventName[leaveNotifyEvent] := "LeaveNotify";
      xeventName[focusInEvent] := "FocusIn";
      xeventName[focusOutEvent] := "FocusOut";
      xeventName[keymapNotifyEvent] := "KeymapNotify";
      xeventName[exposeEvent] := "Expose";
      xeventName[graphicsExposeEvent] := "GraphicsExpose";
      xeventName[noExposeEvent] := "NoExpose";
      xeventName[visibilityNotifyEvent] := "VisibilityNotify";
      xeventName[createNotifyEvent] := "CreateNotify";
      xeventName[destroyNotifyEvent] := "DestroyNotify";
      xeventName[unmapNotifyEvent] := "UnmapNotify";
      xeventName[mapNotifyEvent] := "MapNotify";
      xeventName[mapRequestEvent] := "MapRequest";
      xeventName[reparentNotifyEvent] := "ReparentNotify";
      xeventName[configureNotifyEvent] := "ConfigureNotify";
      xeventName[configureRequestEvent] := "ConfigureRequest";
      xeventName[gravityNotifyEvent] := "GravityNotify";
      xeventName[resizeRequestEvent] := "ResizeRequest";
      xeventName[circulateNotifyEvent] := "CirculateNotify";
      xeventName[circulateRequestEvent] := "CirculateRequest";
      xeventName[propertyNotifyEvent] := "PropertyNotify";
      xeventName[selectionClearEvent] := "SelectionClear";
      xeventName[selectionRequestEvent] := "SelectionRequest";
      xeventName[selectionNotifyEvent] := "SelectionNotify";
      xeventName[colormapNotifyEvent] := "ColormapNotify";
      xeventName[clientMessageEvent] := "ClientMessage";
      xeventName[mappingNotifyEvent] := "MappingNotify";
      (* initialize error handling *)
      Events.Define(error);
      errormsg[connectionRejected] := "connection rejected by X server";
      errormsg[invalidDisplaySpecification] :=
	 "invalid display specification";
      errormsg[missingDisplaySpecification] :=
	 "missing display specification";
      errormsg[invalidScreenNumber] :=
	 "invalid screen number";
      errormsg[localConnectionFailed] :=
	 "connection to local X server failed";
      errormsg[networkConnectionFailed] :=
	 "connection to remote X server failed";
      errormsg[greetingFailed] :=
	 "initial greeting to X server could not be sent";
      errormsg[invalidWelcome] :=
	 "initial response by X server was invalid";
      errormsg[noSuchScreenNumber] :=
	 "no such screen number";
      errormsg[outOfResourceIDs] :=
	 "out of resource ids";
      Errors.AssignWriteProcedure(error, WriteError);
   END Init;

   (* === public procedures ================================================ *)

   PROCEDURE GetNumberOfScreens(connection: Connection) : INTEGER;
   BEGIN
      RETURN connection.server.numberOfScreens
   END GetNumberOfScreens;

   PROCEDURE SetScreen(connection: Connection; screenNumber: INTEGER);
      VAR
	 screen: Screen;
   BEGIN
      ASSERT((screenNumber >= 0) &
	 (screenNumber < connection.server.numberOfScreens));
      screen := connection.server.listOfScreens;
      WHILE screenNumber > 0 DO
	 screen := screen.next;
	 DEC(screenNumber);
      END;
      connection.screen := screen;
   END SetScreen;

   PROCEDURE GetScreenNumber(connection: Connection) : INTEGER;
      VAR
	 screenNumber: INTEGER;
	 screen: Screen;
   BEGIN
      screenNumber := 0;
      screen := connection.server.listOfScreens;
      WHILE screen # connection.screen DO
	 INC(screenNumber);
	 screen := screen.next;
      END;
      RETURN screenNumber
   END GetScreenNumber;

   PROCEDURE Open(VAR connection: Connection;
                  display: ARRAY OF CHAR;
		  errors: RelatedEvents.Object) : BOOLEAN;
      VAR
	 s: Streams.Stream;
	 auth: XAuthority.AuthRec;
	 server: Server;
	 con: Connection;
	 displayNumber: INTEGER;
	 eventType: Events.EventType;
	 type: INTEGER;
	 inputHandler: InputHandlerJob;
	 ds, ds2: Streams.Stream; (* display stream *)
	 ok: BOOLEAN;
   BEGIN
      IF display # "" THEN
	 Strings.Open(ds, display);
      ELSIF ~UnixEnvironment.Open(ds, "DISPLAY") THEN
	 ConnectionError(errors, missingDisplaySpecification, NIL, "");
	 RETURN FALSE
      END;
      IF ~GetConnection(s, ds, auth, server, displayNumber, errors) THEN
	 RETURN FALSE
      END;
      ASSERT(s # NIL);
      NEW(con); RelatedEvents.QueueEvents(con);
      Strings.Open(ds2, con.display);
      Streams.SetPos(ds, 0);
      ok := Streams.Copy(ds, ds2, -1);
      con.s := s; con.server := server;
      SetScreen(con, displayNumber);
      LocalSemaphores.Create(con.mutex);
      con.closed := FALSE;
      Resources.TakeInterest(con, eventType);
      Events.Handler(eventType, TerminationHandler);
      con.nextSequenceNumber := 1;
      con.openRequests := NIL;
      con.id := 0;
      type := 0;
      WHILE type < 256 DO
	 con.eventType[type] := NIL;
	 INC(type);
      END;
      NEW(inputHandler); inputHandler.con := con;
      Jobs.Submit(inputHandler, InputHandler);
      connection := con;
      RETURN TRUE
   END Open;

   PROCEDURE Flush(connection: Connection) : BOOLEAN;
      VAR
	 ok: BOOLEAN;
   BEGIN
      Semaphores.P(connection.mutex);
      ok := Streams.Flush(connection.s);
      Semaphores.V(connection.mutex);
      IF ~ok THEN
	 Disconnect(connection);
      END;
      RETURN ok
   END Flush;

   PROCEDURE GetVendor(connection: Connection;
                       VAR vendor: ARRAY OF CHAR);
   BEGIN
      COPY(connection.server.vendor, vendor);
   END GetVendor;

   PROCEDURE GetProtocolVersion(connection: Connection;
                                VAR major, minor: INTEGER);
   BEGIN
      major := connection.server.major;
      minor := connection.server.minor;
   END GetProtocolVersion;

   PROCEDURE GetRootWindow(connection: Connection) : WindowID;
   BEGIN
      RETURN connection.screen.root
   END GetRootWindow;

   PROCEDURE GetWhitePixel(connection: Connection) : PixmapID;
   BEGIN
      RETURN connection.screen.whitePixel
   END GetWhitePixel;

   PROCEDURE GetBlackPixel(connection: Connection) : PixmapID;
   BEGIN
      RETURN connection.screen.blackPixel
   END GetBlackPixel;

   PROCEDURE GetResourceIDRange(connection: Connection;
                                VAR resourceIDbase: ResourceID;
				VAR resourceIDmask: ResourceID);
   BEGIN
      resourceIDbase := connection.server.resourceIDbase;
      resourceIDmask := connection.server.resourceIDmask;
   END GetResourceIDRange;

   PROCEDURE GetEventType(con: Connection;
                          type: INTEGER;
			  VAR eventType: Events.EventType);
   BEGIN
      IF con.eventType[type] = NIL THEN
	 Events.Define(con.eventType[type]);
	 Events.Handler(con.eventType[type], Events.NilHandler);
      END;
      eventType := con.eventType[type];
   END GetEventType;

   PROCEDURE CreateGC(connection: Connection;
                      cid: GContextID;
		      drawable: DrawableID;
		      gcats: GraphicalContextAttributes) : BOOLEAN;
      VAR
	 s: Streams.Stream;
	 ok: BOOLEAN;
   BEGIN
      Semaphores.P(connection.mutex);
      NextSequenceNumber(connection);
      s := connection.s;
      ok := WriteCard8(s, createGC) &
	    WritePad(s, 1) &
	    WriteCard16(s, 4 + Card(gcats.defined)) & (* request length *)
	    WriteCard32(s, cid) &
	    WriteCard32(s, drawable) &
	    WriteGCAttributes(s, gcats);
      Semaphores.V(connection.mutex);
      IF ~ok THEN
	 Disconnect(connection); RETURN FALSE
      END;
      RETURN TRUE
   END CreateGC;

   PROCEDURE CreateWindow(connection: Connection;
                          wid, parent: WindowID;
			  class: INTEGER;
			  depth: INTEGER;
			  visual: VisualID;
			  x, y: INTEGER;
			  width, height: INTEGER;
			  borderWidth: INTEGER;
			  winats: WindowAttributes) : BOOLEAN;
      VAR
	 s: Streams.Stream;
	 ok: BOOLEAN;
   BEGIN
      Semaphores.P(connection.mutex);
      NextSequenceNumber(connection);
      s := connection.s;
      ok := WriteCard8(s, createWindow) &
	    WriteCard8(s, 0) & (* take depth from parent *)
	    WriteCard16(s, 8 + Card(winats.defined)) & (* request length *)
	    WriteCard32(s, wid) &
	    WriteCard32(s, parent) &
	    WriteInt16(s, x) &
	    WriteInt16(s, y) &
	    WriteCard16(s, width) &
	    WriteCard16(s, height) &
	    WriteCard16(s, borderWidth) &
	    WriteCard16(s, class) &
	    WriteCard32(s, visual) &
	    WriteAttributes(s, winats);
      Semaphores.V(connection.mutex);
      IF ~ok THEN
	 Disconnect(connection); RETURN FALSE
      END;
      RETURN TRUE
   END CreateWindow;

   PROCEDURE ChangeWindowAttributes(connection: Connection;
                                    window: WindowID;
				    winats: WindowAttributes) : BOOLEAN;
      VAR
	 s: Streams.Stream;
	 ok: BOOLEAN;
   BEGIN
      Semaphores.P(connection.mutex);
      NextSequenceNumber(connection);
      s := connection.s;
      ok := WriteCard8(s, changeWindowAttributes) &
	    WritePad(s, 1) &
	    WriteCard16(s, 3 + Card(winats.defined)) & (* request length *)
	    WriteCard32(s, window) &
	    WriteAttributes(s, winats);
      Semaphores.V(connection.mutex);
      IF ~ok THEN
	 Disconnect(connection); RETURN FALSE
      END;
      RETURN TRUE
   END ChangeWindowAttributes;

   PROCEDURE GetWindowAttributes(connection: Connection;
                                 window: WindowID;
				 VAR winats: WindowAttributes;
				 VAR extra: ExtraWindowAttributes) : BOOLEAN;
      VAR
	 s: Streams.Stream;
	 ok: BOOLEAN;
	 request: OpenRequest;
	 ats: WindowAttributes;
	 xats: ExtraWindowAttributes;
	 allEventMasks, yourEventMask, doNotPropagateMask: Types.Int32;
   BEGIN
      Semaphores.P(connection.mutex);
      InsertOpenRequest(connection, request);
      s := connection.s;
      ok := WriteCard8(s, getWindowAttributes) &
            WritePad(s, 1) &
	    WriteCard16(s, 2) & (* request length *)
	    WriteCard32(s, window) &
	    Streams.Flush(s);
      Semaphores.V(connection.mutex);
      IF ~ok THEN
	 Disconnect(connection); RETURN FALSE
      END;
      Signals.WaitFor(request.signal);
      IF request.xerror # NIL THEN
	 RelatedEvents.Raise(connection, request.xerror);
	 RETURN FALSE
      END;
      IF request.reply = NIL THEN
	 RETURN FALSE
      END;
      NEW(ats); NEW(xats);
      s := request.reply;
      ok := ReadPad(s, 1) & (* skip reply code *)
            ReadCard8(s, ats.backingStore) &
	    ReadPad(s, 2 + 4) & (* sequence number and reply length *)
	    ReadCard32(s, xats.visual) &
	    ReadCard16(s, xats.class) &
	    ReadCard8(s, ats.bitGravity) &
	    ReadCard8(s, ats.winGravity) &
	    ReadCard32(s, ats.backingPlanes) &
	    ReadCard32(s, ats.backingPixel) &
	    ReadBool(s, ats.saveUnder) &
	    ReadBool(s, xats.mapIsInstalled) &
	    ReadCard8(s, xats.mapState) &
	    ReadBool(s, ats.overrideRedirect) &
	    ReadCard32(s, ats.colormap) &
	    ReadCard32(s, allEventMasks) &
	    ReadCard32(s, yourEventMask) &
	    ReadCard32(s, doNotPropagateMask);
      IF ~ok THEN
	 RETURN FALSE
      END;
      ats.eventMask := ConvertIntToSet32(yourEventMask);
      ats.doNotPropagateMask := ConvertIntToSet32(doNotPropagateMask);
      xats.allEventMasks := ConvertIntToSet32(allEventMasks);
      ats.defined := {
	 atBackingStore, atBitGravity, atWinGravity,
	 atBackingPlanes, atBackingPixel,
	 atSaveUnder, atEventMask, atDoNotPropagateMask
      };
      winats := ats;
      extra := xats;
      RETURN TRUE
   END GetWindowAttributes;

   PROCEDURE GetGeometry(connection: Connection;
                         drawable: DrawableID;
			 VAR geometry: Geometry) : BOOLEAN;
      VAR
	 s: Streams.Stream;
	 ok: BOOLEAN;
	 request: OpenRequest;
	 geo: Geometry;
   BEGIN
      Semaphores.P(connection.mutex);
      InsertOpenRequest(connection, request);
      s := connection.s;
      ok := WriteCard8(s, getGeometry) &
            WritePad(s, 1) &
	    WriteCard16(s, 2) & (* request length *)
	    WriteCard32(s, drawable) &
	    Streams.Flush(s);
      Semaphores.V(connection.mutex);
      IF ~ok THEN
	 Disconnect(connection); RETURN FALSE
      END;
      Signals.WaitFor(request.signal);
      IF request.xerror # NIL THEN
	 RelatedEvents.Raise(connection, request.xerror);
	 RETURN FALSE
      END;
      IF request.reply = NIL THEN
	 RETURN FALSE
      END;
      NEW(geo);
      s := request.reply;
      ok := ReadPad(s, 1) & (* skip reply code *)
            ReadCard8(s, geo.depth) &
	    ReadPad(s, 2 + 4) & (* sequence number and reply length *)
	    ReadCard32(s, geo.root) &
	    ReadInt16(s, geo.x) &
	    ReadInt16(s, geo.y) &
	    ReadCard16(s, geo.width) &
	    ReadCard16(s, geo.height) &
	    ReadCard16(s, geo.borderWidth);
      IF ~ok THEN
	 RETURN FALSE
      END;
      geometry := geo;
      RETURN TRUE
   END GetGeometry;

   PROCEDURE MapWindow(connection: Connection;
                       window: WindowID) : BOOLEAN;
      VAR
	 s: Streams.Stream;
	 ok: BOOLEAN;
   BEGIN
      Semaphores.P(connection.mutex);
      NextSequenceNumber(connection);
      s := connection.s;
      ok := WriteCard8(s, mapWindow) &
	    WritePad(s, 1) &
	    WriteCard16(s, 2) & (* request length *)
	    WriteCard32(s, window) &
	    Streams.Flush(s);
      Semaphores.V(connection.mutex);
      IF ~ok THEN
	 Disconnect(connection); RETURN FALSE
      END;
      RETURN TRUE
   END MapWindow;

   PROCEDURE PolyLine(connection: Connection;
                      drawable: DrawableID;
		      gc: GContextID;
		      coordinateMode: INTEGER;
		      points: ListOfPoints) : BOOLEAN;
      VAR
	 s: Streams.Stream;
	 ok: BOOLEAN;
	 count: INTEGER;
	 p: ListOfPoints;
   BEGIN
      IF points = NIL THEN RETURN TRUE END;
      Semaphores.P(connection.mutex);
      NextSequenceNumber(connection);
      p := points; count := 0;
      WHILE p # NIL DO
	 INC(count);
	 p := p.next;
      END;
      s := connection.s;
      ok := WriteCard8(s, polyLine) &
	    WriteCard8(s, coordinateMode) &
	    WriteCard16(s, 3 + count) & (* request length *)
	    WriteCard32(s, drawable) &
	    WriteCard32(s, gc);
      p := points;
      WHILE ok & (p # NIL) DO
	 ok := WriteInt16(s, p.x) & WriteInt16(s, p.y);
	 p := p.next;
      END;
      Semaphores.V(connection.mutex);
      IF ~ok THEN
	 Disconnect(connection); RETURN FALSE
      END;
      RETURN TRUE
   END PolyLine;

   PROCEDURE Close(connection: Connection);
   BEGIN
      Disconnect(connection);
   END Close;

BEGIN
   Init;
END XConnections.
